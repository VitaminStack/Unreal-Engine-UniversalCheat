#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CombatComponents

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CombatComponents_structs.hpp"


namespace SDK::Params
{

// Function CombatComponents.CCCollisionHandlerComponent.ActivateCollision
// 0x0001 (0x0001 - 0x0000)
struct CCCollisionHandlerComponent_ActivateCollision final
{
public:
	ECCCollisionPart                              CollisionPart;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCCollisionHandlerComponent_ActivateCollision) == 0x000001, "Wrong alignment on CCCollisionHandlerComponent_ActivateCollision");
static_assert(sizeof(CCCollisionHandlerComponent_ActivateCollision) == 0x000001, "Wrong size on CCCollisionHandlerComponent_ActivateCollision");
static_assert(offsetof(CCCollisionHandlerComponent_ActivateCollision, CollisionPart) == 0x000000, "Member 'CCCollisionHandlerComponent_ActivateCollision::CollisionPart' has a wrong offset!");

// Function CombatComponents.CCCollisionHandlerComponent.DrawDebugTrace
// 0x0030 (0x0030 - 0x0000)
struct CCCollisionHandlerComponent_DrawDebugTrace final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0018(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCCollisionHandlerComponent_DrawDebugTrace) == 0x000008, "Wrong alignment on CCCollisionHandlerComponent_DrawDebugTrace");
static_assert(sizeof(CCCollisionHandlerComponent_DrawDebugTrace) == 0x000030, "Wrong size on CCCollisionHandlerComponent_DrawDebugTrace");
static_assert(offsetof(CCCollisionHandlerComponent_DrawDebugTrace, Start) == 0x000000, "Member 'CCCollisionHandlerComponent_DrawDebugTrace::Start' has a wrong offset!");
static_assert(offsetof(CCCollisionHandlerComponent_DrawDebugTrace, End) == 0x000018, "Member 'CCCollisionHandlerComponent_DrawDebugTrace::End' has a wrong offset!");

// Function CombatComponents.CCCollisionHandlerComponent.DrawHitSphere
// 0x0018 (0x0018 - 0x0000)
struct CCCollisionHandlerComponent_DrawHitSphere final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCCollisionHandlerComponent_DrawHitSphere) == 0x000008, "Wrong alignment on CCCollisionHandlerComponent_DrawHitSphere");
static_assert(sizeof(CCCollisionHandlerComponent_DrawHitSphere) == 0x000018, "Wrong size on CCCollisionHandlerComponent_DrawHitSphere");
static_assert(offsetof(CCCollisionHandlerComponent_DrawHitSphere, Location) == 0x000000, "Member 'CCCollisionHandlerComponent_DrawHitSphere::Location' has a wrong offset!");

// Function CombatComponents.CCCollisionHandlerComponent.SetActiveCollisionPart
// 0x0001 (0x0001 - 0x0000)
struct CCCollisionHandlerComponent_SetActiveCollisionPart final
{
public:
	ECCCollisionPart                              CollisionPart;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCCollisionHandlerComponent_SetActiveCollisionPart) == 0x000001, "Wrong alignment on CCCollisionHandlerComponent_SetActiveCollisionPart");
static_assert(sizeof(CCCollisionHandlerComponent_SetActiveCollisionPart) == 0x000001, "Wrong size on CCCollisionHandlerComponent_SetActiveCollisionPart");
static_assert(offsetof(CCCollisionHandlerComponent_SetActiveCollisionPart, CollisionPart) == 0x000000, "Member 'CCCollisionHandlerComponent_SetActiveCollisionPart::CollisionPart' has a wrong offset!");

// Function CombatComponents.CCCollisionHandlerComponent.UpdateCollidingComponent
// 0x0018 (0x0018 - 0x0000)
struct CCCollisionHandlerComponent_UpdateCollidingComponent final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Sockets;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCCollisionHandlerComponent_UpdateCollidingComponent) == 0x000008, "Wrong alignment on CCCollisionHandlerComponent_UpdateCollidingComponent");
static_assert(sizeof(CCCollisionHandlerComponent_UpdateCollidingComponent) == 0x000018, "Wrong size on CCCollisionHandlerComponent_UpdateCollidingComponent");
static_assert(offsetof(CCCollisionHandlerComponent_UpdateCollidingComponent, Component) == 0x000000, "Member 'CCCollisionHandlerComponent_UpdateCollidingComponent::Component' has a wrong offset!");
static_assert(offsetof(CCCollisionHandlerComponent_UpdateCollidingComponent, Sockets) == 0x000008, "Member 'CCCollisionHandlerComponent_UpdateCollidingComponent::Sockets' has a wrong offset!");

// Function CombatComponents.CCCollisionHandlerComponent.UpdateCollidingComponents
// 0x0010 (0x0010 - 0x0000)
struct CCCollisionHandlerComponent_UpdateCollidingComponents final
{
public:
	TArray<struct FCCCollidingComponent>          collidingComponents;                               // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCCollisionHandlerComponent_UpdateCollidingComponents) == 0x000008, "Wrong alignment on CCCollisionHandlerComponent_UpdateCollidingComponents");
static_assert(sizeof(CCCollisionHandlerComponent_UpdateCollidingComponents) == 0x000010, "Wrong size on CCCollisionHandlerComponent_UpdateCollidingComponents");
static_assert(offsetof(CCCollisionHandlerComponent_UpdateCollidingComponents, collidingComponents) == 0x000000, "Member 'CCCollisionHandlerComponent_UpdateCollidingComponents::collidingComponents' has a wrong offset!");

// Function CombatComponents.CCCollisionHandlerComponent.GetActivatedCollisionPart
// 0x0001 (0x0001 - 0x0000)
struct CCCollisionHandlerComponent_GetActivatedCollisionPart final
{
public:
	ECCCollisionPart                              ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCCollisionHandlerComponent_GetActivatedCollisionPart) == 0x000001, "Wrong alignment on CCCollisionHandlerComponent_GetActivatedCollisionPart");
static_assert(sizeof(CCCollisionHandlerComponent_GetActivatedCollisionPart) == 0x000001, "Wrong size on CCCollisionHandlerComponent_GetActivatedCollisionPart");
static_assert(offsetof(CCCollisionHandlerComponent_GetActivatedCollisionPart, ReturnValue) == 0x000000, "Member 'CCCollisionHandlerComponent_GetActivatedCollisionPart::ReturnValue' has a wrong offset!");

// Function CombatComponents.CCCollisionHandlerComponent.IsCollisionActivated
// 0x0001 (0x0001 - 0x0000)
struct CCCollisionHandlerComponent_IsCollisionActivated final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCCollisionHandlerComponent_IsCollisionActivated) == 0x000001, "Wrong alignment on CCCollisionHandlerComponent_IsCollisionActivated");
static_assert(sizeof(CCCollisionHandlerComponent_IsCollisionActivated) == 0x000001, "Wrong size on CCCollisionHandlerComponent_IsCollisionActivated");
static_assert(offsetof(CCCollisionHandlerComponent_IsCollisionActivated, ReturnValue) == 0x000000, "Member 'CCCollisionHandlerComponent_IsCollisionActivated::ReturnValue' has a wrong offset!");

// Function CombatComponents.CCRotatingOwnerComponent.SetOwnerRotation
// 0x0018 (0x0018 - 0x0000)
struct CCRotatingOwnerComponent_SetOwnerRotation final
{
public:
	struct FRotator                               NewRotation;                                       // 0x0000(0x0018)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCRotatingOwnerComponent_SetOwnerRotation) == 0x000008, "Wrong alignment on CCRotatingOwnerComponent_SetOwnerRotation");
static_assert(sizeof(CCRotatingOwnerComponent_SetOwnerRotation) == 0x000018, "Wrong size on CCRotatingOwnerComponent_SetOwnerRotation");
static_assert(offsetof(CCRotatingOwnerComponent_SetOwnerRotation, NewRotation) == 0x000000, "Member 'CCRotatingOwnerComponent_SetOwnerRotation::NewRotation' has a wrong offset!");

// Function CombatComponents.CCRotatingOwnerComponent.StartRotating
// 0x0008 (0x0008 - 0x0000)
struct CCRotatingOwnerComponent_StartRotating final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         degressPerSecond;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCRotatingOwnerComponent_StartRotating) == 0x000004, "Wrong alignment on CCRotatingOwnerComponent_StartRotating");
static_assert(sizeof(CCRotatingOwnerComponent_StartRotating) == 0x000008, "Wrong size on CCRotatingOwnerComponent_StartRotating");
static_assert(offsetof(CCRotatingOwnerComponent_StartRotating, Time) == 0x000000, "Member 'CCRotatingOwnerComponent_StartRotating::Time' has a wrong offset!");
static_assert(offsetof(CCRotatingOwnerComponent_StartRotating, degressPerSecond) == 0x000004, "Member 'CCRotatingOwnerComponent_StartRotating::degressPerSecond' has a wrong offset!");

// Function CombatComponents.CCRotatingOwnerComponent.StartRotatingWithLimit
// 0x0008 (0x0008 - 0x0000)
struct CCRotatingOwnerComponent_StartRotatingWithLimit final
{
public:
	float                                         MaxPossibleRotation;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         degressPerSecond;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCRotatingOwnerComponent_StartRotatingWithLimit) == 0x000004, "Wrong alignment on CCRotatingOwnerComponent_StartRotatingWithLimit");
static_assert(sizeof(CCRotatingOwnerComponent_StartRotatingWithLimit) == 0x000008, "Wrong size on CCRotatingOwnerComponent_StartRotatingWithLimit");
static_assert(offsetof(CCRotatingOwnerComponent_StartRotatingWithLimit, MaxPossibleRotation) == 0x000000, "Member 'CCRotatingOwnerComponent_StartRotatingWithLimit::MaxPossibleRotation' has a wrong offset!");
static_assert(offsetof(CCRotatingOwnerComponent_StartRotatingWithLimit, degressPerSecond) == 0x000004, "Member 'CCRotatingOwnerComponent_StartRotatingWithLimit::degressPerSecond' has a wrong offset!");

// Function CombatComponents.CCRotatingOwnerComponent.IsRotating
// 0x0001 (0x0001 - 0x0000)
struct CCRotatingOwnerComponent_IsRotating final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCRotatingOwnerComponent_IsRotating) == 0x000001, "Wrong alignment on CCRotatingOwnerComponent_IsRotating");
static_assert(sizeof(CCRotatingOwnerComponent_IsRotating) == 0x000001, "Wrong size on CCRotatingOwnerComponent_IsRotating");
static_assert(offsetof(CCRotatingOwnerComponent_IsRotating, ReturnValue) == 0x000000, "Member 'CCRotatingOwnerComponent_IsRotating::ReturnValue' has a wrong offset!");

// Function CombatComponents.CCRotatingOwnerInterface.GetDesiredRotation
// 0x0018 (0x0018 - 0x0000)
struct CCRotatingOwnerInterface_GetDesiredRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CCRotatingOwnerInterface_GetDesiredRotation) == 0x000008, "Wrong alignment on CCRotatingOwnerInterface_GetDesiredRotation");
static_assert(sizeof(CCRotatingOwnerInterface_GetDesiredRotation) == 0x000018, "Wrong size on CCRotatingOwnerInterface_GetDesiredRotation");
static_assert(offsetof(CCRotatingOwnerInterface_GetDesiredRotation, ReturnValue) == 0x000000, "Member 'CCRotatingOwnerInterface_GetDesiredRotation::ReturnValue' has a wrong offset!");

}

