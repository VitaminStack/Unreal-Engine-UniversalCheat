#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CombatComponents

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CombatComponents_structs.hpp"
#include "AnimGraphRuntime_classes.hpp"


namespace SDK
{

// Class CombatComponents.CCActivateCollisionNotifyWindow
// 0x0008 (0x0040 - 0x0038)
class UCCActivateCollisionNotifyWindow final : public UAnimNotify_PlayMontageNotifyWindow
{
public:
	ECCCollisionPart                              CollisionPart;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CCActivateCollisionNotifyWindow">();
	}
	static class UCCActivateCollisionNotifyWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCCActivateCollisionNotifyWindow>();
	}
};
static_assert(alignof(UCCActivateCollisionNotifyWindow) == 0x000008, "Wrong alignment on UCCActivateCollisionNotifyWindow");
static_assert(sizeof(UCCActivateCollisionNotifyWindow) == 0x000040, "Wrong size on UCCActivateCollisionNotifyWindow");
static_assert(offsetof(UCCActivateCollisionNotifyWindow, CollisionPart) == 0x000038, "Member 'UCCActivateCollisionNotifyWindow::CollisionPart' has a wrong offset!");

// Class CombatComponents.CCClearHitActorsNotify
// 0x0000 (0x0040 - 0x0040)
class UCCClearHitActorsNotify final : public UAnimNotify_PlayMontageNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CCClearHitActorsNotify">();
	}
	static class UCCClearHitActorsNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCCClearHitActorsNotify>();
	}
};
static_assert(alignof(UCCClearHitActorsNotify) == 0x000008, "Wrong alignment on UCCClearHitActorsNotify");
static_assert(sizeof(UCCClearHitActorsNotify) == 0x000040, "Wrong size on UCCClearHitActorsNotify");

// Class CombatComponents.CCCollisionHandlerComponent
// 0x0150 (0x01F0 - 0x00A0)
class UCCCollisionHandlerComponent final : public UActorComponent
{
public:
	uint8                                         bTraceComplex : 1;                                 // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceRadius;                                       // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceCheckInterval;                                // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class AActor>>             IgnoredClasses;                                    // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class FName>                           IgnoredCollisionProfileNames;                      // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypesToCollideWith;                          // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoredActors;                                     // 0x00E0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	ECCCollisionPart                              ActivatedCollisionPart;                            // 0x00F0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCCCollidingComponent>          ActiveCollidingComponents;                         // 0x00F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         bIsCollisionActivated : 1;                         // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TimerHandle_TraceCheck;                            // 0x0110(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FVector>             LastFrameSocketLocations;                          // 0x0118(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(struct FHitResult& HitResult, class UPrimitiveComponent* CollidingComponent)> OnHit;                                             // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_180[0x18];                                     // 0x0180(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(ECCCollisionPart CollisionPart)> OnCollisionActivated;                              // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x18];                                     // 0x01A8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnCollisionDeactivated;                            // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x18];                                     // 0x01D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDebug : 1;                                        // 0x01E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateCollision(ECCCollisionPart CollisionPart);
	void ClearHitActors();
	void DeactivateCollision();
	void DrawDebugTrace(const struct FVector& Start, const struct FVector& End);
	void DrawHitSphere(const struct FVector& Location);
	void OnRep_IsCollisionActivated();
	void SetActiveCollisionPart(ECCCollisionPart CollisionPart);
	void TraceCheckLoop();
	void UpdateCollidingComponent(class UPrimitiveComponent* Component, const TArray<class FName>& Sockets);
	void UpdateCollidingComponents(const TArray<struct FCCCollidingComponent>& collidingComponents);

	ECCCollisionPart GetActivatedCollisionPart() const;
	bool IsCollisionActivated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CCCollisionHandlerComponent">();
	}
	static class UCCCollisionHandlerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCCCollisionHandlerComponent>();
	}
};
static_assert(alignof(UCCCollisionHandlerComponent) == 0x000008, "Wrong alignment on UCCCollisionHandlerComponent");
static_assert(sizeof(UCCCollisionHandlerComponent) == 0x0001F0, "Wrong size on UCCCollisionHandlerComponent");
static_assert(offsetof(UCCCollisionHandlerComponent, TraceRadius) == 0x0000A4, "Member 'UCCCollisionHandlerComponent::TraceRadius' has a wrong offset!");
static_assert(offsetof(UCCCollisionHandlerComponent, TraceCheckInterval) == 0x0000A8, "Member 'UCCCollisionHandlerComponent::TraceCheckInterval' has a wrong offset!");
static_assert(offsetof(UCCCollisionHandlerComponent, IgnoredClasses) == 0x0000B0, "Member 'UCCCollisionHandlerComponent::IgnoredClasses' has a wrong offset!");
static_assert(offsetof(UCCCollisionHandlerComponent, IgnoredCollisionProfileNames) == 0x0000C0, "Member 'UCCCollisionHandlerComponent::IgnoredCollisionProfileNames' has a wrong offset!");
static_assert(offsetof(UCCCollisionHandlerComponent, ObjectTypesToCollideWith) == 0x0000D0, "Member 'UCCCollisionHandlerComponent::ObjectTypesToCollideWith' has a wrong offset!");
static_assert(offsetof(UCCCollisionHandlerComponent, IgnoredActors) == 0x0000E0, "Member 'UCCCollisionHandlerComponent::IgnoredActors' has a wrong offset!");
static_assert(offsetof(UCCCollisionHandlerComponent, ActivatedCollisionPart) == 0x0000F0, "Member 'UCCCollisionHandlerComponent::ActivatedCollisionPart' has a wrong offset!");
static_assert(offsetof(UCCCollisionHandlerComponent, ActiveCollidingComponents) == 0x0000F8, "Member 'UCCCollisionHandlerComponent::ActiveCollidingComponents' has a wrong offset!");
static_assert(offsetof(UCCCollisionHandlerComponent, TimerHandle_TraceCheck) == 0x000110, "Member 'UCCCollisionHandlerComponent::TimerHandle_TraceCheck' has a wrong offset!");
static_assert(offsetof(UCCCollisionHandlerComponent, LastFrameSocketLocations) == 0x000118, "Member 'UCCCollisionHandlerComponent::LastFrameSocketLocations' has a wrong offset!");
static_assert(offsetof(UCCCollisionHandlerComponent, OnHit) == 0x000170, "Member 'UCCCollisionHandlerComponent::OnHit' has a wrong offset!");
static_assert(offsetof(UCCCollisionHandlerComponent, OnCollisionActivated) == 0x000198, "Member 'UCCCollisionHandlerComponent::OnCollisionActivated' has a wrong offset!");
static_assert(offsetof(UCCCollisionHandlerComponent, OnCollisionDeactivated) == 0x0001C0, "Member 'UCCCollisionHandlerComponent::OnCollisionDeactivated' has a wrong offset!");

// Class CombatComponents.CCRotateOwnerNotify
// 0x0008 (0x0048 - 0x0040)
class UCCRotateOwnerNotify final : public UAnimNotify_PlayMontageNotify
{
public:
	float                                         DegreesPerSecond;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPossibleRotation;                               // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CCRotateOwnerNotify">();
	}
	static class UCCRotateOwnerNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCCRotateOwnerNotify>();
	}
};
static_assert(alignof(UCCRotateOwnerNotify) == 0x000008, "Wrong alignment on UCCRotateOwnerNotify");
static_assert(sizeof(UCCRotateOwnerNotify) == 0x000048, "Wrong size on UCCRotateOwnerNotify");
static_assert(offsetof(UCCRotateOwnerNotify, DegreesPerSecond) == 0x000040, "Member 'UCCRotateOwnerNotify::DegreesPerSecond' has a wrong offset!");
static_assert(offsetof(UCCRotateOwnerNotify, MaxPossibleRotation) == 0x000044, "Member 'UCCRotateOwnerNotify::MaxPossibleRotation' has a wrong offset!");

// Class CombatComponents.CCRotateOwnerNotifyWindow
// 0x0008 (0x0040 - 0x0038)
class UCCRotateOwnerNotifyWindow final : public UAnimNotify_PlayMontageNotifyWindow
{
public:
	float                                         DegreesPerSecond;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CCRotateOwnerNotifyWindow">();
	}
	static class UCCRotateOwnerNotifyWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCCRotateOwnerNotifyWindow>();
	}
};
static_assert(alignof(UCCRotateOwnerNotifyWindow) == 0x000008, "Wrong alignment on UCCRotateOwnerNotifyWindow");
static_assert(sizeof(UCCRotateOwnerNotifyWindow) == 0x000040, "Wrong size on UCCRotateOwnerNotifyWindow");
static_assert(offsetof(UCCRotateOwnerNotifyWindow, DegreesPerSecond) == 0x000038, "Member 'UCCRotateOwnerNotifyWindow::DegreesPerSecond' has a wrong offset!");

// Class CombatComponents.CCRotatingOwnerComponent
// 0x0060 (0x0100 - 0x00A0)
class UCCRotatingOwnerComponent final : public UActorComponent
{
public:
	uint8                                         bIsRotating : 1;                                   // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_A1[0xF];                                       // 0x00A1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnRotatingStart;                                   // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x18];                                      // 0x00C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnRotatingEnd;                                     // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x18];                                      // 0x00E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NotifyOnRotatingEnd();
	void NotifyOnRotatingStart();
	void SetOwnerRotation(const struct FRotator& NewRotation);
	void StartRotating(float Time, float degressPerSecond);
	void StartRotatingWithLimit(float MaxPossibleRotation, float degressPerSecond);
	void StopRotating();

	bool IsRotating() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CCRotatingOwnerComponent">();
	}
	static class UCCRotatingOwnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCCRotatingOwnerComponent>();
	}
};
static_assert(alignof(UCCRotatingOwnerComponent) == 0x000008, "Wrong alignment on UCCRotatingOwnerComponent");
static_assert(sizeof(UCCRotatingOwnerComponent) == 0x000100, "Wrong size on UCCRotatingOwnerComponent");
static_assert(offsetof(UCCRotatingOwnerComponent, OnRotatingStart) == 0x0000B0, "Member 'UCCRotatingOwnerComponent::OnRotatingStart' has a wrong offset!");
static_assert(offsetof(UCCRotatingOwnerComponent, OnRotatingEnd) == 0x0000D8, "Member 'UCCRotatingOwnerComponent::OnRotatingEnd' has a wrong offset!");

// Class CombatComponents.CCRotatingOwnerInterface
// 0x0000 (0x0028 - 0x0028)
class ICCRotatingOwnerInterface final : public IInterface
{
public:
	struct FRotator GetDesiredRotation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CCRotatingOwnerInterface">();
	}
	static class ICCRotatingOwnerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICCRotatingOwnerInterface>();
	}
};
static_assert(alignof(ICCRotatingOwnerInterface) == 0x000008, "Wrong alignment on ICCRotatingOwnerInterface");
static_assert(sizeof(ICCRotatingOwnerInterface) == 0x000028, "Wrong size on ICCRotatingOwnerInterface");

}

