#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JSI_Slot

#include "Basic.hpp"

#include "JSI_Slot_classes.hpp"
#include "JSI_Slot_parameters.hpp"


namespace SDK
{

// Function JSI_Slot.JSI_Slot_C.AbleToStackTo?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      ToItem                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSI_Slot_C::AbleToStackTo_(class UJSI_Slot_C* ToItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "AbleToStackTo?");

	Params::JSI_Slot_C_AbleToStackTo_ Parms{};

	Parms.ToItem = ToItem;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.AdaptImageToActionbar
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTextureRenderTarget2D*           RenderTargetSnap_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::AdaptImageToActionbar(class UTextureRenderTarget2D* RenderTargetSnap_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "AdaptImageToActionbar");

	Params::JSI_Slot_C_AdaptImageToActionbar Parms{};

	Parms.RenderTargetSnap_0 = RenderTargetSnap_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.AddToXY
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   X                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Y                                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        SlotDimension                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::AddToXY(int32 X, int32 Y, struct FVector2D* SlotDimension)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "AddToXY");

	Params::JSI_Slot_C_AddToXY Parms{};

	Parms.X = X;
	Parms.Y = Y;

	UObject::ProcessEvent(Func, &Parms);

	if (SlotDimension != nullptr)
		*SlotDimension = std::move(Parms.SlotDimension);
}


// Function JSI_Slot.JSI_Slot_C.AdjustImageScale
// (Public, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::AdjustImageScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "AdjustImageScale");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.CanOpenSpecialContainer?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Return_value                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::CanOpenSpecialContainer_(bool* Return_value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "CanOpenSpecialContainer?");

	Params::JSI_Slot_C_CanOpenSpecialContainer_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return_value != nullptr)
		*Return_value = Parms.Return_value;
}


// Function JSI_Slot.JSI_Slot_C.CanStack?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    CanStack                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FreeSpaceAvailable                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::CanStack_(bool* CanStack, bool* FreeSpaceAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "CanStack?");

	Params::JSI_Slot_C_CanStack_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CanStack != nullptr)
		*CanStack = Parms.CanStack;

	if (FreeSpaceAvailable != nullptr)
		*FreeSpaceAvailable = Parms.FreeSpaceAvailable;
}


// Function JSI_Slot.JSI_Slot_C.CapacityContainer_GetLastItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      Output                                                 (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::CapacityContainer_GetLastItem(class UJSI_Slot_C** Output)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "CapacityContainer_GetLastItem");

	Params::JSI_Slot_C_CapacityContainer_GetLastItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Output != nullptr)
		*Output = Parms.Output;
}


// Function JSI_Slot.JSI_Slot_C.ChangePrice
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Price_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::ChangePrice(double Price_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "ChangePrice");

	Params::JSI_Slot_C_ChangePrice Parms{};

	Parms.Price_0 = Price_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.ChangeRarity
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Rarity_0                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    Changed_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::ChangeRarity(const struct FGameplayTag& Rarity_0, bool* Changed_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "ChangeRarity");

	Params::JSI_Slot_C_ChangeRarity Parms{};

	Parms.Rarity_0 = std::move(Rarity_0);

	UObject::ProcessEvent(Func, &Parms);

	if (Changed_ != nullptr)
		*Changed_ = Parms.Changed_;
}


// Function JSI_Slot.JSI_Slot_C.CheckIfScaleIsNeeded
// (Public, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::CheckIfScaleIsNeeded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "CheckIfScaleIsNeeded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.CheckRootContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      DraggedItem                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    CanAdd_                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::CheckRootContainer(class UJSI_Slot_C* DraggedItem, bool* CanAdd_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "CheckRootContainer");

	Params::JSI_Slot_C_CheckRootContainer Parms{};

	Parms.DraggedItem = DraggedItem;

	UObject::ProcessEvent(Func, &Parms);

	if (CanAdd_ != nullptr)
		*CanAdd_ = Parms.CanAdd_;
}


// Function JSI_Slot.JSI_Slot_C.ClearImageScale
// (Public, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::ClearImageScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "ClearImageScale");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.ClearPendingAttachments
// (Public, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::ClearPendingAttachments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "ClearPendingAttachments");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.ClearSlot
// (Public, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::ClearSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "ClearSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.Construct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UJSI_Slot_C::Construct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "Construct");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.ConstructInitialize
// (BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::ConstructInitialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "ConstructInitialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.DeepSearch_GetAllItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSI_Slot_C*>              ArrItemsByRef                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UJSI_Slot_C::DeepSearch_GetAllItems(TArray<class UJSI_Slot_C*>& ArrItemsByRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "DeepSearch_GetAllItems");

	Params::JSI_Slot_C_DeepSearch_GetAllItems Parms{};

	Parms.ArrItemsByRef = std::move(ArrItemsByRef);

	UObject::ProcessEvent(Func, &Parms);

	ArrItemsByRef = std::move(Parms.ArrItemsByRef);
}


// Function JSI_Slot.JSI_Slot_C.Destruct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UJSI_Slot_C::Destruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "Destruct");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.DetectChange
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      DroppedSlotRef                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    DraggedRotated_                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    NOChange                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::DetectChange(class UJSI_Slot_C* DroppedSlotRef, bool DraggedRotated_, bool* NOChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "DetectChange");

	Params::JSI_Slot_C_DetectChange Parms{};

	Parms.DroppedSlotRef = DroppedSlotRef;
	Parms.DraggedRotated_ = DraggedRotated_;

	UObject::ProcessEvent(Func, &Parms);

	if (NOChange != nullptr)
		*NOChange = Parms.NOChange;
}


// Function JSI_Slot.JSI_Slot_C.ExecuteUbergraph_JSI_Slot
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::ExecuteUbergraph_JSI_Slot(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "ExecuteUbergraph_JSI_Slot");

	Params::JSI_Slot_C_ExecuteUbergraph_JSI_Slot Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.Get_SlotBorder_ToolTipWidget_0
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UWidget*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash)

class UWidget* UJSI_Slot_C::Get_SlotBorder_ToolTipWidget_0()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "Get_SlotBorder_ToolTipWidget_0");

	Params::JSI_Slot_C_Get_SlotBorder_ToolTipWidget_0 Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.GetBorderColorByRarity
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGameplayTag                     Rarity_0                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor                     Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetBorderColorByRarity(const struct FGameplayTag& Rarity_0, struct FLinearColor* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetBorderColorByRarity");

	Params::JSI_Slot_C_GetBorderColorByRarity Parms{};

	Parms.Rarity_0 = std::move(Rarity_0);

	UObject::ProcessEvent(Func, &Parms);

	if (Color != nullptr)
		*Color = std::move(Parms.Color);
}


// Function JSI_Slot.JSI_Slot_C.GetClickLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGeometry                        Geometry                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
// struct FPointerEvent                    MouseEvents                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FVector2D                        Output_Get                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetClickLocation(const struct FGeometry& Geometry, const struct FPointerEvent& MouseEvents, struct FVector2D* Output_Get)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetClickLocation");

	Params::JSI_Slot_C_GetClickLocation Parms{};

	Parms.Geometry = std::move(Geometry);
	Parms.MouseEvents = std::move(MouseEvents);

	UObject::ProcessEvent(Func, &Parms);

	if (Output_Get != nullptr)
		*Output_Get = std::move(Parms.Output_Get);
}


// Function JSI_Slot.JSI_Slot_C.GetContainerCapacity
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Cap                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MaxCapacity                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetContainerCapacity(int32* Cap, int32* MaxCapacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetContainerCapacity");

	Params::JSI_Slot_C_GetContainerCapacity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Cap != nullptr)
		*Cap = Parms.Cap;

	if (MaxCapacity != nullptr)
		*MaxCapacity = Parms.MaxCapacity;
}


// Function JSI_Slot.JSI_Slot_C.GetContainerOneRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUserWidget*                      ContainerRef                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetContainerOneRef(class UUserWidget** ContainerRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetContainerOneRef");

	Params::JSI_Slot_C_GetContainerOneRef Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ContainerRef != nullptr)
		*ContainerRef = Parms.ContainerRef;
}


// Function JSI_Slot.JSI_Slot_C.GetContainerRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUserWidget*                      SpecialContainerRef_0                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  SlotContainer_0                                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    IsSpecialContainer                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetContainerRef(class UUserWidget** SpecialContainerRef_0, class UJSIContainer_C** SlotContainer_0, bool* IsSpecialContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetContainerRef");

	Params::JSI_Slot_C_GetContainerRef Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SpecialContainerRef_0 != nullptr)
		*SpecialContainerRef_0 = Parms.SpecialContainerRef_0;

	if (SlotContainer_0 != nullptr)
		*SlotContainer_0 = Parms.SlotContainer_0;

	if (IsSpecialContainer != nullptr)
		*IsSpecialContainer = Parms.IsSpecialContainer;
}


// Function JSI_Slot.JSI_Slot_C.GetContainers
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSIContainer_C*>          Container                                              (Parm, OutParm, ContainsInstancedReference)

void UJSI_Slot_C::GetContainers(TArray<class UJSIContainer_C*>* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetContainers");

	Params::JSI_Slot_C_GetContainers Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Container != nullptr)
		*Container = std::move(Parms.Container);
}


// Function JSI_Slot.JSI_Slot_C.GetCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetCount(int32* Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetCount");

	Params::JSI_Slot_C_GetCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Count != nullptr)
		*Count = Parms.Count;
}


// Function JSI_Slot.JSI_Slot_C.GetCSlotFromHosted
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSIContainer_C*                  SlotContainer_0                                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetCSlotFromHosted(class UJSIContainer_C** SlotContainer_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetCSlotFromHosted");

	Params::JSI_Slot_C_GetCSlotFromHosted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SlotContainer_0 != nullptr)
		*SlotContainer_0 = Parms.SlotContainer_0;
}


// Function JSI_Slot.JSI_Slot_C.GetCurrency
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             Currency                                               (Parm, OutParm)

void UJSI_Slot_C::GetCurrency(class FText* Currency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetCurrency");

	Params::JSI_Slot_C_GetCurrency Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Currency != nullptr)
		*Currency = std::move(Parms.Currency);
}


// Function JSI_Slot.JSI_Slot_C.GetDefaultWeight
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Weight                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetDefaultWeight(double* Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetDefaultWeight");

	Params::JSI_Slot_C_GetDefaultWeight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Weight != nullptr)
		*Weight = Parms.Weight;
}


// Function JSI_Slot.JSI_Slot_C.GetDurability
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Durability_0                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  MaxDurability                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetDurability(double* Durability_0, double* MaxDurability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetDurability");

	Params::JSI_Slot_C_GetDurability Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Durability_0 != nullptr)
		*Durability_0 = Parms.Durability_0;

	if (MaxDurability != nullptr)
		*MaxDurability = Parms.MaxDurability;
}


// Function JSI_Slot.JSI_Slot_C.GetFreeSpace
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UJSI_Slot_C::GetFreeSpace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetFreeSpace");

	Params::JSI_Slot_C_GetFreeSpace Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.GetHostedSlot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      HostingItem                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetHostedSlot(class UJSI_Slot_C** HostingItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetHostedSlot");

	Params::JSI_Slot_C_GetHostedSlot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (HostingItem != nullptr)
		*HostingItem = Parms.HostingItem;
}


// Function JSI_Slot.JSI_Slot_C.GetItemID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             ItemId                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetItemID(class FName* ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetItemID");

	Params::JSI_Slot_C_GetItemID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ItemId != nullptr)
		*ItemId = Parms.ItemId;
}


// Function JSI_Slot.JSI_Slot_C.GetItemName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             Name_0                                                 (Parm, OutParm)

void UJSI_Slot_C::GetItemName(class FText* Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetItemName");

	Params::JSI_Slot_C_GetItemName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);
}


// Function JSI_Slot.JSI_Slot_C.GetJigDA
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJigsawItem_DataAsset_C*          JigDataAsset_0                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetJigDA(class UJigsawItem_DataAsset_C** JigDataAsset_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetJigDA");

	Params::JSI_Slot_C_GetJigDA Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (JigDataAsset_0 != nullptr)
		*JigDataAsset_0 = Parms.JigDataAsset_0;
}


// Function JSI_Slot.JSI_Slot_C.GetJigItemImage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UTexture*                         TextureRef                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetJigItemImage(class UTexture** TextureRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetJigItemImage");

	Params::JSI_Slot_C_GetJigItemImage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TextureRef != nullptr)
		*TextureRef = Parms.TextureRef;
}


// Function JSI_Slot.JSI_Slot_C.GetLenOfItemsInContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Output_Get                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetLenOfItemsInContainer(int32* Output_Get)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetLenOfItemsInContainer");

	Params::JSI_Slot_C_GetLenOfItemsInContainer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Output_Get != nullptr)
		*Output_Get = Parms.Output_Get;
}


// Function JSI_Slot.JSI_Slot_C.GetMaxStack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    CheckCapacityContainer_                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MaxStack                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetMaxStack(bool CheckCapacityContainer_, int32* MaxStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetMaxStack");

	Params::JSI_Slot_C_GetMaxStack Parms{};

	Parms.CheckCapacityContainer_ = CheckCapacityContainer_;

	UObject::ProcessEvent(Func, &Parms);

	if (MaxStack != nullptr)
		*MaxStack = Parms.MaxStack;
}


// Function JSI_Slot.JSI_Slot_C.GetPendingAttachments
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class FName>                     PendingSnapAttachements_0                              (Parm, OutParm)

void UJSI_Slot_C::GetPendingAttachments(TArray<class FName>* PendingSnapAttachements_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetPendingAttachments");

	Params::JSI_Slot_C_GetPendingAttachments Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PendingSnapAttachements_0 != nullptr)
		*PendingSnapAttachements_0 = std::move(Parms.PendingSnapAttachements_0);
}


// Function JSI_Slot.JSI_Slot_C.GetPrice
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Price_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetPrice(double* Price_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetPrice");

	Params::JSI_Slot_C_GetPrice Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Price_0 != nullptr)
		*Price_0 = Parms.Price_0;
}


// Function JSI_Slot.JSI_Slot_C.GetSlotDim
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        SlotDimension                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetSlotDim(struct FVector2D* SlotDimension)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetSlotDim");

	Params::JSI_Slot_C_GetSlotDim Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SlotDimension != nullptr)
		*SlotDimension = std::move(Parms.SlotDimension);
}


// Function JSI_Slot.JSI_Slot_C.GetSlotDimUnrotated
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        SlotDimension                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetSlotDimUnrotated(struct FVector2D* SlotDimension)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetSlotDimUnrotated");

	Params::JSI_Slot_C_GetSlotDimUnrotated Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SlotDimension != nullptr)
		*SlotDimension = std::move(Parms.SlotDimension);
}


// Function JSI_Slot.JSI_Slot_C.GetSlotIndexOnDrop
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   SlotIndex_0                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetSlotIndexOnDrop(int32* SlotIndex_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetSlotIndexOnDrop");

	Params::JSI_Slot_C_GetSlotIndexOnDrop Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SlotIndex_0 != nullptr)
		*SlotIndex_0 = Parms.SlotIndex_0;
}


// Function JSI_Slot.JSI_Slot_C.GetSlotSize
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        Size_0                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetSlotSize(struct FVector2D* Size_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetSlotSize");

	Params::JSI_Slot_C_GetSlotSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Size_0 != nullptr)
		*Size_0 = std::move(Parms.Size_0);
}


// Function JSI_Slot.JSI_Slot_C.GetSpecialContainerRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUserWidget*                      SpecialContainerRef_0                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetSpecialContainerRef(class UUserWidget** SpecialContainerRef_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetSpecialContainerRef");

	Params::JSI_Slot_C_GetSpecialContainerRef Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SpecialContainerRef_0 != nullptr)
		*SpecialContainerRef_0 = Parms.SpecialContainerRef_0;
}


// Function JSI_Slot.JSI_Slot_C.GetStatByName
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     STAT_TAG                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_ItemStat                      Stat                                                   (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetStatByName(const struct FGameplayTag& STAT_TAG, bool* Found, struct FS_ItemStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetStatByName");

	Params::JSI_Slot_C_GetStatByName Parms{};

	Parms.STAT_TAG = std::move(STAT_TAG);

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (Stat != nullptr)
		*Stat = std::move(Parms.Stat);
}


// Function JSI_Slot.JSI_Slot_C.GetStats
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FS_ItemStat>              ItemStats_0                                            (Parm, OutParm)

void UJSI_Slot_C::GetStats(TArray<struct FS_ItemStat>* ItemStats_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetStats");

	Params::JSI_Slot_C_GetStats Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ItemStats_0 != nullptr)
		*ItemStats_0 = std::move(Parms.ItemStats_0);
}


// Function JSI_Slot.JSI_Slot_C.GetType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGameplayTag                     Type                                                   (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetType(struct FGameplayTag* Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetType");

	Params::JSI_Slot_C_GetType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Type != nullptr)
		*Type = std::move(Parms.Type);
}


// Function JSI_Slot.JSI_Slot_C.GetUniqueID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGuid                            UniqueServerID                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::GetUniqueID(struct FGuid* UniqueServerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetUniqueID");

	Params::JSI_Slot_C_GetUniqueID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (UniqueServerID != nullptr)
		*UniqueServerID = std::move(Parms.UniqueServerID);
}


// Function JSI_Slot.JSI_Slot_C.GetWeight
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double UJSI_Slot_C::GetWeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "GetWeight");

	Params::JSI_Slot_C_GetWeight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.HandleSizeBox
// (Public, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::HandleSizeBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "HandleSizeBox");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.HasPendingAttachments
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSI_Slot_C::HasPendingAttachments()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "HasPendingAttachments");

	Params::JSI_Slot_C_HasPendingAttachments Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.HideCapacity
// (Public, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::HideCapacity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "HideCapacity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.Initialize
// (BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "Initialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.IsALTDown
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    CTRL_Down_0                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::IsALTDown(bool* CTRL_Down_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "IsALTDown");

	Params::JSI_Slot_C_IsALTDown Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CTRL_Down_0 != nullptr)
		*CTRL_Down_0 = Parms.CTRL_Down_0;
}


// Function JSI_Slot.JSI_Slot_C.ISCapacityContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSI_Slot_C::ISCapacityContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "ISCapacityContainer");

	Params::JSI_Slot_C_ISCapacityContainer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.IsContainer?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsContainer__0                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::IsContainer_(bool* IsContainer__0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "IsContainer?");

	Params::JSI_Slot_C_IsContainer_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsContainer__0 != nullptr)
		*IsContainer__0 = Parms.IsContainer__0;
}


// Function JSI_Slot.JSI_Slot_C.IsCTRLDown
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    CTRL_Down_0                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::IsCTRLDown(bool* CTRL_Down_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "IsCTRLDown");

	Params::JSI_Slot_C_IsCTRLDown Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CTRL_Down_0 != nullptr)
		*CTRL_Down_0 = Parms.CTRL_Down_0;
}


// Function JSI_Slot.JSI_Slot_C.IsEmptySlot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsEmpty_0                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::IsEmptySlot(bool* IsEmpty_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "IsEmptySlot");

	Params::JSI_Slot_C_IsEmptySlot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsEmpty_0 != nullptr)
		*IsEmpty_0 = Parms.IsEmpty_0;
}


// Function JSI_Slot.JSI_Slot_C.IsItemPending?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsPending_0                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::IsItemPending_(bool* IsPending_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "IsItemPending?");

	Params::JSI_Slot_C_IsItemPending_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsPending_0 != nullptr)
		*IsPending_0 = Parms.IsPending_0;
}


// Function JSI_Slot.JSI_Slot_C.IsPendingSnap?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    PendingSnap_0                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::IsPendingSnap_(bool* PendingSnap_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "IsPendingSnap?");

	Params::JSI_Slot_C_IsPendingSnap_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PendingSnap_0 != nullptr)
		*PendingSnap_0 = Parms.PendingSnap_0;
}


// Function JSI_Slot.JSI_Slot_C.isRotated?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSI_Slot_C::isRotated_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "isRotated?");

	Params::JSI_Slot_C_isRotated_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.IsSHIFTDown
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    CTRL_Down_0                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::IsSHIFTDown(bool* CTRL_Down_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "IsSHIFTDown");

	Params::JSI_Slot_C_IsSHIFTDown Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CTRL_Down_0 != nullptr)
		*CTRL_Down_0 = Parms.CTRL_Down_0;
}


// Function JSI_Slot.JSI_Slot_C.IsSnapOnStandBy
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    SnapIsOnStandby_0                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::IsSnapOnStandBy(bool* SnapIsOnStandby_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "IsSnapOnStandBy");

	Params::JSI_Slot_C_IsSnapOnStandBy Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SnapIsOnStandby_0 != nullptr)
		*SnapIsOnStandby_0 = Parms.SnapIsOnStandby_0;
}


// Function JSI_Slot.JSI_Slot_C.IsSpecialContainer?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSI_Slot_C::IsSpecialContainer_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "IsSpecialContainer?");

	Params::JSI_Slot_C_IsSpecialContainer_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.IsStillValid
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      Slot_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::IsStillValid(class UJSI_Slot_C* Slot_0, bool* Valid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "IsStillValid");

	Params::JSI_Slot_C_IsStillValid Parms{};

	Parms.Slot_0 = Slot_0;

	UObject::ProcessEvent(Func, &Parms);

	if (Valid != nullptr)
		*Valid = Parms.Valid;
}


// Function JSI_Slot.JSI_Slot_C.LockSlot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::LockSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "LockSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.On_MouseDoubleClick
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm)

struct FEventReply UJSI_Slot_C::On_MouseDoubleClick(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "On_MouseDoubleClick");

	Params::JSI_Slot_C_On_MouseDoubleClick Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.OnDone_Event_0
// (BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::OnDone_Event_0()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "OnDone_Event_0");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.OnDragCancelled
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPointerEvent                    PointerEvent                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UDragDropOperation*               Operation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::OnDragCancelled(const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "OnDragCancelled");

	Params::JSI_Slot_C_OnDragCancelled Parms{};

	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.OnDragDetected
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FPointerEvent                    PointerEvent                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UDragDropOperation*               Operation                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::OnDragDetected(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation** Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "OnDragDetected");

	Params::JSI_Slot_C_OnDragDetected Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.PointerEvent = std::move(PointerEvent);

	UObject::ProcessEvent(Func, &Parms);

	if (Operation != nullptr)
		*Operation = Parms.Operation;
}


// Function JSI_Slot.JSI_Slot_C.OnDragEnter
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FPointerEvent                    PointerEvent                                           (BlueprintVisible, BlueprintReadOnly, Parm)
// class UDragDropOperation*               Operation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::OnDragEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "OnDragEnter");

	Params::JSI_Slot_C_OnDragEnter Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.OnDrop
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FPointerEvent                    PointerEvent                                           (BlueprintVisible, BlueprintReadOnly, Parm)
// class UDragDropOperation*               Operation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSI_Slot_C::OnDrop(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "OnDrop");

	Params::JSI_Slot_C_OnDrop Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.OnFocusReceived
// (BlueprintCosmetic, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FFocusEvent                      InFocusEvent                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm)

struct FEventReply UJSI_Slot_C::OnFocusReceived(const struct FGeometry& MyGeometry, const struct FFocusEvent& InFocusEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "OnFocusReceived");

	Params::JSI_Slot_C_OnFocusReceived Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InFocusEvent = std::move(InFocusEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.OnItemMoved
// (Public, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::OnItemMoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "OnItemMoved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.OnMouseButtonDown
// (BlueprintCosmetic, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm)

struct FEventReply UJSI_Slot_C::OnMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "OnMouseButtonDown");

	Params::JSI_Slot_C_OnMouseButtonDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.OnMouseButtonUp
// (BlueprintCosmetic, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm)

struct FEventReply UJSI_Slot_C::OnMouseButtonUp(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "OnMouseButtonUp");

	Params::JSI_Slot_C_OnMouseButtonUp Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.OnMouseEnter
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UJSI_Slot_C::OnMouseEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "OnMouseEnter");

	Params::JSI_Slot_C_OnMouseEnter Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.OnMouseLeave
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPointerEvent                    MouseEvent                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UJSI_Slot_C::OnMouseLeave(const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "OnMouseLeave");

	Params::JSI_Slot_C_OnMouseLeave Parms{};

	Parms.MouseEvent = std::move(MouseEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.OnVisualDragHighlight
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::OnVisualDragHighlight(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "OnVisualDragHighlight");

	Params::JSI_Slot_C_OnVisualDragHighlight Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.OptimizeFixedSlot
// (Public, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::OptimizeFixedSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "OptimizeFixedSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.PreConstruct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsDesignTime                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::PreConstruct(bool IsDesignTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "PreConstruct");

	Params::JSI_Slot_C_PreConstruct Parms{};

	Parms.IsDesignTime = IsDesignTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.ProcessMouseDown
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGeometry                        Geo                                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
// struct FPointerEvent                    Pointer                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm)

struct FEventReply UJSI_Slot_C::ProcessMouseDown(struct FGeometry& Geo, struct FPointerEvent& Pointer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "ProcessMouseDown");

	Params::JSI_Slot_C_ProcessMouseDown Parms{};

	Parms.Geo = std::move(Geo);
	Parms.Pointer = std::move(Pointer);

	UObject::ProcessEvent(Func, &Parms);

	Geo = std::move(Parms.Geo);
	Pointer = std::move(Parms.Pointer);

	return Parms.ReturnValue;
}


// Function JSI_Slot.JSI_Slot_C.RefreshOnDragEnter
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDragDropOperation*               Op                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::RefreshOnDragEnter(class UDragDropOperation* Op)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "RefreshOnDragEnter");

	Params::JSI_Slot_C_RefreshOnDragEnter Parms{};

	Parms.Op = Op;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.RemoveCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   RemoveNum                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RemoveAllIfCount_Num_                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CallOnStackChanged_                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Removed_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::RemoveCount(int32 RemoveNum, bool RemoveAllIfCount_Num_, bool CallOnStackChanged_, bool* Removed_, int32* NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "RemoveCount");

	Params::JSI_Slot_C_RemoveCount Parms{};

	Parms.RemoveNum = RemoveNum;
	Parms.RemoveAllIfCount_Num_ = RemoveAllIfCount_Num_;
	Parms.CallOnStackChanged_ = CallOnStackChanged_;

	UObject::ProcessEvent(Func, &Parms);

	if (Removed_ != nullptr)
		*Removed_ = Parms.Removed_;

	if (NewCount != nullptr)
		*NewCount = Parms.NewCount;
}


// Function JSI_Slot.JSI_Slot_C.RemoveFromJSIParent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Removed                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::RemoveFromJSIParent(bool* Removed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "RemoveFromJSIParent");

	Params::JSI_Slot_C_RemoveFromJSIParent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Removed != nullptr)
		*Removed = Parms.Removed;
}


// Function JSI_Slot.JSI_Slot_C.ResetOpacity
// (BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::ResetOpacity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "ResetOpacity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.ResizeSlot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                        NewSize                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ResizeImage_                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        Size_0                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::ResizeSlot(const struct FVector2D& NewSize, bool ResizeImage_, struct FVector2D* Size_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "ResizeSlot");

	Params::JSI_Slot_C_ResizeSlot Parms{};

	Parms.NewSize = std::move(NewSize);
	Parms.ResizeImage_ = ResizeImage_;

	UObject::ProcessEvent(Func, &Parms);

	if (Size_0 != nullptr)
		*Size_0 = std::move(Parms.Size_0);
}


// Function JSI_Slot.JSI_Slot_C.Rotate Image Default
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::Rotate_Image_Default(bool Rotated_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "Rotate Image Default");

	Params::JSI_Slot_C_Rotate_Image_Default Parms{};

	Parms.Rotated_ = Rotated_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.RotateEquippedImage
// (Public, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::RotateEquippedImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "RotateEquippedImage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.RotateSlot
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Rotate_                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FlipVector_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::RotateSlot(bool Rotate_, bool FlipVector_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "RotateSlot");

	Params::JSI_Slot_C_RotateSlot Parms{};

	Parms.Rotate_ = Rotate_;
	Parms.FlipVector_ = FlipVector_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetCapacity
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   CurrentCap                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Unknown_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetCapacity(int32 CurrentCap, bool Unknown_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetCapacity");

	Params::JSI_Slot_C_SetCapacity Parms{};

	Parms.CurrentCap = CurrentCap;
	Parms.Unknown_ = Unknown_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetControllerHighlight
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetControllerHighlight(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetControllerHighlight");

	Params::JSI_Slot_C_SetControllerHighlight Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetDynamicInfo
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          JigDataAsset_0                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetDynamicInfo(class UJigsawItem_DataAsset_C* JigDataAsset_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetDynamicInfo");

	Params::JSI_Slot_C_SetDynamicInfo Parms{};

	Parms.JigDataAsset_0 = JigDataAsset_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetHighlight
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Highlight_                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FSlateColor                      HighlightColor                                         (BlueprintVisible, BlueprintReadOnly, Parm)
// bool                                    HideImage_                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Highlight                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetHighlight(bool Highlight_, const struct FSlateColor& HighlightColor, bool HideImage_, bool* Highlight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetHighlight");

	Params::JSI_Slot_C_SetHighlight Parms{};

	Parms.Highlight_ = Highlight_;
	Parms.HighlightColor = std::move(HighlightColor);
	Parms.HideImage_ = HideImage_;

	UObject::ProcessEvent(Func, &Parms);

	if (Highlight != nullptr)
		*Highlight = Parms.Highlight;
}


// Function JSI_Slot.JSI_Slot_C.SetHostedSlot
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      HostingItem                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetHostedSlot(class UJSI_Slot_C* HostingItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetHostedSlot");

	Params::JSI_Slot_C_SetHostedSlot Parms{};

	Parms.HostingItem = HostingItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetHostingArray
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSI_Slot_C*>              ArrayOfHostingItem_0                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UJSI_Slot_C::SetHostingArray(TArray<class UJSI_Slot_C*>& ArrayOfHostingItem_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetHostingArray");

	Params::JSI_Slot_C_SetHostingArray Parms{};

	Parms.ArrayOfHostingItem_0 = std::move(ArrayOfHostingItem_0);

	UObject::ProcessEvent(Func, &Parms);

	ArrayOfHostingItem_0 = std::move(Parms.ArrayOfHostingItem_0);
}


// Function JSI_Slot.JSI_Slot_C.SetItemDim
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                        ItemDim_0                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetItemDim(const struct FVector2D& ItemDim_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetItemDim");

	Params::JSI_Slot_C_SetItemDim Parms{};

	Parms.ItemDim_0 = std::move(ItemDim_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetJigBrushSize
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UImage*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        Image_Size                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetJigBrushSize(class UImage* Target, const struct FVector2D& Image_Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetJigBrushSize");

	Params::JSI_Slot_C_SetJigBrushSize Parms{};

	Parms.Target = Target;
	Parms.Image_Size = std::move(Image_Size);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetMaxCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CallOnStackChanged_                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetMaxCount(bool CallOnStackChanged_, int32* Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetMaxCount");

	Params::JSI_Slot_C_SetMaxCount Parms{};

	Parms.CallOnStackChanged_ = CallOnStackChanged_;

	UObject::ProcessEvent(Func, &Parms);

	if (Count != nullptr)
		*Count = Parms.Count;
}


// Function JSI_Slot.JSI_Slot_C.SetOverlaySlot
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UOverlaySlot*                     OverlayRef_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetOverlaySlot(class UOverlaySlot* OverlayRef_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetOverlaySlot");

	Params::JSI_Slot_C_SetOverlaySlot Parms{};

	Parms.OverlayRef_0 = OverlayRef_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetPending
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Pending_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  PlaybackSpeed                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  TimerInSec                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetPending(bool Pending_, double PlaybackSpeed, double TimerInSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetPending");

	Params::JSI_Slot_C_SetPending Parms{};

	Parms.Pending_ = Pending_;
	Parms.PlaybackSpeed = PlaybackSpeed;
	Parms.TimerInSec = TimerInSec;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetPendingAttachments
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     PendingSnapAttachements_0                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UJSI_Slot_C::SetPendingAttachments(TArray<class FName>& PendingSnapAttachements_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetPendingAttachments");

	Params::JSI_Slot_C_SetPendingAttachments Parms{};

	Parms.PendingSnapAttachements_0 = std::move(PendingSnapAttachements_0);

	UObject::ProcessEvent(Func, &Parms);

	PendingSnapAttachements_0 = std::move(Parms.PendingSnapAttachements_0);
}


// Function JSI_Slot.JSI_Slot_C.SetRarityColor
// (BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::SetRarityColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetRarityColor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.SetSlotContainerRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  SlotContainer_0                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      Output_Get                                             (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetSlotContainerRef(class UJSIContainer_C* SlotContainer_0, class UJSI_Slot_C** Output_Get)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetSlotContainerRef");

	Params::JSI_Slot_C_SetSlotContainerRef Parms{};

	Parms.SlotContainer_0 = SlotContainer_0;

	UObject::ProcessEvent(Func, &Parms);

	if (Output_Get != nullptr)
		*Output_Get = Parms.Output_Get;
}


// Function JSI_Slot.JSI_Slot_C.SetSlotImageVisibility
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ESlateVisibility                        InVisibility                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetSlotImageVisibility(ESlateVisibility InVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetSlotImageVisibility");

	Params::JSI_Slot_C_SetSlotImageVisibility Parms{};

	Parms.InVisibility = InVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetSnapImagePending
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    PendingInspect                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetSnapImagePending(bool PendingInspect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetSnapImagePending");

	Params::JSI_Slot_C_SetSnapImagePending Parms{};

	Parms.PendingInspect = PendingInspect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetSnapOnStandBy
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    SnapIsOnStandby_0                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetSnapOnStandBy(bool SnapIsOnStandby_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetSnapOnStandBy");

	Params::JSI_Slot_C_SetSnapOnStandBy Parms{};

	Parms.SnapIsOnStandby_0 = SnapIsOnStandby_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetSortHighlight
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsFaded                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    AllowInteractionOnSort_0                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetSortHighlight(bool IsFaded, bool AllowInteractionOnSort_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetSortHighlight");

	Params::JSI_Slot_C_SetSortHighlight Parms{};

	Parms.IsFaded = IsFaded;
	Parms.AllowInteractionOnSort_0 = AllowInteractionOnSort_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetSpecialContainer
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      SpecialContainerRef_0                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetSpecialContainer(class UUserWidget* SpecialContainerRef_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetSpecialContainer");

	Params::JSI_Slot_C_SetSpecialContainer Parms{};

	Parms.SpecialContainerRef_0 = SpecialContainerRef_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.SetStatByName
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     STAT_TAG                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// double                                  MinVal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  MaxVal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_ItemStat                      Stat                                                   (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetStatByName(const struct FGameplayTag& STAT_TAG, double MinVal, double MaxVal, bool* Found, struct FS_ItemStat* Stat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetStatByName");

	Params::JSI_Slot_C_SetStatByName Parms{};

	Parms.STAT_TAG = std::move(STAT_TAG);
	Parms.MinVal = MinVal;
	Parms.MaxVal = MaxVal;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (Stat != nullptr)
		*Stat = std::move(Parms.Stat);
}


// Function JSI_Slot.JSI_Slot_C.SetUniqueID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ID                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UniqueID                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::SetUniqueID(const struct FGuid& ID, struct FGuid* UniqueID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "SetUniqueID");

	Params::JSI_Slot_C_SetUniqueID Parms{};

	Parms.ID = std::move(ID);

	UObject::ProcessEvent(Func, &Parms);

	if (UniqueID != nullptr)
		*UniqueID = std::move(Parms.UniqueID);
}


// Function JSI_Slot.JSI_Slot_C.ShowHideDisplayName
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Hide_                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::ShowHideDisplayName(bool Hide_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "ShowHideDisplayName");

	Params::JSI_Slot_C_ShowHideDisplayName Parms{};

	Parms.Hide_ = Hide_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.ShowWeaponMagSize
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   CurrentCap                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MaxCap                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::ShowWeaponMagSize(int32 CurrentCap, int32 MaxCap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "ShowWeaponMagSize");

	Params::JSI_Slot_C_ShowWeaponMagSize Parms{};

	Parms.CurrentCap = CurrentCap;
	Parms.MaxCap = MaxCap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.TogleHighlight
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::TogleHighlight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "TogleHighlight");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.TryUseBullet
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UID                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemUsed                                               (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::TryUseBullet(bool* Return, struct FGuid* UID, class UJSI_Slot_C** ItemUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "TryUseBullet");

	Params::JSI_Slot_C_TryUseBullet Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;

	if (UID != nullptr)
		*UID = std::move(Parms.UID);

	if (ItemUsed != nullptr)
		*ItemUsed = Parms.ItemUsed;
}


// Function JSI_Slot.JSI_Slot_C.UnhandledGetTargetContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSIContainer_C*                  Container1                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  Container2                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  Target                                                 (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::UnhandledGetTargetContainer(class UJSIContainer_C* Container1, class UJSIContainer_C* Container2, class UJSIContainer_C** Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "UnhandledGetTargetContainer");

	Params::JSI_Slot_C_UnhandledGetTargetContainer Parms{};

	Parms.Container1 = Container1;
	Parms.Container2 = Container2;

	UObject::ProcessEvent(Func, &Parms);

	if (Target != nullptr)
		*Target = Parms.Target;
}


// Function JSI_Slot.JSI_Slot_C.UnlockSlot
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::UnlockSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "UnlockSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.Update_OnCountChanged
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OldCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::Update_OnCountChanged(class UJSI_Slot_C* ItemRef, int32 OldCount, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "Update_OnCountChanged");

	Params::JSI_Slot_C_Update_OnCountChanged Parms{};

	Parms.ItemRef = ItemRef;
	Parms.OldCount = OldCount;
	Parms.NewCount = NewCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.Update_OnItemAdded
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::Update_OnItemAdded(class UJSI_Slot_C* ItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "Update_OnItemAdded");

	Params::JSI_Slot_C_Update_OnItemAdded Parms{};

	Parms.ItemRef = ItemRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.Update_OnItemRemoved
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::Update_OnItemRemoved(class UJSI_Slot_C* ItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "Update_OnItemRemoved");

	Params::JSI_Slot_C_Update_OnItemRemoved Parms{};

	Parms.ItemRef = ItemRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.UpdateCapacity
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             UpdateCountText                                        (BlueprintVisible, BlueprintReadOnly, Parm)

void UJSI_Slot_C::UpdateCapacity(const class FText& UpdateCountText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "UpdateCapacity");

	Params::JSI_Slot_C_UpdateCapacity Parms{};

	Parms.UpdateCountText = std::move(UpdateCountText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.UpdateCount
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CallOnStackChanged_                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    SkipIfCapContainer                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::UpdateCount(int32 NewCount, bool CallOnStackChanged_, bool SkipIfCapContainer, int32* Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "UpdateCount");

	Params::JSI_Slot_C_UpdateCount Parms{};

	Parms.NewCount = NewCount;
	Parms.CallOnStackChanged_ = CallOnStackChanged_;
	Parms.SkipIfCapContainer = SkipIfCapContainer;

	UObject::ProcessEvent(Func, &Parms);

	if (Count != nullptr)
		*Count = Parms.Count;
}


// Function JSI_Slot.JSI_Slot_C.UpdateCustom Data
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FString>                   Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class FString>                   Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UJSI_Slot_C::UpdateCustom_Data(TArray<class FString>& Key, TArray<class FString>& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "UpdateCustom Data");

	Params::JSI_Slot_C_UpdateCustom_Data Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	UObject::ProcessEvent(Func, &Parms);

	Key = std::move(Parms.Key);
	Value = std::move(Parms.Value);
}


// Function JSI_Slot.JSI_Slot_C.UpdateDurability
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                        NewDur                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::UpdateDurability(const struct FVector2D& NewDur)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "UpdateDurability");

	Params::JSI_Slot_C_UpdateDurability Parms{};

	Parms.NewDur = std::move(NewDur);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.UpdateImage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTexture*                         NewTexture                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    SetInInfo_                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Updated                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::UpdateImage(class UTexture* NewTexture, bool SetInInfo_, bool* Updated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "UpdateImage");

	Params::JSI_Slot_C_UpdateImage Parms{};

	Parms.NewTexture = NewTexture;
	Parms.SetInInfo_ = SetInInfo_;

	UObject::ProcessEvent(Func, &Parms);

	if (Updated != nullptr)
		*Updated = Parms.Updated;
}


// Function JSI_Slot.JSI_Slot_C.UpdateInfo
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Image_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        Image_Size                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::UpdateInfo(class UObject* Image_0, const struct FVector2D& Image_Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "UpdateInfo");

	Params::JSI_Slot_C_UpdateInfo Parms{};

	Parms.Image_0 = Image_0;
	Parms.Image_Size = std::move(Image_Size);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.UpdateItemSnap
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsActionbar_                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::UpdateItemSnap(bool IsActionbar_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "UpdateItemSnap");

	Params::JSI_Slot_C_UpdateItemSnap Parms{};

	Parms.IsActionbar_ = IsActionbar_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSI_Slot.JSI_Slot_C.UpdateMaterialRarity
// (Public, BlueprintCallable, BlueprintEvent)

void UJSI_Slot_C::UpdateMaterialRarity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "UpdateMaterialRarity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSI_Slot.JSI_Slot_C.UpdateStats
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_ItemStat>              Stats                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UJSI_Slot_C::UpdateStats(TArray<struct FS_ItemStat>& Stats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "UpdateStats");

	Params::JSI_Slot_C_UpdateStats Parms{};

	Parms.Stats = std::move(Stats);

	UObject::ProcessEvent(Func, &Parms);

	Stats = std::move(Parms.Stats);
}


// Function JSI_Slot.JSI_Slot_C.UpdateStockCount
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSI_Slot_C::UpdateStockCount(int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSI_Slot_C", "UpdateStockCount");

	Params::JSI_Slot_C_UpdateStockCount Parms{};

	Parms.NewCount = NewCount;

	UObject::ProcessEvent(Func, &Parms);
}

}

