#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Narrative

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum Narrative.ELineDuration
// NumValues: 0x0007
enum class ELineDuration : uint8
{
	LD_Default                               = 0,
	LD_WhenAudioEnds                         = 1,
	LD_WhenSequenceEnds                      = 2,
	LD_AfterReadingTime                      = 3,
	LD_AfterDuration                         = 4,
	LD_Never                                 = 5,
	LD_MAX                                   = 6,
};

// Enum Narrative.EUpdateType
// NumValues: 0x0008
enum class EUpdateType : uint8
{
	UT_None                                  = 0,
	UT_CompleteTask                          = 1,
	UT_BeginQuest                            = 2,
	UT_ForgetQuest                           = 3,
	UT_RestartQuest                          = 4,
	UT_QuestNewState                         = 5,
	UT_TaskProgressMade                      = 6,
	UT_MAX                                   = 7,
};

// Enum Narrative.EPartyConditionPolicy
// NumValues: 0x0005
enum class EPartyConditionPolicy : uint32
{
	AnyPlayerPasses                          = 0,
	PartyPasses                              = 1,
	AllPlayersPass                           = 2,
	PartyLeaderPasses                        = 3,
	EPartyConditionPolicy_MAX                = 4,
};

// Enum Narrative.EAnchorOriginRule
// NumValues: 0x0006
enum class EAnchorOriginRule : uint8
{
	AOR_Disabled                             = 0,
	AOR_ConversationCenter                   = 1,
	AOR_Speaker                              = 2,
	AOR_Listener                             = 3,
	AOR_Custom                               = 4,
	AOR_MAX                                  = 5,
};

// Enum Narrative.EAnchorRotationRule
// NumValues: 0x0003
enum class EAnchorRotationRule : uint8
{
	ARR_AnchorActorForwardVector             = 0,
	ARR_Conversation                         = 1,
	ARR_MAX                                  = 2,
};

// Enum Narrative.EShotTrackingRule
// NumValues: 0x0005
enum class EShotTrackingRule : uint8
{
	STR_Disabled                             = 0,
	STR_Speaker                              = 1,
	STR_Listener                             = 2,
	STR_Custom                               = 3,
	STR_MAX                                  = 4,
};

// Enum Narrative.EPartyEventPolicy
// NumValues: 0x0004
enum class EPartyEventPolicy : uint32
{
	Party                                    = 0,
	AllPartyMembers                          = 1,
	PartyLeader                              = 2,
	EPartyEventPolicy_MAX                    = 3,
};

// Enum Narrative.EEventRuntime
// NumValues: 0x0004
enum class EEventRuntime : uint8
{
	Start                                    = 0,
	End                                      = 1,
	Both                                     = 2,
	EEventRuntime_MAX                        = 3,
};

// Enum Narrative.EPartyDialogueControlPolicy
// NumValues: 0x0003
enum class EPartyDialogueControlPolicy : uint8
{
	PartyLeaderControlled                    = 0,
	AllPlayers                               = 1,
	EPartyDialogueControlPolicy_MAX          = 2,
};

// Enum Narrative.EQuestCompletion
// NumValues: 0x0005
enum class EQuestCompletion : uint8
{
	QC_NotStarted                            = 0,
	QC_Started                               = 1,
	QC_Succeded                              = 2,
	QC_Failed                                = 3,
	QC_MAX                                   = 4,
};

// Enum Narrative.EStateNodeType
// NumValues: 0x0004
enum class EStateNodeType : uint8
{
	Regular                                  = 0,
	Success                                  = 1,
	Failure                                  = 2,
	EStateNodeType_MAX                       = 3,
};

// ScriptStruct Narrative.SpeakerSelector
// 0x0008 (0x0008 - 0x0000)
struct FSpeakerSelector final
{
public:
	class FName                                   SpeakerID;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpeakerSelector) == 0x000004, "Wrong alignment on FSpeakerSelector");
static_assert(sizeof(FSpeakerSelector) == 0x000008, "Wrong size on FSpeakerSelector");
static_assert(offsetof(FSpeakerSelector, SpeakerID) == 0x000000, "Member 'FSpeakerSelector::SpeakerID' has a wrong offset!");

// ScriptStruct Narrative.SpeakerInfo
// 0x00B0 (0x00B0 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x10) FSpeakerInfo
{
public:
	class FName                                   SpeakerID;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   SpeakerName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UNarrativeDialogueSequence*             DefaultSpeakerShot;                                // 0x0020(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     SpeakerAvatarClass;                                // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpeakerAvatarTransform;                            // 0x0030(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NodeColor;                                         // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlayer;                                         // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
#pragma pack(pop)
static_assert(alignof(FSpeakerInfo) == 0x000010, "Wrong alignment on FSpeakerInfo");
static_assert(sizeof(FSpeakerInfo) == 0x0000B0, "Wrong size on FSpeakerInfo");
static_assert(offsetof(FSpeakerInfo, SpeakerID) == 0x000000, "Member 'FSpeakerInfo::SpeakerID' has a wrong offset!");
static_assert(offsetof(FSpeakerInfo, SpeakerName) == 0x000008, "Member 'FSpeakerInfo::SpeakerName' has a wrong offset!");
static_assert(offsetof(FSpeakerInfo, DefaultSpeakerShot) == 0x000020, "Member 'FSpeakerInfo::DefaultSpeakerShot' has a wrong offset!");
static_assert(offsetof(FSpeakerInfo, SpeakerAvatarClass) == 0x000028, "Member 'FSpeakerInfo::SpeakerAvatarClass' has a wrong offset!");
static_assert(offsetof(FSpeakerInfo, SpeakerAvatarTransform) == 0x000030, "Member 'FSpeakerInfo::SpeakerAvatarTransform' has a wrong offset!");
static_assert(offsetof(FSpeakerInfo, NodeColor) == 0x000090, "Member 'FSpeakerInfo::NodeColor' has a wrong offset!");
static_assert(offsetof(FSpeakerInfo, bIsPlayer) == 0x0000A0, "Member 'FSpeakerInfo::bIsPlayer' has a wrong offset!");

// ScriptStruct Narrative.ShotTrackingSettings
// 0x0030 (0x0030 - 0x0000)
struct FShotTrackingSettings final
{
public:
	EShotTrackingRule                             AvatarToTrack;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TrackedAvatarCustomID;                             // 0x0004(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TrackBoneNudge;                                    // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateTrackingEveryFrame;                         // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdateTrackingInterpSpeed;                         // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShotTrackingSettings) == 0x000008, "Wrong alignment on FShotTrackingSettings");
static_assert(sizeof(FShotTrackingSettings) == 0x000030, "Wrong size on FShotTrackingSettings");
static_assert(offsetof(FShotTrackingSettings, AvatarToTrack) == 0x000000, "Member 'FShotTrackingSettings::AvatarToTrack' has a wrong offset!");
static_assert(offsetof(FShotTrackingSettings, TrackedAvatarCustomID) == 0x000004, "Member 'FShotTrackingSettings::TrackedAvatarCustomID' has a wrong offset!");
static_assert(offsetof(FShotTrackingSettings, TrackBoneNudge) == 0x000010, "Member 'FShotTrackingSettings::TrackBoneNudge' has a wrong offset!");
static_assert(offsetof(FShotTrackingSettings, bUpdateTrackingEveryFrame) == 0x000028, "Member 'FShotTrackingSettings::bUpdateTrackingEveryFrame' has a wrong offset!");
static_assert(offsetof(FShotTrackingSettings, UpdateTrackingInterpSpeed) == 0x00002C, "Member 'FShotTrackingSettings::UpdateTrackingInterpSpeed' has a wrong offset!");

// ScriptStruct Narrative.DialogueLine
// 0x0040 (0x0040 - 0x0000)
struct FDialogueLine final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ELineDuration                                 Duration;                                          // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationSecondsOverride;                           // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DialogueSound;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DialogueMontage;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FacialAnimation;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNarrativeDialogueSequence*             Shot;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDialogueLine) == 0x000008, "Wrong alignment on FDialogueLine");
static_assert(sizeof(FDialogueLine) == 0x000040, "Wrong size on FDialogueLine");
static_assert(offsetof(FDialogueLine, Text) == 0x000000, "Member 'FDialogueLine::Text' has a wrong offset!");
static_assert(offsetof(FDialogueLine, Duration) == 0x000018, "Member 'FDialogueLine::Duration' has a wrong offset!");
static_assert(offsetof(FDialogueLine, DurationSecondsOverride) == 0x00001C, "Member 'FDialogueLine::DurationSecondsOverride' has a wrong offset!");
static_assert(offsetof(FDialogueLine, DialogueSound) == 0x000020, "Member 'FDialogueLine::DialogueSound' has a wrong offset!");
static_assert(offsetof(FDialogueLine, DialogueMontage) == 0x000028, "Member 'FDialogueLine::DialogueMontage' has a wrong offset!");
static_assert(offsetof(FDialogueLine, FacialAnimation) == 0x000030, "Member 'FDialogueLine::FacialAnimation' has a wrong offset!");
static_assert(offsetof(FDialogueLine, Shot) == 0x000038, "Member 'FDialogueLine::Shot' has a wrong offset!");

// ScriptStruct Narrative.PlayerSpeakerInfo
// 0x0000 (0x00B0 - 0x00B0)
struct FPlayerSpeakerInfo final : public FSpeakerInfo
{
public:
	class UNarrativeDialogueSequence*             SelectingReplyShot;                                // 0x00A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerSpeakerInfo) == 0x000010, "Wrong alignment on FPlayerSpeakerInfo");
static_assert(sizeof(FPlayerSpeakerInfo) == 0x0000B0, "Wrong size on FPlayerSpeakerInfo");
static_assert(offsetof(FPlayerSpeakerInfo, SelectingReplyShot) == 0x0000A8, "Member 'FPlayerSpeakerInfo::SelectingReplyShot' has a wrong offset!");

// ScriptStruct Narrative.DialoguePlayParams
// 0x000C (0x000C - 0x0000)
struct FDialoguePlayParams final
{
public:
	class FName                                   StartFromID;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDialoguePlayParams) == 0x000004, "Wrong alignment on FDialoguePlayParams");
static_assert(sizeof(FDialoguePlayParams) == 0x00000C, "Wrong size on FDialoguePlayParams");
static_assert(offsetof(FDialoguePlayParams, StartFromID) == 0x000000, "Member 'FDialoguePlayParams::StartFromID' has a wrong offset!");
static_assert(offsetof(FDialoguePlayParams, Priority) == 0x000008, "Member 'FDialoguePlayParams::Priority' has a wrong offset!");

// ScriptStruct Narrative.DialogueInfo
// 0x0010 (0x0010 - 0x0000)
struct FDialogueInfo final
{
public:
	class UDialogue*                              Dialogue;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NPC;                                               // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDialogueInfo) == 0x000008, "Wrong alignment on FDialogueInfo");
static_assert(sizeof(FDialogueInfo) == 0x000010, "Wrong size on FDialogueInfo");
static_assert(offsetof(FDialogueInfo, Dialogue) == 0x000000, "Member 'FDialogueInfo::Dialogue' has a wrong offset!");
static_assert(offsetof(FDialogueInfo, NPC) == 0x000008, "Member 'FDialogueInfo::NPC' has a wrong offset!");

// ScriptStruct Narrative.NarrativeUpdate
// 0x0040 (0x0040 - 0x0000)
struct FNarrativeUpdate final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EUpdateType                                   UpdateType;                                        // 0x0008(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UQuest>                     QuestClass;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Payload;                                           // 0x0018(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 IntPayload;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNarrativeUpdate) == 0x000008, "Wrong alignment on FNarrativeUpdate");
static_assert(sizeof(FNarrativeUpdate) == 0x000040, "Wrong size on FNarrativeUpdate");
static_assert(offsetof(FNarrativeUpdate, UpdateType) == 0x000008, "Member 'FNarrativeUpdate::UpdateType' has a wrong offset!");
static_assert(offsetof(FNarrativeUpdate, QuestClass) == 0x000010, "Member 'FNarrativeUpdate::QuestClass' has a wrong offset!");
static_assert(offsetof(FNarrativeUpdate, Payload) == 0x000018, "Member 'FNarrativeUpdate::Payload' has a wrong offset!");
static_assert(offsetof(FNarrativeUpdate, IntPayload) == 0x000028, "Member 'FNarrativeUpdate::IntPayload' has a wrong offset!");

// ScriptStruct Narrative.SavedQuestBranch
// 0x0018 (0x0018 - 0x0000)
struct FSavedQuestBranch final
{
public:
	class FName                                   BranchID;                                          // 0x0000(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 TasksProgress;                                     // 0x0008(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedQuestBranch) == 0x000008, "Wrong alignment on FSavedQuestBranch");
static_assert(sizeof(FSavedQuestBranch) == 0x000018, "Wrong size on FSavedQuestBranch");
static_assert(offsetof(FSavedQuestBranch, BranchID) == 0x000000, "Member 'FSavedQuestBranch::BranchID' has a wrong offset!");
static_assert(offsetof(FSavedQuestBranch, TasksProgress) == 0x000008, "Member 'FSavedQuestBranch::TasksProgress' has a wrong offset!");

// ScriptStruct Narrative.NarrativeSavedQuest
// 0x0030 (0x0030 - 0x0000)
struct FNarrativeSavedQuest final
{
public:
	TSubclassOf<class UQuest>                     QuestClass;                                        // 0x0000(0x0008)(ZeroConstructor, SaveGame, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurrentStateID;                                    // 0x0008(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSavedQuestBranch>              QuestBranches;                                     // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReachedStateNames;                                 // 0x0020(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNarrativeSavedQuest) == 0x000008, "Wrong alignment on FNarrativeSavedQuest");
static_assert(sizeof(FNarrativeSavedQuest) == 0x000030, "Wrong size on FNarrativeSavedQuest");
static_assert(offsetof(FNarrativeSavedQuest, QuestClass) == 0x000000, "Member 'FNarrativeSavedQuest::QuestClass' has a wrong offset!");
static_assert(offsetof(FNarrativeSavedQuest, CurrentStateID) == 0x000008, "Member 'FNarrativeSavedQuest::CurrentStateID' has a wrong offset!");
static_assert(offsetof(FNarrativeSavedQuest, QuestBranches) == 0x000010, "Member 'FNarrativeSavedQuest::QuestBranches' has a wrong offset!");
static_assert(offsetof(FNarrativeSavedQuest, ReachedStateNames) == 0x000020, "Member 'FNarrativeSavedQuest::ReachedStateNames' has a wrong offset!");

// ScriptStruct Narrative.QuestTask
// 0x0048 (0x0048 - 0x0000)
struct FQuestTask final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNarrativeDataTask*                     Task;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Argument;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x0024(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOptional;                                         // 0x0025(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRetroactive;                                      // 0x0026(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   TaskDescription;                                   // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         CurrentProgress;                                   // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestTask) == 0x000008, "Wrong alignment on FQuestTask");
static_assert(sizeof(FQuestTask) == 0x000048, "Wrong size on FQuestTask");
static_assert(offsetof(FQuestTask, Task) == 0x000008, "Member 'FQuestTask::Task' has a wrong offset!");
static_assert(offsetof(FQuestTask, Argument) == 0x000010, "Member 'FQuestTask::Argument' has a wrong offset!");
static_assert(offsetof(FQuestTask, Quantity) == 0x000020, "Member 'FQuestTask::Quantity' has a wrong offset!");
static_assert(offsetof(FQuestTask, bHidden) == 0x000024, "Member 'FQuestTask::bHidden' has a wrong offset!");
static_assert(offsetof(FQuestTask, bOptional) == 0x000025, "Member 'FQuestTask::bOptional' has a wrong offset!");
static_assert(offsetof(FQuestTask, bRetroactive) == 0x000026, "Member 'FQuestTask::bRetroactive' has a wrong offset!");
static_assert(offsetof(FQuestTask, TaskDescription) == 0x000028, "Member 'FQuestTask::TaskDescription' has a wrong offset!");
static_assert(offsetof(FQuestTask, CurrentProgress) == 0x000040, "Member 'FQuestTask::CurrentProgress' has a wrong offset!");

}

