#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_JigMultiplayer

#include "Basic.hpp"

#include "BP_JigMultiplayer_classes.hpp"
#include "BP_JigMultiplayer_parameters.hpp"


namespace SDK
{

// Function BP_JigMultiplayer.BP_JigMultiplayer_C.AddItemFromComp
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FContainerPickupsInfo            ItemInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FS_ReplicatedContainerInfo>SubContainers                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FGuid                            ToUID                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   VendorAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    VendorCountUpdate                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::AddItemFromComp(struct FContainerPickupsInfo& ItemInfo, TArray<struct FS_ReplicatedContainerInfo>& SubContainers, const struct FGuid& ToUID, bool FinalRotation, int32 ToIndex, int32 VendorAmount, bool* VendorCountUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "AddItemFromComp");

	Params::BP_JigMultiplayer_C_AddItemFromComp Parms{};

	Parms.ItemInfo = std::move(ItemInfo);
	Parms.SubContainers = std::move(SubContainers);
	Parms.ToUID = std::move(ToUID);
	Parms.FinalRotation = FinalRotation;
	Parms.ToIndex = ToIndex;
	Parms.VendorAmount = VendorAmount;

	UObject::ProcessEvent(Func, &Parms);

	ItemInfo = std::move(Parms.ItemInfo);
	SubContainers = std::move(Parms.SubContainers);

	if (VendorCountUpdate != nullptr)
		*VendorCountUpdate = Parms.VendorCountUpdate;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.AddItemToContainerByName
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ContainerName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TopLevelContainersOnly_                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          ItemInside                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   ItemInsideCount                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::AddItemToContainerByName(class FName ContainerName, class UJigsawItem_DataAsset_C* ItemId, int32 Count, bool TopLevelContainersOnly_, class UJigsawItem_DataAsset_C* ItemInside, int32 ItemInsideCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "AddItemToContainerByName");

	Params::BP_JigMultiplayer_C_AddItemToContainerByName Parms{};

	Parms.ContainerName = ContainerName;
	Parms.ItemId = ItemId;
	Parms.Count = Count;
	Parms.TopLevelContainersOnly_ = TopLevelContainersOnly_;
	Parms.ItemInside = ItemInside;
	Parms.ItemInsideCount = ItemInsideCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.AddJSIContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  InputPin                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::AddJSIContainer(const class UJSIContainer_C*& InputPin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "AddJSIContainer");

	Params::BP_JigMultiplayer_C_AddJSIContainer Parms{};

	Parms.InputPin = InputPin;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.AddNewItemSomewhere
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          ItemInside                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   ItemInsideCount                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DropIfFailedToAdd_                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Added                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Dropped_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            AddedToUID                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::AddNewItemSomewhere(class UJigsawItem_DataAsset_C* ItemId, int32 Count, class UJigsawItem_DataAsset_C* ItemInside, int32 ItemInsideCount, bool DropIfFailedToAdd_, bool* Added, bool* Dropped_, struct FGuid* ItemUID, struct FGuid* AddedToUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "AddNewItemSomewhere");

	Params::BP_JigMultiplayer_C_AddNewItemSomewhere Parms{};

	Parms.ItemId = ItemId;
	Parms.Count = Count;
	Parms.ItemInside = ItemInside;
	Parms.ItemInsideCount = ItemInsideCount;
	Parms.DropIfFailedToAdd_ = DropIfFailedToAdd_;

	UObject::ProcessEvent(Func, &Parms);

	if (Added != nullptr)
		*Added = Parms.Added;

	if (Dropped_ != nullptr)
		*Dropped_ = Parms.Dropped_;

	if (ItemUID != nullptr)
		*ItemUID = std::move(Parms.ItemUID);

	if (AddedToUID != nullptr)
		*AddedToUID = std::move(Parms.AddedToUID);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.AddNewItemToSlot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FContainerPickupsInfo            ItemInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// struct FGuid                            ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_ReplicatedContainerInfo>ContainerContent                                       (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// bool                                    SetUID_                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Added                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            AddedItemInfo                                          (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::AddNewItemToSlot(struct FContainerPickupsInfo& ItemInfo, const struct FGuid& ToContainer, int32 ToIndex, TArray<struct FS_ReplicatedContainerInfo>& ContainerContent, bool SetUID_, bool* Added, struct FContainerPickupsInfo* AddedItemInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "AddNewItemToSlot");

	Params::BP_JigMultiplayer_C_AddNewItemToSlot Parms{};

	Parms.ItemInfo = std::move(ItemInfo);
	Parms.ToContainer = std::move(ToContainer);
	Parms.ToIndex = ToIndex;
	Parms.ContainerContent = std::move(ContainerContent);
	Parms.SetUID_ = SetUID_;

	UObject::ProcessEvent(Func, &Parms);

	ItemInfo = std::move(Parms.ItemInfo);
	ContainerContent = std::move(Parms.ContainerContent);

	if (Added != nullptr)
		*Added = Parms.Added;

	if (AddedItemInfo != nullptr)
		*AddedItemInfo = std::move(Parms.AddedItemInfo);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.AddNewPendingRequest
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      NewItem                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::AddNewPendingRequest(const class UJSI_Slot_C*& NewItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "AddNewPendingRequest");

	Params::BP_JigMultiplayer_C_AddNewPendingRequest Parms{};

	Parms.NewItem = NewItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.AdjustCrafting
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::AdjustCrafting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "AdjustCrafting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.AdjustEquipToContainerSettings
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::AdjustEquipToContainerSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "AdjustEquipToContainerSettings");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.AdjustNewContainerSize
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          DA                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::AdjustNewContainerSize(class UJigsawItem_DataAsset_C* DA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "AdjustNewContainerSize");

	Params::BP_JigMultiplayer_C_AdjustNewContainerSize Parms{};

	Parms.DA = DA;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.BindMainEvents
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::BindMainEvents(class UJSIContainer_C* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "BindMainEvents");

	Params::BP_JigMultiplayer_C_BindMainEvents Parms{};

	Parms.Container = Container;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.BuildContainerSlots
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_ContainerSlots>        SlotArr                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// int32                                   Columns                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Rows                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::BuildContainerSlots(TArray<struct FS_ContainerSlots>& SlotArr, int32 Columns, int32 Rows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "BuildContainerSlots");

	Params::BP_JigMultiplayer_C_BuildContainerSlots Parms{};

	Parms.SlotArr = std::move(SlotArr);
	Parms.Columns = Columns;
	Parms.Rows = Rows;

	UObject::ProcessEvent(Func, &Parms);

	SlotArr = std::move(Parms.SlotArr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.BuildDataToContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FContainerPickupsInfo>    Data                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::BuildDataToContainer(TArray<struct FContainerPickupsInfo>& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "BuildDataToContainer");

	Params::BP_JigMultiplayer_C_BuildDataToContainer Parms{};

	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);

	Data = std::move(Parms.Data);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.BulkUpdateStats
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     StatTag                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// double                                  Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Override_                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::BulkUpdateStats(const struct FGameplayTag& StatTag, double Value, bool Override_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "BulkUpdateStats");

	Params::BP_JigMultiplayer_C_BulkUpdateStats Parms{};

	Parms.StatTag = std::move(StatTag);
	Parms.Value = Value;
	Parms.Override_ = Override_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CanAddItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FContainerPickupsInfo            Info                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ToMain_                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CanAddItem(struct FContainerPickupsInfo& Info, const struct FGuid& ToContainerUID, int32 Index_0, bool FinalRotation, bool* Result, bool* ToMain_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CanAddItem");

	Params::BP_JigMultiplayer_C_CanAddItem Parms{};

	Parms.Info = std::move(Info);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.Index_0 = Index_0;
	Parms.FinalRotation = FinalRotation;

	UObject::ProcessEvent(Func, &Parms);

	Info = std::move(Parms.Info);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (ToMain_ != nullptr)
		*ToMain_ = Parms.ToMain_;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CanAddToContainerIgnoreIndexes
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_ReplicatedContainerInfo       RepContainer                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        Vec                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<int32>                           Ignore                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Proceed                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CanAddToContainerIgnoreIndexes(struct FS_ReplicatedContainerInfo& RepContainer, int32 ToIndex, const struct FVector2D& Vec, TArray<int32>& Ignore, bool* Proceed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CanAddToContainerIgnoreIndexes");

	Params::BP_JigMultiplayer_C_CanAddToContainerIgnoreIndexes Parms{};

	Parms.RepContainer = std::move(RepContainer);
	Parms.ToIndex = ToIndex;
	Parms.Vec = std::move(Vec);
	Parms.Ignore = std::move(Ignore);

	UObject::ProcessEvent(Func, &Parms);

	RepContainer = std::move(Parms.RepContainer);
	Ignore = std::move(Parms.Ignore);

	if (Proceed != nullptr)
		*Proceed = Parms.Proceed;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CanLootPickup?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CanLootPickup_(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CanLootPickup?");

	Params::BP_JigMultiplayer_C_CanLootPickup_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CheckCanClearContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CheckCanClearContainer(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CheckCanClearContainer");

	Params::BP_JigMultiplayer_C_CheckCanClearContainer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CheckCapacityContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRepItemInfo                     ContainerInfo                                          (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   FreeSpace                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UJigsawItem_DataAsset_C*>  AvailableIDs                                           (Parm, OutParm)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::CheckCapacityContainer(const struct FRepItemInfo& ContainerInfo, const struct FGuid& ToContainerUID, int32* FreeSpace, TArray<class UJigsawItem_DataAsset_C*>* AvailableIDs, int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CheckCapacityContainer");

	Params::BP_JigMultiplayer_C_CheckCapacityContainer Parms{};

	Parms.ContainerInfo = std::move(ContainerInfo);
	Parms.ToContainerUID = std::move(ToContainerUID);

	UObject::ProcessEvent(Func, &Parms);

	if (FreeSpace != nullptr)
		*FreeSpace = Parms.FreeSpace;

	if (AvailableIDs != nullptr)
		*AvailableIDs = std::move(Parms.AvailableIDs);

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CheckContainerRefill
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    BeginPlay_                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CheckContainerRefill(bool BeginPlay_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CheckContainerRefill");

	Params::BP_JigMultiplayer_C_CheckContainerRefill Parms{};

	Parms.BeginPlay_ = BeginPlay_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CheckCraftingIngredients
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRepItemInfo                     RequiredItem                                           (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// TArray<struct FGuid>                    Exclude                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class UJSI_Slot_C*>              ItemFound_Element                                      (Parm, OutParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::CheckCraftingIngredients(const struct FRepItemInfo& RequiredItem, TArray<struct FGuid>& Exclude, TArray<class UJSI_Slot_C*>* ItemFound_Element)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CheckCraftingIngredients");

	Params::BP_JigMultiplayer_C_CheckCraftingIngredients Parms{};

	Parms.RequiredItem = std::move(RequiredItem);
	Parms.Exclude = std::move(Exclude);

	UObject::ProcessEvent(Func, &Parms);

	Exclude = std::move(Parms.Exclude);

	if (ItemFound_Element != nullptr)
		*ItemFound_Element = std::move(Parms.ItemFound_Element);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CheckIfCapacityContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGuid                            ItemMotherUID                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsCapacity                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CheckIfCapacityContainer(const struct FGuid& ItemMotherUID, bool* IsCapacity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CheckIfCapacityContainer");

	Params::BP_JigMultiplayer_C_CheckIfCapacityContainer Parms{};

	Parms.ItemMotherUID = std::move(ItemMotherUID);

	UObject::ProcessEvent(Func, &Parms);

	if (IsCapacity != nullptr)
		*IsCapacity = Parms.IsCapacity;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CheckIfHasEnoughMoney
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Price                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          Currency                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::CheckIfHasEnoughMoney(int32 Price, class UJigsawItem_DataAsset_C* Currency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CheckIfHasEnoughMoney");

	Params::BP_JigMultiplayer_C_CheckIfHasEnoughMoney Parms{};

	Parms.Price = Price;
	Parms.Currency = Currency;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CheckIfItemsExist
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJigsawItem_DataAsset_C*>  Items                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CheckIfItemsExist(TArray<class UJigsawItem_DataAsset_C*>& Items, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CheckIfItemsExist");

	Params::BP_JigMultiplayer_C_CheckIfItemsExist Parms{};

	Parms.Items = std::move(Items);

	UObject::ProcessEvent(Func, &Parms);

	Items = std::move(Parms.Items);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClearContainer
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ResetInit_                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ClearContainer(bool ResetInit_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClearContainer");

	Params::BP_JigMultiplayer_C_ClearContainer Parms{};

	Parms.ResetInit_ = ResetInit_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClearContainerWidgets
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::ClearContainerWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClearContainerWidgets");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClearJSIItems
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::ClearJSIItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClearJSIItems");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_AddActorToContainerSUCCESS
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            ItemAdded                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FContainerPickupsInfo>    ContainerContent                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FGuid                            TempUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_UpdateCount>           UpdateCounts                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::CLIENT_AddActorToContainerSUCCESS(class AActor* ActorRef, const struct FContainerPickupsInfo& ItemAdded, const TArray<struct FContainerPickupsInfo>& ContainerContent, const struct FGuid& TempUID, const TArray<struct FS_UpdateCount>& UpdateCounts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_AddActorToContainerSUCCESS");

	Params::BP_JigMultiplayer_C_CLIENT_AddActorToContainerSUCCESS Parms{};

	Parms.ActorRef = ActorRef;
	Parms.ItemAdded = std::move(ItemAdded);
	Parms.ContainerContent = std::move(ContainerContent);
	Parms.TempUID = std::move(TempUID);
	Parms.UpdateCounts = std::move(UpdateCounts);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_AddNewItem
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FContainerPickupsInfo            ItemInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FContainerPickupsInfo>    Content                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class UBP_JigMultiplayer_C*             Comp                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            PendingUID                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_AddNewItem(const struct FContainerPickupsInfo& ItemInfo, const TArray<struct FContainerPickupsInfo>& Content, class UBP_JigMultiplayer_C* Comp, const struct FGuid& PendingUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_AddNewItem");

	Params::BP_JigMultiplayer_C_CLIENT_AddNewItem Parms{};

	Parms.ItemInfo = std::move(ItemInfo);
	Parms.Content = std::move(Content);
	Parms.Comp = Comp;
	Parms.PendingUID = std::move(PendingUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_AddStackActorResponse
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Success                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_AddStackActorResponse(bool Success, const struct FGuid& ItemUID, int32 NewCount, class AActor* ActorRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_AddStackActorResponse");

	Params::BP_JigMultiplayer_C_CLIENT_AddStackActorResponse Parms{};

	Parms.Success = Success;
	Parms.ItemUID = std::move(ItemUID);
	Parms.NewCount = NewCount;
	Parms.ActorRef = ActorRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_ContainerDataResponse
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FGuid>                    MainContainersUIDs                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FContainerPickupsInfo>    ContainerItems                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class UBP_JigMultiplayer_C*             JigMPCompRef                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    ActionbarUIDs                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::CLIENT_ContainerDataResponse(const TArray<struct FGuid>& MainContainersUIDs, const TArray<struct FContainerPickupsInfo>& ContainerItems, class UBP_JigMultiplayer_C* JigMPCompRef, const TArray<struct FGuid>& ActionbarUIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_ContainerDataResponse");

	Params::BP_JigMultiplayer_C_CLIENT_ContainerDataResponse Parms{};

	Parms.MainContainersUIDs = std::move(MainContainersUIDs);
	Parms.ContainerItems = std::move(ContainerItems);
	Parms.JigMPCompRef = JigMPCompRef;
	Parms.ActionbarUIDs = std::move(ActionbarUIDs);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_DropRequestFailed
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_DropRequestFailed(const struct FGuid& ItemUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_DropRequestFailed");

	Params::BP_JigMultiplayer_C_CLIENT_DropRequestFailed Parms{};

	Parms.ItemUID = std::move(ItemUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_EquipActorSuccess
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            ItemAdded                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FContainerPickupsInfo>    ContainerContent                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::CLIENT_EquipActorSuccess(class AActor* ActorRef, const struct FContainerPickupsInfo& ItemAdded, const TArray<struct FContainerPickupsInfo>& ContainerContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_EquipActorSuccess");

	Params::BP_JigMultiplayer_C_CLIENT_EquipActorSuccess Parms{};

	Parms.ActorRef = ActorRef;
	Parms.ItemAdded = std::move(ItemAdded);
	Parms.ContainerContent = std::move(ContainerContent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_ExpandContainer
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AddedColumn                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AddedRow                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_ExpandContainer(const struct FGuid& ContainerUID, int32 AddedColumn, int32 AddedRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_ExpandContainer");

	Params::BP_JigMultiplayer_C_CLIENT_ExpandContainer Parms{};

	Parms.ContainerUID = std::move(ContainerUID);
	Parms.AddedColumn = AddedColumn;
	Parms.AddedRow = AddedRow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_ItemCraftedResponse
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            TempUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            ItemAdded                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Success_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    UpdateUIDs                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<int32>                           WithCounts                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    IsCraftingStation_                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            ItemInside                                             (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_ItemCraftedResponse(const struct FGuid& TempUID, const struct FContainerPickupsInfo& ItemAdded, bool Success_, const TArray<struct FGuid>& UpdateUIDs, TArray<int32>& WithCounts, bool IsCraftingStation_, const struct FContainerPickupsInfo& ItemInside)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_ItemCraftedResponse");

	Params::BP_JigMultiplayer_C_CLIENT_ItemCraftedResponse Parms{};

	Parms.TempUID = std::move(TempUID);
	Parms.ItemAdded = std::move(ItemAdded);
	Parms.Success_ = Success_;
	Parms.UpdateUIDs = std::move(UpdateUIDs);
	Parms.WithCounts = std::move(WithCounts);
	Parms.IsCraftingStation_ = IsCraftingStation_;
	Parms.ItemInside = std::move(ItemInside);

	UObject::ProcessEvent(Func, &Parms);

	WithCounts = std::move(Parms.WithCounts);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_ItemRemoved
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             Comp                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    SkipPendingRequests_                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_ItemRemoved(const struct FGuid& UID, class UBP_JigMultiplayer_C* Comp, bool SkipPendingRequests_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_ItemRemoved");

	Params::BP_JigMultiplayer_C_CLIENT_ItemRemoved Parms{};

	Parms.UID = std::move(UID);
	Parms.Comp = Comp;
	Parms.SkipPendingRequests_ = SkipPendingRequests_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_MoveItemToIndex
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_MoveItemToIndex(const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool FinalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_MoveItemToIndex");

	Params::BP_JigMultiplayer_C_CLIENT_MoveItemToIndex Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.FinalRotation = FinalRotation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_MoveToIndexFailed
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FGuid>                    ItemUID                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UBP_JigMultiplayer_C*             JijgCompTarget                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_MoveToIndexFailed(const TArray<struct FGuid>& ItemUID, class UBP_JigMultiplayer_C* JijgCompTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_MoveToIndexFailed");

	Params::BP_JigMultiplayer_C_CLIENT_MoveToIndexFailed Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.JijgCompTarget = JijgCompTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_NewItemAdded
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRepItemInfo                     ItemInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_UpdateCount                   UpdateCount                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            RemovePending                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_SubContainerInfo>      SubContainers                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::CLIENT_NewItemAdded(const struct FRepItemInfo& ItemInfo, const struct FGuid& UID, const struct FGuid& ToContainerUID, int32 ToIndex, bool FinalRotation, const struct FS_UpdateCount& UpdateCount, const struct FGuid& RemovePending, TArray<struct FS_SubContainerInfo>& SubContainers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_NewItemAdded");

	Params::BP_JigMultiplayer_C_CLIENT_NewItemAdded Parms{};

	Parms.ItemInfo = std::move(ItemInfo);
	Parms.UID = std::move(UID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.FinalRotation = FinalRotation;
	Parms.UpdateCount = std::move(UpdateCount);
	Parms.RemovePending = std::move(RemovePending);
	Parms.SubContainers = std::move(SubContainers);

	UObject::ProcessEvent(Func, &Parms);

	SubContainers = std::move(Parms.SubContainers);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_OnStatsUpdated
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FGuid>                    UID                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FGameplayTag                     STAT_NAME                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// TArray<double>                          Values                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::CLIENT_OnStatsUpdated(const TArray<struct FGuid>& UID, const struct FGameplayTag& STAT_NAME, const TArray<double>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_OnStatsUpdated");

	Params::BP_JigMultiplayer_C_CLIENT_OnStatsUpdated Parms{};

	Parms.UID = std::move(UID);
	Parms.STAT_NAME = std::move(STAT_NAME);
	Parms.Values = std::move(Values);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_OnStatUpdated
// (Net, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     STAT_TAG                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// double                                  NewValue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_OnStatUpdated(const struct FGuid& UID, const struct FGameplayTag& STAT_TAG, double NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_OnStatUpdated");

	Params::BP_JigMultiplayer_C_CLIENT_OnStatUpdated Parms{};

	Parms.UID = std::move(UID);
	Parms.STAT_TAG = std::move(STAT_TAG);
	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_ReloadResponse
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Success_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UnloadUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UnloadToContainerUID                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRot                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ReloadUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ReloadToContainerUID                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_ReloadResponse(bool Success_, const struct FGuid& UnloadUID, const struct FGuid& UnloadToContainerUID, int32 ToIndex, bool FinalRot, const struct FGuid& ReloadUID, const struct FGuid& ReloadToContainerUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_ReloadResponse");

	Params::BP_JigMultiplayer_C_CLIENT_ReloadResponse Parms{};

	Parms.Success_ = Success_;
	Parms.UnloadUID = std::move(UnloadUID);
	Parms.UnloadToContainerUID = std::move(UnloadToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.FinalRot = FinalRot;
	Parms.ReloadUID = std::move(ReloadUID);
	Parms.ReloadToContainerUID = std::move(ReloadToContainerUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_RequestAddActorToContainerFAILED
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            TempUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_RequestAddActorToContainerFAILED(class AActor* ActorRef, const struct FGuid& TempUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_RequestAddActorToContainerFAILED");

	Params::BP_JigMultiplayer_C_CLIENT_RequestAddActorToContainerFAILED Parms{};

	Parms.ActorRef = ActorRef;
	Parms.TempUID = std::move(TempUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_RequestEquipResponseFailed
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            MainContainerUID                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_RequestEquipResponseFailed(const struct FGuid& MainContainerUID, class AActor* ActorRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_RequestEquipResponseFailed");

	Params::BP_JigMultiplayer_C_CLIENT_RequestEquipResponseFailed Parms{};

	Parms.MainContainerUID = std::move(MainContainerUID);
	Parms.ActorRef = ActorRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Client_SameCompUpdateSplitRequest
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            SourceUID                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SourceNewCount                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRepItemInfo                     NewItem                                                (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FGuid                            NewItemUID                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::Client_SameCompUpdateSplitRequest(const struct FGuid& SourceUID, int32 SourceNewCount, const struct FRepItemInfo& NewItem, const struct FGuid& NewItemUID, const struct FGuid& ToContainerUID, int32 ToSlot, bool Rotated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Client_SameCompUpdateSplitRequest");

	Params::BP_JigMultiplayer_C_Client_SameCompUpdateSplitRequest Parms{};

	Parms.SourceUID = std::move(SourceUID);
	Parms.SourceNewCount = SourceNewCount;
	Parms.NewItem = std::move(NewItem);
	Parms.NewItemUID = std::move(NewItemUID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToSlot = ToSlot;
	Parms.Rotated = Rotated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_SwapContainersResponse
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            SecondContainerUID                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Success                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_SwapContainersResponse(const struct FGuid& ContainerUID, const struct FGuid& SecondContainerUID, bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_SwapContainersResponse");

	Params::BP_JigMultiplayer_C_CLIENT_SwapContainersResponse Parms{};

	Parms.ContainerUID = std::move(ContainerUID);
	Parms.SecondContainerUID = std::move(SecondContainerUID);
	Parms.Success = Success;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_UpdateChamberBulletUID
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            NewUID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_UpdateChamberBulletUID(const struct FGuid& NewUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_UpdateChamberBulletUID");

	Params::BP_JigMultiplayer_C_CLIENT_UpdateChamberBulletUID Parms{};

	Parms.NewUID = std::move(NewUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_UpdateCount
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             TargetComp                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            RemovedPending                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_UpdateCount(class UBP_JigMultiplayer_C* TargetComp, const struct FGuid& ItemUID, int32 NewCount, const struct FGuid& RemovedPending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_UpdateCount");

	Params::BP_JigMultiplayer_C_CLIENT_UpdateCount Parms{};

	Parms.TargetComp = TargetComp;
	Parms.ItemUID = std::move(ItemUID);
	Parms.NewCount = NewCount;
	Parms.RemovedPending = std::move(RemovedPending);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_UpdateCounts
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_UpdateCount>           Counts                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FGuid                            TempUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_UpdateCounts(const TArray<struct FS_UpdateCount>& Counts, const struct FGuid& TempUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_UpdateCounts");

	Params::BP_JigMultiplayer_C_CLIENT_UpdateCounts Parms{};

	Parms.Counts = std::move(Counts);
	Parms.TempUID = std::move(TempUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_UpdateCustomValues
// (Net, NetReliable, HasOutParams, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class FString>                   Keys                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class FString>                   Values                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::CLIENT_UpdateCustomValues(const struct FGuid& ItemUID, const TArray<class FString>& Keys, const TArray<class FString>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_UpdateCustomValues");

	Params::BP_JigMultiplayer_C_CLIENT_UpdateCustomValues Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.Keys = std::move(Keys);
	Parms.Values = std::move(Values);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_UpdateDurability
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        NewDurab                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_UpdateDurability(const struct FGuid& ItemUID, const struct FVector2D& NewDurab)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_UpdateDurability");

	Params::BP_JigMultiplayer_C_CLIENT_UpdateDurability Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.NewDurab = std::move(NewDurab);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.CLIENT_UpdateStack
// (Net, NetReliable, NetClient, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            DroppedUID                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   DropNewCount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            RecUID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   RecNewCount                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::CLIENT_UpdateStack(const struct FGuid& DroppedUID, int32 DropNewCount, const struct FGuid& RecUID, int32 RecNewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "CLIENT_UpdateStack");

	Params::BP_JigMultiplayer_C_CLIENT_UpdateStack Parms{};

	Parms.DroppedUID = std::move(DroppedUID);
	Parms.DropNewCount = DropNewCount;
	Parms.RecUID = std::move(RecUID);
	Parms.RecNewCount = RecNewCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClientFunc_CheckIfCanStackAddActor
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    TestOnlly                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Handled                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            WithUID                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    PartialStacks                                          (Parm, OutParm)

void UBP_JigMultiplayer_C::ClientFunc_CheckIfCanStackAddActor(class AActor* ActorRef, bool TestOnlly, bool* Handled, struct FGuid* WithUID, TArray<struct FGuid>* PartialStacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClientFunc_CheckIfCanStackAddActor");

	Params::BP_JigMultiplayer_C_ClientFunc_CheckIfCanStackAddActor Parms{};

	Parms.ActorRef = ActorRef;
	Parms.TestOnlly = TestOnlly;

	UObject::ProcessEvent(Func, &Parms);

	if (Handled != nullptr)
		*Handled = Parms.Handled;

	if (WithUID != nullptr)
		*WithUID = std::move(Parms.WithUID);

	if (PartialStacks != nullptr)
		*PartialStacks = std::move(Parms.PartialStacks);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClientFunc_GetDesiredMoneyLocation
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             VendorCom                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      DroppedItem                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerID                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ClientFunc_GetDesiredMoneyLocation(class UBP_JigMultiplayer_C* VendorCom, class UJSI_Slot_C* DroppedItem, bool* Found, struct FGuid* ToContainerID, int32* ToIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClientFunc_GetDesiredMoneyLocation");

	Params::BP_JigMultiplayer_C_ClientFunc_GetDesiredMoneyLocation Parms{};

	Parms.VendorCom = VendorCom;
	Parms.DroppedItem = DroppedItem;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (ToContainerID != nullptr)
		*ToContainerID = std::move(Parms.ToContainerID);

	if (ToIndex != nullptr)
		*ToIndex = Parms.ToIndex;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClientFunc_HandleActorAddedToContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            ItemAdded                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FContainerPickupsInfo>    ContainerContent                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FGuid                            TempUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_UpdateCount>           UpdateCounts                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::ClientFunc_HandleActorAddedToContainer(class AActor* ActorRef, const struct FContainerPickupsInfo& ItemAdded, const TArray<struct FContainerPickupsInfo>& ContainerContent, const struct FGuid& TempUID, TArray<struct FS_UpdateCount>& UpdateCounts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClientFunc_HandleActorAddedToContainer");

	Params::BP_JigMultiplayer_C_ClientFunc_HandleActorAddedToContainer Parms{};

	Parms.ActorRef = ActorRef;
	Parms.ItemAdded = std::move(ItemAdded);
	Parms.ContainerContent = std::move(ContainerContent);
	Parms.TempUID = std::move(TempUID);
	Parms.UpdateCounts = std::move(UpdateCounts);

	UObject::ProcessEvent(Func, &Parms);

	UpdateCounts = std::move(Parms.UpdateCounts);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClientFunc_UpdateCustomData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class FString>                   Keys                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class FString>                   Values                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::ClientFunc_UpdateCustomData(const struct FGuid& ItemUID, TArray<class FString>& Keys, TArray<class FString>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClientFunc_UpdateCustomData");

	Params::BP_JigMultiplayer_C_ClientFunc_UpdateCustomData Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.Keys = std::move(Keys);
	Parms.Values = std::move(Values);

	UObject::ProcessEvent(Func, &Parms);

	Keys = std::move(Parms.Keys);
	Values = std::move(Parms.Values);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClientFunc_UpdateDurability
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        NewDurab                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ClientFunc_UpdateDurability(const struct FGuid& ItemUID, const struct FVector2D& NewDurab)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClientFunc_UpdateDurability");

	Params::BP_JigMultiplayer_C_ClientFunc_UpdateDurability Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.NewDurab = std::move(NewDurab);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClientFunc_UpdateStatByUID
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     STAT_TAG                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// double                                  NewValue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ClientFunc_UpdateStatByUID(const struct FGuid& UID, const struct FGameplayTag& STAT_TAG, double NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClientFunc_UpdateStatByUID");

	Params::BP_JigMultiplayer_C_ClientFunc_UpdateStatByUID Parms{};

	Parms.UID = std::move(UID);
	Parms.STAT_TAG = std::move(STAT_TAG);
	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClientFuncHandleReloadResponse
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Success_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UnloadUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UnloadToContainerUID                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRot                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ReloadUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ReloadToContainerUID                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ClientFuncHandleReloadResponse(bool Success_, const struct FGuid& UnloadUID, const struct FGuid& UnloadToContainerUID, int32 ToIndex, bool FinalRot, const struct FGuid& ReloadUID, const struct FGuid& ReloadToContainerUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClientFuncHandleReloadResponse");

	Params::BP_JigMultiplayer_C_ClientFuncHandleReloadResponse Parms{};

	Parms.Success_ = Success_;
	Parms.UnloadUID = std::move(UnloadUID);
	Parms.UnloadToContainerUID = std::move(UnloadToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.FinalRot = FinalRot;
	Parms.ReloadUID = std::move(ReloadUID);
	Parms.ReloadToContainerUID = std::move(ReloadToContainerUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClientFuncItemCrafted
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            TempUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            ItemAdded                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Success_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    UpdateUIDs                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<int32>                           WithCounts                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    IsCraftingStation_                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            ItemInside                                             (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ClientFuncItemCrafted(const struct FGuid& TempUID, const struct FContainerPickupsInfo& ItemAdded, bool Success_, TArray<struct FGuid>& UpdateUIDs, TArray<int32>& WithCounts, bool IsCraftingStation_, const struct FContainerPickupsInfo& ItemInside)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClientFuncItemCrafted");

	Params::BP_JigMultiplayer_C_ClientFuncItemCrafted Parms{};

	Parms.TempUID = std::move(TempUID);
	Parms.ItemAdded = std::move(ItemAdded);
	Parms.Success_ = Success_;
	Parms.UpdateUIDs = std::move(UpdateUIDs);
	Parms.WithCounts = std::move(WithCounts);
	Parms.IsCraftingStation_ = IsCraftingStation_;
	Parms.ItemInside = std::move(ItemInside);

	UObject::ProcessEvent(Func, &Parms);

	UpdateUIDs = std::move(Parms.UpdateUIDs);
	WithCounts = std::move(Parms.WithCounts);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClientHandleTwoContainersSwap
// (Private, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            SecondContainerUID                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Success                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ClientHandleTwoContainersSwap(const struct FGuid& ContainerUID, const struct FGuid& SecondContainerUID, bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClientHandleTwoContainersSwap");

	Params::BP_JigMultiplayer_C_ClientHandleTwoContainersSwap Parms{};

	Parms.ContainerUID = std::move(ContainerUID);
	Parms.SecondContainerUID = std::move(SecondContainerUID);
	Parms.Success = Success;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClientSetupSwappingTwoContainers
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            SecondaryContainer                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ClientSetupSwappingTwoContainers(const struct FGuid& Container, const struct FGuid& SecondaryContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClientSetupSwappingTwoContainers");

	Params::BP_JigMultiplayer_C_ClientSetupSwappingTwoContainers Parms{};

	Parms.Container = std::move(Container);
	Parms.SecondaryContainer = std::move(SecondaryContainer);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ClientUpdateCount
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RemoveIf0                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ClientUpdateCount(const struct FGuid& ItemUID, int32 NewCount, bool RemoveIf0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ClientUpdateCount");

	Params::BP_JigMultiplayer_C_ClientUpdateCount Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.NewCount = NewCount;
	Parms.RemoveIf0 = RemoveIf0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Context_TryEquip
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      EquippedItem                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  JSIRootCont                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::Context_TryEquip(class UJSI_Slot_C* EquippedItem, class UJSIContainer_C* JSIRootCont)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Context_TryEquip");

	Params::BP_JigMultiplayer_C_Context_TryEquip Parms{};

	Parms.EquippedItem = EquippedItem;
	Parms.JSIRootCont = JSIRootCont;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Context_TryUnequip
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      EquippedItem                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  JSIRootCont                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::Context_TryUnequip(class UJSI_Slot_C* EquippedItem, class UJSIContainer_C* JSIRootCont)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Context_TryUnequip");

	Params::BP_JigMultiplayer_C_Context_TryUnequip Parms{};

	Parms.EquippedItem = EquippedItem;
	Parms.JSIRootCont = JSIRootCont;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Context_TryUnloadAmmo
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  RootContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::Context_TryUnloadAmmo(class UJSI_Slot_C* ItemRef, class UJSIContainer_C* RootContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Context_TryUnloadAmmo");

	Params::BP_JigMultiplayer_C_Context_TryUnloadAmmo Parms{};

	Parms.ItemRef = ItemRef;
	Parms.RootContainer = RootContainer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Controller?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::Controller_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Controller?");

	Params::BP_JigMultiplayer_C_Controller_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.DeepSearchForContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  Array_Element                                          (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::DeepSearchForContainer(const struct FGuid& UID, class UJSIContainer_C* Target, class UJSIContainer_C** Array_Element)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "DeepSearchForContainer");

	Params::BP_JigMultiplayer_C_DeepSearchForContainer Parms{};

	Parms.UID = std::move(UID);
	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);

	if (Array_Element != nullptr)
		*Array_Element = Parms.Array_Element;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.DeepSearchForItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemFound                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::DeepSearchForItem(const struct FGuid& UID, class UJSI_Slot_C** ItemFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "DeepSearchForItem");

	Params::BP_JigMultiplayer_C_DeepSearchForItem Parms{};

	Parms.UID = std::move(UID);

	UObject::ProcessEvent(Func, &Parms);

	if (ItemFound != nullptr)
		*ItemFound = Parms.ItemFound;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.DetectDuplicateIDs
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::DetectDuplicateIDs(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "DetectDuplicateIDs");

	Params::BP_JigMultiplayer_C_DetectDuplicateIDs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Drop_ItemOverItem_Event_0
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemReceiver                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemDropped                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ItemReceiverContainer                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ItemDroppedContainer                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::Drop_ItemOverItem_Event_0(class UJSI_Slot_C* ItemReceiver, class UJSI_Slot_C* ItemDropped, class UJSIContainer_C* ItemReceiverContainer, class UJSIContainer_C* ItemDroppedContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Drop_ItemOverItem_Event_0");

	Params::BP_JigMultiplayer_C_Drop_ItemOverItem_Event_0 Parms{};

	Parms.ItemReceiver = ItemReceiver;
	Parms.ItemDropped = ItemDropped;
	Parms.ItemReceiverContainer = ItemReceiverContainer;
	Parms.ItemDroppedContainer = ItemDroppedContainer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.DropAllItems
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::DropAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "DropAllItems");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.EventOnInventoryAction
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      DroppedSlotRef                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotReceiverRef                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlotIndex                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::EventOnInventoryAction(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* DroppedSlotRef, class UJSI_Slot_C* SlotReceiverRef, int32 ToSlotIndex, bool Rotated_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "EventOnInventoryAction");

	Params::BP_JigMultiplayer_C_EventOnInventoryAction Parms{};

	Parms.FromContainer = FromContainer;
	Parms.ToContainer = ToContainer;
	Parms.DroppedSlotRef = DroppedSlotRef;
	Parms.SlotReceiverRef = SlotReceiverRef;
	Parms.ToSlotIndex = ToSlotIndex;
	Parms.Rotated_ = Rotated_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.EventOnJigItemMouseButtonDown
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FKey                             Button                                                 (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::EventOnJigItemMouseButtonDown(class UJSIContainer_C* Container, class UJSI_Slot_C* SlotRef, const struct FKey& Button)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "EventOnJigItemMouseButtonDown");

	Params::BP_JigMultiplayer_C_EventOnJigItemMouseButtonDown Parms{};

	Parms.Container = Container;
	Parms.SlotRef = SlotRef;
	Parms.Button = std::move(Button);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ExecuteUbergraph_BP_JigMultiplayer
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ExecuteUbergraph_BP_JigMultiplayer(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ExecuteUbergraph_BP_JigMultiplayer");

	Params::BP_JigMultiplayer_C_ExecuteUbergraph_BP_JigMultiplayer Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Find Actor Ref byItemUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           PickupRef                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::Find_Actor_Ref_byItemUID(const struct FGuid& UID, class AActor** PickupRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Find Actor Ref byItemUID");

	Params::BP_JigMultiplayer_C_Find_Actor_Ref_byItemUID Parms{};

	Parms.UID = std::move(UID);

	UObject::ProcessEvent(Func, &Parms);

	if (PickupRef != nullptr)
		*PickupRef = Parms.PickupRef;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Find Pickup Ref by AttachmentMotherUID
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           PickupRef                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::Find_Pickup_Ref_by_AttachmentMotherUID(const struct FGuid& ContainerUID, class AActor** PickupRef, struct FGuid* ItemUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Find Pickup Ref by AttachmentMotherUID");

	Params::BP_JigMultiplayer_C_Find_Pickup_Ref_by_AttachmentMotherUID Parms{};

	Parms.ContainerUID = std::move(ContainerUID);

	UObject::ProcessEvent(Func, &Parms);

	if (PickupRef != nullptr)
		*PickupRef = Parms.PickupRef;

	if (ItemUID != nullptr)
		*ItemUID = std::move(Parms.ItemUID);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FindAndConsume
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          ItemDA                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FindAndConsume(class UJigsawItem_DataAsset_C* ItemDA, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FindAndConsume");

	Params::BP_JigMultiplayer_C_FindAndConsume Parms{};

	Parms.ItemDA = ItemDA;
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FindCraftingIngredient
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      OneCont                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          ID                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    Exclude                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class UJSI_Slot_C*>              OutputPin                                              (Parm, OutParm, ContainsInstancedReference)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FindCraftingIngredient(class UUserWidget* OneCont, class UJigsawItem_DataAsset_C* ID, int32 Count, TArray<struct FGuid>& Exclude, TArray<class UJSI_Slot_C*>* OutputPin, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FindCraftingIngredient");

	Params::BP_JigMultiplayer_C_FindCraftingIngredient Parms{};

	Parms.OneCont = OneCont;
	Parms.ID = ID;
	Parms.Count = Count;
	Parms.Exclude = std::move(Exclude);

	UObject::ProcessEvent(Func, &Parms);

	Exclude = std::move(Parms.Exclude);

	if (OutputPin != nullptr)
		*OutputPin = std::move(Parms.OutputPin);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FindItemByMotherUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            MotherUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            FoundItem                                              (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FindItemByMotherUID(const struct FGuid& MotherUID, bool* Found_, struct FContainerPickupsInfo* FoundItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FindItemByMotherUID");

	Params::BP_JigMultiplayer_C_FindItemByMotherUID Parms{};

	Parms.MotherUID = std::move(MotherUID);

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (FoundItem != nullptr)
		*FoundItem = std::move(Parms.FoundItem);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FindItemBySubContainerUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FindItemBySubContainerUID(struct FGuid& UID, bool* Found, struct FGuid* ItemUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FindItemBySubContainerUID");

	Params::BP_JigMultiplayer_C_FindItemBySubContainerUID Parms{};

	Parms.UID = std::move(UID);

	UObject::ProcessEvent(Func, &Parms);

	UID = std::move(Parms.UID);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (ItemUID != nullptr)
		*ItemUID = std::move(Parms.ItemUID);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FindItemByUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      Found                                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FindItemByUID(const struct FGuid& UID, class UJSI_Slot_C** Found)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FindItemByUID");

	Params::BP_JigMultiplayer_C_FindItemByUID Parms{};

	Parms.UID = std::move(UID);

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FindItemInContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  InContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      Found                                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FindItemInContainer(class UJSIContainer_C* InContainer, const struct FGuid& UID, class UJSI_Slot_C** Found)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FindItemInContainer");

	Params::BP_JigMultiplayer_C_FindItemInContainer Parms{};

	Parms.InContainer = InContainer;
	Parms.UID = std::move(UID);

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FindJigContainerByUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_ReplicatedContainerInfo       Output                                                 (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FindJigContainerByUID(struct FGuid& UID, struct FS_ReplicatedContainerInfo* Output, int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FindJigContainerByUID");

	Params::BP_JigMultiplayer_C_FindJigContainerByUID Parms{};

	Parms.UID = std::move(UID);

	UObject::ProcessEvent(Func, &Parms);

	UID = std::move(Parms.UID);

	if (Output != nullptr)
		*Output = std::move(Parms.Output);

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FindJigItemByDA
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          DA                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            SearchOnlyInSlots                                      (BlueprintVisible, BlueprintReadOnly, Parm)
// bool                                    DeepSearch_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    SearchInEquipTo_                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   RequiredAmount                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      Found                                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FindJigItemByDA(class UJigsawItem_DataAsset_C* DA, const struct FGameplayTagContainer& SearchOnlyInSlots, bool DeepSearch_, bool SearchInEquipTo_, int32 RequiredAmount, bool* Result, class UJSI_Slot_C** Found)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FindJigItemByDA");

	Params::BP_JigMultiplayer_C_FindJigItemByDA Parms{};

	Parms.DA = DA;
	Parms.SearchOnlyInSlots = std::move(SearchOnlyInSlots);
	Parms.DeepSearch_ = DeepSearch_;
	Parms.SearchInEquipTo_ = SearchInEquipTo_;
	Parms.RequiredAmount = RequiredAmount;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (Found != nullptr)
		*Found = Parms.Found;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FindJSIContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  JSIRef                                                 (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FindJSIContainer(const struct FGuid& UID, class UJSIContainer_C** JSIRef, bool* Found)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FindJSIContainer");

	Params::BP_JigMultiplayer_C_FindJSIContainer Parms{};

	Parms.UID = std::move(UID);

	UObject::ProcessEvent(Func, &Parms);

	if (JSIRef != nullptr)
		*JSIRef = Parms.JSIRef;

	if (Found != nullptr)
		*Found = Parms.Found;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FindRootContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            RootCUID                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FindRootContainer(const struct FGuid& ContainerUID, struct FGuid* RootCUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FindRootContainer");

	Params::BP_JigMultiplayer_C_FindRootContainer Parms{};

	Parms.ContainerUID = std::move(ContainerUID);

	UObject::ProcessEvent(Func, &Parms);

	if (RootCUID != nullptr)
		*RootCUID = std::move(Parms.RootCUID);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FindRootContainer_Pure
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            RootCUID                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FindRootContainer_Pure(const struct FGuid& ContainerUID, struct FGuid* RootCUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FindRootContainer_Pure");

	Params::BP_JigMultiplayer_C_FindRootContainer_Pure Parms{};

	Parms.ContainerUID = std::move(ContainerUID);

	UObject::ProcessEvent(Func, &Parms);

	if (RootCUID != nullptr)
		*RootCUID = std::move(Parms.RootCUID);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FireArmChamberWeapon
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ChamberContainerUID                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            MagContainerUID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            BulletToChamberUID                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ChamberContainerIndex                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    SendChamberUID_                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FireArmChamberWeapon(const struct FGuid& ChamberContainerUID, const struct FGuid& MagContainerUID, const struct FGuid& BulletToChamberUID, int32 ChamberContainerIndex, bool SendChamberUID_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FireArmChamberWeapon");

	Params::BP_JigMultiplayer_C_FireArmChamberWeapon Parms{};

	Parms.ChamberContainerUID = std::move(ChamberContainerUID);
	Parms.MagContainerUID = std::move(MagContainerUID);
	Parms.BulletToChamberUID = std::move(BulletToChamberUID);
	Parms.ChamberContainerIndex = ChamberContainerIndex;
	Parms.SendChamberUID_ = SendChamberUID_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FireArmGetChamberUID
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ChamberContainerUID                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FireArmGetChamberUID(const struct FGuid& ChamberContainerUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FireArmGetChamberUID");

	Params::BP_JigMultiplayer_C_FireArmGetChamberUID Parms{};

	Parms.ChamberContainerUID = std::move(ChamberContainerUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FixUpReferences
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::FixUpReferences()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FixUpReferences");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FuncHandleCraftingTimers
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::FuncHandleCraftingTimers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FuncHandleCraftingTimers");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.FuncHandleStackResponse
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            DroppedUID                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   DropNewCount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            RecUID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   RecNewCount                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::FuncHandleStackResponse(const struct FGuid& DroppedUID, int32 DropNewCount, const struct FGuid& RecUID, int32 RecNewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "FuncHandleStackResponse");

	Params::BP_JigMultiplayer_C_FuncHandleStackResponse Parms{};

	Parms.DroppedUID = std::move(DroppedUID);
	Parms.DropNewCount = DropNewCount;
	Parms.RecUID = std::move(RecUID);
	Parms.RecNewCount = RecNewCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Generate_AddNewItemToContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            AddedItemInfo                                          (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Added_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::Generate_AddNewItemToContainer(const struct FGuid& ToContainerUID, class UJigsawItem_DataAsset_C* ItemId, int32 Count, struct FContainerPickupsInfo* AddedItemInfo, bool* Added_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Generate_AddNewItemToContainer");

	Params::BP_JigMultiplayer_C_Generate_AddNewItemToContainer Parms{};

	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ItemId = ItemId;
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);

	if (AddedItemInfo != nullptr)
		*AddedItemInfo = std::move(Parms.AddedItemInfo);

	if (Added_ != nullptr)
		*Added_ = Parms.Added_;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GenerateRandomStats
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FS_RandomStatsConfig             RandomConfig                                           (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// TArray<struct FS_ItemStat>              DTStats                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FS_ItemStat>              Stats                                                  (Parm, OutParm)

void UBP_JigMultiplayer_C::GenerateRandomStats(const struct FS_RandomStatsConfig& RandomConfig, TArray<struct FS_ItemStat>& DTStats, TArray<struct FS_ItemStat>* Stats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GenerateRandomStats");

	Params::BP_JigMultiplayer_C_GenerateRandomStats Parms{};

	Parms.RandomConfig = std::move(RandomConfig);
	Parms.DTStats = std::move(DTStats);

	UObject::ProcessEvent(Func, &Parms);

	DTStats = std::move(Parms.DTStats);

	if (Stats != nullptr)
		*Stats = std::move(Parms.Stats);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Get Index From CraftingArr
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FRepItemInfo>             Arr                                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UJigsawItem_DataAsset_C*          ID                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Array_Index                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::Get_Index_From_CraftingArr(TArray<struct FRepItemInfo>& Arr, class UJigsawItem_DataAsset_C* ID, int32* Array_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Get Index From CraftingArr");

	Params::BP_JigMultiplayer_C_Get_Index_From_CraftingArr Parms{};

	Parms.Arr = std::move(Arr);
	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);

	Arr = std::move(Parms.Arr);

	if (Array_Index != nullptr)
		*Array_Index = Parms.Array_Index;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetAllContainerByItemUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_ReplicatedContainerInfo>ContainersRef                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::GetAllContainerByItemUID(const struct FGuid& ItemUID, TArray<struct FS_ReplicatedContainerInfo>& ContainersRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetAllContainerByItemUID");

	Params::BP_JigMultiplayer_C_GetAllContainerByItemUID Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.ContainersRef = std::move(ContainersRef);

	UObject::ProcessEvent(Func, &Parms);

	ContainersRef = std::move(Parms.ContainersRef);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetAllContainersOfUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    ListFound                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::GetAllContainersOfUID(const struct FGuid& ContainerUID, TArray<struct FGuid>& ListFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetAllContainersOfUID");

	Params::BP_JigMultiplayer_C_GetAllContainersOfUID Parms{};

	Parms.ContainerUID = std::move(ContainerUID);
	Parms.ListFound = std::move(ListFound);

	UObject::ProcessEvent(Func, &Parms);

	ListFound = std::move(Parms.ListFound);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetAllContainersOfUIDCustom
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    ListFound                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FS_ReplicatedContainerInfo>Containers                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::GetAllContainersOfUIDCustom(const struct FGuid& ContainerUID, TArray<struct FGuid>& ListFound, TArray<struct FS_ReplicatedContainerInfo>& Containers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetAllContainersOfUIDCustom");

	Params::BP_JigMultiplayer_C_GetAllContainersOfUIDCustom Parms{};

	Parms.ContainerUID = std::move(ContainerUID);
	Parms.ListFound = std::move(ListFound);
	Parms.Containers = std::move(Containers);

	UObject::ProcessEvent(Func, &Parms);

	ListFound = std::move(Parms.ListFound);
	Containers = std::move(Parms.Containers);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetAllItemsSellPrice
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FContainerPickupsInfo            Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Price                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetAllItemsSellPrice(const struct FContainerPickupsInfo& Item, int32 Amount, double* Price)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetAllItemsSellPrice");

	Params::BP_JigMultiplayer_C_GetAllItemsSellPrice Parms{};

	Parms.Item = std::move(Item);
	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);

	if (Price != nullptr)
		*Price = Parms.Price;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetCapacity
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Output_Get                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetCapacity(int32* Output_Get)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetCapacity");

	Params::BP_JigMultiplayer_C_GetCapacity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Output_Get != nullptr)
		*Output_Get = Parms.Output_Get;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetColumnRowBySlotIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   NumOfColumns                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Column                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Row                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetColumnRowBySlotIndex(int32 NumOfColumns, int32 SlotIndex, int32* Column, int32* Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetColumnRowBySlotIndex");

	Params::BP_JigMultiplayer_C_GetColumnRowBySlotIndex Parms{};

	Parms.NumOfColumns = NumOfColumns;
	Parms.SlotIndex = SlotIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Column != nullptr)
		*Column = Parms.Column;

	if (Row != nullptr)
		*Row = Parms.Row;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetContainerDimensions
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          Asset                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector2D>                SpecialContainerDemensions                             (Parm, OutParm)

void UBP_JigMultiplayer_C::GetContainerDimensions(class UJigsawItem_DataAsset_C* Asset, TArray<struct FVector2D>* SpecialContainerDemensions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetContainerDimensions");

	Params::BP_JigMultiplayer_C_GetContainerDimensions Parms{};

	Parms.Asset = Asset;

	UObject::ProcessEvent(Func, &Parms);

	if (SpecialContainerDemensions != nullptr)
		*SpecialContainerDemensions = std::move(Parms.SpecialContainerDemensions);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetContainerIndex
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetContainerIndex(class UJSI_Slot_C* ItemRef, int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetContainerIndex");

	Params::BP_JigMultiplayer_C_GetContainerIndex Parms{};

	Parms.ItemRef = ItemRef;

	UObject::ProcessEvent(Func, &Parms);

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetContainerItemByInContainerIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ContainerIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            FoundItem                                              (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetContainerItemByInContainerIndex(const struct FGuid& ContainerUID, int32 ContainerIndex, bool* Found_, struct FContainerPickupsInfo* FoundItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetContainerItemByInContainerIndex");

	Params::BP_JigMultiplayer_C_GetContainerItemByInContainerIndex Parms{};

	Parms.ContainerUID = std::move(ContainerUID);
	Parms.ContainerIndex = ContainerIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (FoundItem != nullptr)
		*FoundItem = std::move(Parms.FoundItem);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetContainerItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    RemoveExcluded_                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FContainerPickupsInfo>    AllItems                                               (Parm, OutParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::GetContainerItems(bool RemoveExcluded_, TArray<struct FContainerPickupsInfo>* AllItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetContainerItems");

	Params::BP_JigMultiplayer_C_GetContainerItems Parms{};

	Parms.RemoveExcluded_ = RemoveExcluded_;

	UObject::ProcessEvent(Func, &Parms);

	if (AllItems != nullptr)
		*AllItems = std::move(Parms.AllItems);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetContainerNameByUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             ContainerName                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetContainerNameByUID(const struct FGuid& UID, class FName* ContainerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetContainerNameByUID");

	Params::BP_JigMultiplayer_C_GetContainerNameByUID Parms{};

	Parms.UID = std::move(UID);

	UObject::ProcessEvent(Func, &Parms);

	if (ContainerName != nullptr)
		*ContainerName = Parms.ContainerName;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetCurrencyFromDT
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Price                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          Asset                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MaxStack                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            Currency                                               (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetCurrencyFromDT(double Price, class UJigsawItem_DataAsset_C* Asset, bool* Found, int32* MaxStack, struct FContainerPickupsInfo* Currency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetCurrencyFromDT");

	Params::BP_JigMultiplayer_C_GetCurrencyFromDT Parms{};

	Parms.Price = Price;
	Parms.Asset = Asset;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (MaxStack != nullptr)
		*MaxStack = Parms.MaxStack;

	if (Currency != nullptr)
		*Currency = std::move(Parms.Currency);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetDurability
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGuid                            UID                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  NewDur                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetDurability(const struct FGuid& UID, double* NewDur)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetDurability");

	Params::BP_JigMultiplayer_C_GetDurability Parms{};

	Parms.UID = std::move(UID);

	UObject::ProcessEvent(Func, &Parms);

	if (NewDur != nullptr)
		*NewDur = Parms.NewDur;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetEmptySlot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_ReplicatedContainerInfo       RepContainer                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// struct FVector2D                        ItemVec                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetEmptySlot(struct FS_ReplicatedContainerInfo& RepContainer, const struct FVector2D& ItemVec, bool* Found, int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetEmptySlot");

	Params::BP_JigMultiplayer_C_GetEmptySlot Parms{};

	Parms.RepContainer = std::move(RepContainer);
	Parms.ItemVec = std::move(ItemVec);

	UObject::ProcessEvent(Func, &Parms);

	RepContainer = std::move(Parms.RepContainer);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetEmptySlotTryRotated
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_ReplicatedContainerInfo       RepContainer                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// struct FVector2D                        ItemVec                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetEmptySlotTryRotated(struct FS_ReplicatedContainerInfo& RepContainer, const struct FVector2D& ItemVec, bool* Found, int32* Index_0, bool* Rotated_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetEmptySlotTryRotated");

	Params::BP_JigMultiplayer_C_GetEmptySlotTryRotated Parms{};

	Parms.RepContainer = std::move(RepContainer);
	Parms.ItemVec = std::move(ItemVec);

	UObject::ProcessEvent(Func, &Parms);

	RepContainer = std::move(Parms.RepContainer);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;

	if (Rotated_ != nullptr)
		*Rotated_ = Parms.Rotated_;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetEquippedItemByContainerUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OnlyItems                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsEquipTo                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            Info                                                   (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetEquippedItemByContainerUID(const struct FGuid& ContainerUID, bool OnlyItems, bool* Found_, bool* IsEquipTo, struct FContainerPickupsInfo* Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetEquippedItemByContainerUID");

	Params::BP_JigMultiplayer_C_GetEquippedItemByContainerUID Parms{};

	Parms.ContainerUID = std::move(ContainerUID);
	Parms.OnlyItems = OnlyItems;

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (IsEquipTo != nullptr)
		*IsEquipTo = Parms.IsEquipTo;

	if (Info != nullptr)
		*Info = std::move(Parms.Info);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetHostingSlots
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   NumOfColumns                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        ItemVec                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NumOfRows                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<int32>                           Indexes                                                (Parm, OutParm)

void UBP_JigMultiplayer_C::GetHostingSlots(int32 NumOfColumns, int32 SlotIndex, const struct FVector2D& ItemVec, int32 NumOfRows, TArray<int32>* Indexes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetHostingSlots");

	Params::BP_JigMultiplayer_C_GetHostingSlots Parms{};

	Parms.NumOfColumns = NumOfColumns;
	Parms.SlotIndex = SlotIndex;
	Parms.ItemVec = std::move(ItemVec);
	Parms.NumOfRows = NumOfRows;

	UObject::ProcessEvent(Func, &Parms);

	if (Indexes != nullptr)
		*Indexes = std::move(Parms.Indexes);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetInventoryWeightByMainContainerName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Name_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Weight                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetInventoryWeightByMainContainerName(class FName Name_0, double* Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetInventoryWeightByMainContainerName");

	Params::BP_JigMultiplayer_C_GetInventoryWeightByMainContainerName Parms{};

	Parms.Name_0 = Name_0;

	UObject::ProcessEvent(Func, &Parms);

	if (Weight != nullptr)
		*Weight = Parms.Weight;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetInventoryWidgetReference
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UUserWidget*                      InventoryWidgetRef_0                                   (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    IsVisible_                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetInventoryWidgetReference(class UUserWidget** InventoryWidgetRef_0, bool* IsVisible_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetInventoryWidgetReference");

	Params::BP_JigMultiplayer_C_GetInventoryWidgetReference Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (InventoryWidgetRef_0 != nullptr)
		*InventoryWidgetRef_0 = Parms.InventoryWidgetRef_0;

	if (IsVisible_ != nullptr)
		*IsVisible_ = Parms.IsVisible_;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetItemByUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            Item                                                   (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    InMainContainer_                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetItemByUID(struct FGuid& UID, struct FContainerPickupsInfo* Item, bool* Found, bool* InMainContainer_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetItemByUID");

	Params::BP_JigMultiplayer_C_GetItemByUID Parms{};

	Parms.UID = std::move(UID);

	UObject::ProcessEvent(Func, &Parms);

	UID = std::move(Parms.UID);

	if (Item != nullptr)
		*Item = std::move(Parms.Item);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (InMainContainer_ != nullptr)
		*InMainContainer_ = Parms.InMainContainer_;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetListOfAttachments
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_RepAttachmentInfo>     Attachments                                            (Parm, OutParm)

void UBP_JigMultiplayer_C::GetListOfAttachments(const struct FGuid& ItemUID, TArray<struct FS_RepAttachmentInfo>* Attachments)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetListOfAttachments");

	Params::BP_JigMultiplayer_C_GetListOfAttachments Parms{};

	Parms.ItemUID = std::move(ItemUID);

	UObject::ProcessEvent(Func, &Parms);

	if (Attachments != nullptr)
		*Attachments = std::move(Parms.Attachments);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetLocalComp
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             JigComp                                                (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetLocalComp(class UBP_JigMultiplayer_C** JigComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetLocalComp");

	Params::BP_JigMultiplayer_C_GetLocalComp Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (JigComp != nullptr)
		*JigComp = Parms.JigComp;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetMainContainerUIDByIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UID                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ContainerIndex                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetMainContainerUIDByIndex(int32 Index_0, struct FGuid* UID, int32* ContainerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetMainContainerUIDByIndex");

	Params::BP_JigMultiplayer_C_GetMainContainerUIDByIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	if (UID != nullptr)
		*UID = std::move(Parms.UID);

	if (ContainerIndex != nullptr)
		*ContainerIndex = Parms.ContainerIndex;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetMainContainerUIDByName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ContainerName                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UID                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsEquipTo_                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetMainContainerUIDByName(class FName ContainerName, struct FGuid* UID, int32* Index_0, bool* Found_, bool* IsEquipTo_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetMainContainerUIDByName");

	Params::BP_JigMultiplayer_C_GetMainContainerUIDByName Parms{};

	Parms.ContainerName = ContainerName;

	UObject::ProcessEvent(Func, &Parms);

	if (UID != nullptr)
		*UID = std::move(Parms.UID);

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (IsEquipTo_ != nullptr)
		*IsEquipTo_ = Parms.IsEquipTo_;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetMainContainerUIDS
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<struct FGuid>                    UIDs                                                   (Parm, OutParm)

void UBP_JigMultiplayer_C::GetMainContainerUIDS(TArray<struct FGuid>* UIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetMainContainerUIDS");

	Params::BP_JigMultiplayer_C_GetMainContainerUIDS Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (UIDs != nullptr)
		*UIDs = std::move(Parms.UIDs);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetParentItemByContainerUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            Array_Element                                          (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetParentItemByContainerUID(const struct FGuid& ContainerUID, struct FContainerPickupsInfo* Array_Element, bool* Found)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetParentItemByContainerUID");

	Params::BP_JigMultiplayer_C_GetParentItemByContainerUID Parms{};

	Parms.ContainerUID = std::move(ContainerUID);

	UObject::ProcessEvent(Func, &Parms);

	if (Array_Element != nullptr)
		*Array_Element = std::move(Parms.Array_Element);

	if (Found != nullptr)
		*Found = Parms.Found;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetPickupInfoFromDT
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          ID                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            ContainerPickupsInfo                                   (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetPickupInfoFromDT(class UJigsawItem_DataAsset_C* ID, int32 Count, struct FContainerPickupsInfo* ContainerPickupsInfo, bool* Found)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetPickupInfoFromDT");

	Params::BP_JigMultiplayer_C_GetPickupInfoFromDT Parms{};

	Parms.ID = ID;
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);

	if (ContainerPickupsInfo != nullptr)
		*ContainerPickupsInfo = std::move(Parms.ContainerPickupsInfo);

	if (Found != nullptr)
		*Found = Parms.Found;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetSearchableContainers
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSIContainer_C*>          Result                                                 (Parm, OutParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::GetSearchableContainers(TArray<class UJSIContainer_C*>* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetSearchableContainers");

	Params::BP_JigMultiplayer_C_GetSearchableContainers Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetSlotIndexByColumnRow
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   NumOfColumns                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Column                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Row                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UBP_JigMultiplayer_C::GetSlotIndexByColumnRow(int32 NumOfColumns, int32 Column, int32 Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetSlotIndexByColumnRow");

	Params::BP_JigMultiplayer_C_GetSlotIndexByColumnRow Parms{};

	Parms.NumOfColumns = NumOfColumns;
	Parms.Column = Column;
	Parms.Row = Row;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetSubContainers
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_ReplicatedContainerInfo>RepContainerRef                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// TArray<struct FGuid>                    UIDList                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<int32>                           IndexList                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    SkipCapacity_                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetSubContainers(const struct FGuid& UID, TArray<struct FS_ReplicatedContainerInfo>& RepContainerRef, TArray<struct FGuid>& UIDList, TArray<int32>& IndexList, bool SkipCapacity_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetSubContainers");

	Params::BP_JigMultiplayer_C_GetSubContainers Parms{};

	Parms.UID = std::move(UID);
	Parms.RepContainerRef = std::move(RepContainerRef);
	Parms.UIDList = std::move(UIDList);
	Parms.IndexList = std::move(IndexList);
	Parms.SkipCapacity_ = SkipCapacity_;

	UObject::ProcessEvent(Func, &Parms);

	RepContainerRef = std::move(Parms.RepContainerRef);
	UIDList = std::move(Parms.UIDList);
	IndexList = std::move(Parms.IndexList);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetSubContainersOnce
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_ReplicatedContainerInfo>RepContainerRef                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::GetSubContainersOnce(const struct FGuid& UID, TArray<struct FS_ReplicatedContainerInfo>& RepContainerRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetSubContainersOnce");

	Params::BP_JigMultiplayer_C_GetSubContainersOnce Parms{};

	Parms.UID = std::move(UID);
	Parms.RepContainerRef = std::move(RepContainerRef);

	UObject::ProcessEvent(Func, &Parms);

	RepContainerRef = std::move(Parms.RepContainerRef);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetTotalCountOfItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          DA                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   TotalCount                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetTotalCountOfItem(class UJigsawItem_DataAsset_C* DA, int32* TotalCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetTotalCountOfItem");

	Params::BP_JigMultiplayer_C_GetTotalCountOfItem Parms{};

	Parms.DA = DA;

	UObject::ProcessEvent(Func, &Parms);

	if (TotalCount != nullptr)
		*TotalCount = Parms.TotalCount;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetTotalInventoryWeight
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Output_Get                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetTotalInventoryWeight(double* Output_Get)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetTotalInventoryWeight");

	Params::BP_JigMultiplayer_C_GetTotalInventoryWeight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Output_Get != nullptr)
		*Output_Get = Parms.Output_Get;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetUniqueID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGuid                            UID                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::GetUniqueID(struct FGuid* UID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetUniqueID");

	Params::BP_JigMultiplayer_C_GetUniqueID Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (UID != nullptr)
		*UID = std::move(Parms.UID);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.GetVectorRot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        Vect                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector2D UBP_JigMultiplayer_C::GetVectorRot(const struct FVector2D& Vect, bool Rotated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "GetVectorRot");

	Params::BP_JigMultiplayer_C_GetVectorRot Parms{};

	Parms.Vect = std::move(Vect);
	Parms.Rotated = Rotated;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Handle Comp to Comp Move
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             From                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             To                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   VendorAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            VendorMoneyToUID                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   VendorMoneyToIndex                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::Handle_Comp_to_Comp_Move(class UBP_JigMultiplayer_C* From, class UBP_JigMultiplayer_C* To, const struct FGuid& ItemUID, bool FinalRotation, int32 ToIndex, const struct FGuid& ToContainer, int32 VendorAmount, const struct FGuid& VendorMoneyToUID, int32 VendorMoneyToIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Handle Comp to Comp Move");

	Params::BP_JigMultiplayer_C_Handle_Comp_to_Comp_Move Parms{};

	Parms.From = From;
	Parms.To = To;
	Parms.ItemUID = std::move(ItemUID);
	Parms.FinalRotation = FinalRotation;
	Parms.ToIndex = ToIndex;
	Parms.ToContainer = std::move(ToContainer);
	Parms.VendorAmount = VendorAmount;
	Parms.VendorMoneyToUID = std::move(VendorMoneyToUID);
	Parms.VendorMoneyToIndex = VendorMoneyToIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleActorEquipped
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            ItemAdded                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FContainerPickupsInfo>    ContainerContent                                       (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::HandleActorEquipped(class AActor* ActorRef, struct FContainerPickupsInfo& ItemAdded, const TArray<struct FContainerPickupsInfo>& ContainerContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleActorEquipped");

	Params::BP_JigMultiplayer_C_HandleActorEquipped Parms{};

	Parms.ActorRef = ActorRef;
	Parms.ItemAdded = std::move(ItemAdded);
	Parms.ContainerContent = std::move(ContainerContent);

	UObject::ProcessEvent(Func, &Parms);

	ItemAdded = std::move(Parms.ItemAdded);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleAddNewItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FContainerPickupsInfo            ItemInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FContainerPickupsInfo>    Content                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::HandleAddNewItem(struct FContainerPickupsInfo& ItemInfo, const TArray<struct FContainerPickupsInfo>& Content)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleAddNewItem");

	Params::BP_JigMultiplayer_C_HandleAddNewItem Parms{};

	Parms.ItemInfo = std::move(ItemInfo);
	Parms.Content = std::move(Content);

	UObject::ProcessEvent(Func, &Parms);

	ItemInfo = std::move(Parms.ItemInfo);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleClientMoveItemToIndex
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::HandleClientMoveItemToIndex(const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool FinalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleClientMoveItemToIndex");

	Params::BP_JigMultiplayer_C_HandleClientMoveItemToIndex Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.FinalRotation = FinalRotation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleCraftingTimers
// (BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::HandleCraftingTimers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleCraftingTimers");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleDropRequest
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDropItemBackGwidget_C*           DropWidget                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::HandleDropRequest(class UDropItemBackGwidget_C* DropWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleDropRequest");

	Params::BP_JigMultiplayer_C_HandleDropRequest Parms{};

	Parms.DropWidget = DropWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleItemOverItem
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::HandleItemOverItem(class UJSIContainer_C* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleItemOverItem");

	Params::BP_JigMultiplayer_C_HandleItemOverItem Parms{};

	Parms.Container = Container;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleLocalInternalReload
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            MagContainerUID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            AmmoToAdd                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MaxCap                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::HandleLocalInternalReload(const struct FGuid& MagContainerUID, const struct FGuid& AmmoToAdd, int32 MaxCap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleLocalInternalReload");

	Params::BP_JigMultiplayer_C_HandleLocalInternalReload Parms{};

	Parms.MagContainerUID = std::move(MagContainerUID);
	Parms.AmmoToAdd = std::move(AmmoToAdd);
	Parms.MaxCap = MaxCap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleLocalInternalReload_CustomCount
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            MagContainerUID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            AmmoToAdd                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MaxCap                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::HandleLocalInternalReload_CustomCount(const struct FGuid& MagContainerUID, const struct FGuid& AmmoToAdd, int32 MaxCap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleLocalInternalReload_CustomCount");

	Params::BP_JigMultiplayer_C_HandleLocalInternalReload_CustomCount Parms{};

	Parms.MagContainerUID = std::move(MagContainerUID);
	Parms.AmmoToAdd = std::move(AmmoToAdd);
	Parms.MaxCap = MaxCap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleLocalRequestConsumeItem
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             LocalComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class FString                           CustomData                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    CallbackToPlayer_                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::HandleLocalRequestConsumeItem(const struct FGuid& ItemUID, int32 Amount, class UBP_JigMultiplayer_C* LocalComp, const class FString& CustomData, bool CallbackToPlayer_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleLocalRequestConsumeItem");

	Params::BP_JigMultiplayer_C_HandleLocalRequestConsumeItem Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.Amount = Amount;
	Parms.LocalComp = LocalComp;
	Parms.CustomData = std::move(CustomData);
	Parms.CallbackToPlayer_ = CallbackToPlayer_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleLocalRequestReloadWeapon
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UnloadUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UnloadToContainerUID                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRot                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ReloadUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ReloadToContainerUID                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           WeaponRef                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::HandleLocalRequestReloadWeapon(const struct FGuid& UnloadUID, const struct FGuid& UnloadToContainerUID, int32 ToIndex, bool FinalRot, const struct FGuid& ReloadUID, const struct FGuid& ReloadToContainerUID, class AActor* WeaponRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleLocalRequestReloadWeapon");

	Params::BP_JigMultiplayer_C_HandleLocalRequestReloadWeapon Parms{};

	Parms.UnloadUID = std::move(UnloadUID);
	Parms.UnloadToContainerUID = std::move(UnloadToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.FinalRot = FinalRot;
	Parms.ReloadUID = std::move(ReloadUID);
	Parms.ReloadToContainerUID = std::move(ReloadToContainerUID);
	Parms.WeaponRef = WeaponRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleMainPlayerRequestedData
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::HandleMainPlayerRequestedData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleMainPlayerRequestedData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleMouseButtonDown
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::HandleMouseButtonDown(class UJSIContainer_C* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleMouseButtonDown");

	Params::BP_JigMultiplayer_C_HandleMouseButtonDown Parms{};

	Parms.Container = Container;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleNewItemAdded
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRepItemInfo                     ItemInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_SubContainerInfo>      SubContainers                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::HandleNewItemAdded(const struct FRepItemInfo& ItemInfo, const struct FGuid& UID, const struct FGuid& ToContainerUID, int32 ToIndex, bool FinalRotation, TArray<struct FS_SubContainerInfo>& SubContainers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleNewItemAdded");

	Params::BP_JigMultiplayer_C_HandleNewItemAdded Parms{};

	Parms.ItemInfo = std::move(ItemInfo);
	Parms.UID = std::move(UID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.FinalRotation = FinalRotation;
	Parms.SubContainers = std::move(SubContainers);

	UObject::ProcessEvent(Func, &Parms);

	SubContainers = std::move(Parms.SubContainers);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleSameCompSplitResult
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            SourceUID                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SourceNewCount                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRepItemInfo                     NewItem                                                (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FGuid                            NewItemUID                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::HandleSameCompSplitResult(const struct FGuid& SourceUID, int32 SourceNewCount, const struct FRepItemInfo& NewItem, const struct FGuid& NewItemUID, const struct FGuid& ToContainerUID, int32 ToSlot, bool Rotated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleSameCompSplitResult");

	Params::BP_JigMultiplayer_C_HandleSameCompSplitResult Parms{};

	Parms.SourceUID = std::move(SourceUID);
	Parms.SourceNewCount = SourceNewCount;
	Parms.NewItem = std::move(NewItem);
	Parms.NewItemUID = std::move(NewItemUID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToSlot = ToSlot;
	Parms.Rotated = Rotated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleSameContainerMoveToIndex
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             LocalComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   InContainerIndex                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::HandleSameContainerMoveToIndex(const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool Rotated_, class UBP_JigMultiplayer_C* LocalComp, int32 InContainerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleSameContainerMoveToIndex");

	Params::BP_JigMultiplayer_C_HandleSameContainerMoveToIndex Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.Rotated_ = Rotated_;
	Parms.LocalComp = LocalComp;
	Parms.InContainerIndex = InContainerIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleServerDropRequest
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             LocalComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::HandleServerDropRequest(const struct FGuid& ItemUID, int32 Count, class UBP_JigMultiplayer_C* LocalComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleServerDropRequest");

	Params::BP_JigMultiplayer_C_HandleServerDropRequest Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.Count = Count;
	Parms.LocalComp = LocalComp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleServerFuncRequestCraft
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             CompRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   CraftIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    ConsumeUIDs                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FGuid                            AddToContainer                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            TempUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            StackWith                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::HandleServerFuncRequestCraft(class UBP_JigMultiplayer_C* CompRef, int32 CraftIndex, TArray<struct FGuid>& ConsumeUIDs, const struct FGuid& AddToContainer, int32 ToIndex, bool FinalRotation, const struct FGuid& TempUID, const struct FGuid& StackWith)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleServerFuncRequestCraft");

	Params::BP_JigMultiplayer_C_HandleServerFuncRequestCraft Parms{};

	Parms.CompRef = CompRef;
	Parms.CraftIndex = CraftIndex;
	Parms.ConsumeUIDs = std::move(ConsumeUIDs);
	Parms.AddToContainer = std::move(AddToContainer);
	Parms.ToIndex = ToIndex;
	Parms.FinalRotation = FinalRotation;
	Parms.TempUID = std::move(TempUID);
	Parms.StackWith = std::move(StackWith);

	UObject::ProcessEvent(Func, &Parms);

	ConsumeUIDs = std::move(Parms.ConsumeUIDs);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleServerFuncRequestCraftDrop
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             CompRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   CraftIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    ConsumeUIDs                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::HandleServerFuncRequestCraftDrop(class UBP_JigMultiplayer_C* CompRef, int32 CraftIndex, TArray<struct FGuid>& ConsumeUIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleServerFuncRequestCraftDrop");

	Params::BP_JigMultiplayer_C_HandleServerFuncRequestCraftDrop Parms{};

	Parms.CompRef = CompRef;
	Parms.CraftIndex = CraftIndex;
	Parms.ConsumeUIDs = std::move(ConsumeUIDs);

	UObject::ProcessEvent(Func, &Parms);

	ConsumeUIDs = std::move(Parms.ConsumeUIDs);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HandleTwoContainerSwap
// (Private, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            SecondContainerUID                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::HandleTwoContainerSwap(const struct FGuid& ContainerUID, const struct FGuid& SecondContainerUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HandleTwoContainerSwap");

	Params::BP_JigMultiplayer_C_HandleTwoContainerSwap Parms{};

	Parms.ContainerUID = std::move(ContainerUID);
	Parms.SecondContainerUID = std::move(SecondContainerUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.HasValidWidgetClass?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::HasValidWidgetClass_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "HasValidWidgetClass?");

	Params::BP_JigMultiplayer_C_HasValidWidgetClass_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.InitializeJigComponent
// (BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::InitializeJigComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "InitializeJigComponent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.InitialzieInventoryWeight
// (Private, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::InitialzieInventoryWeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "InitialzieInventoryWeight");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.InitInventoryData
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::InitInventoryData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "InitInventoryData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.InitNoStartingItems
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::InitNoStartingItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "InitNoStartingItems");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.IsCraftingStation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::IsCraftingStation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "IsCraftingStation");

	Params::BP_JigMultiplayer_C_IsCraftingStation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.IsEmpty?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::IsEmpty_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "IsEmpty?");

	Params::BP_JigMultiplayer_C_IsEmpty_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.IsInventoryVisible?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::IsInventoryVisible_(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "IsInventoryVisible?");

	Params::BP_JigMultiplayer_C_IsInventoryVisible_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.IsLocal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::IsLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "IsLocal");

	Params::BP_JigMultiplayer_C_IsLocal Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.IsLocalPlayer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::IsLocalPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "IsLocalPlayer");

	Params::BP_JigMultiplayer_C_IsLocalPlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.IsLootContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::IsLootContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "IsLootContainer");

	Params::BP_JigMultiplayer_C_IsLootContainer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.IsMainCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::IsMainCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "IsMainCharacter");

	Params::BP_JigMultiplayer_C_IsMainCharacter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.IsPickupComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::IsPickupComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "IsPickupComponent");

	Params::BP_JigMultiplayer_C_IsPickupComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.IsSCSupportedItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UBP_MainSpecialContainer_C*       Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::IsSCSupportedItem(class UBP_MainSpecialContainer_C* Container, class UJigsawItem_DataAsset_C* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "IsSCSupportedItem");

	Params::BP_JigMultiplayer_C_IsSCSupportedItem Parms{};

	Parms.Container = Container;
	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.IsSupportedItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJigsawItem_DataAsset_C*          Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::IsSupportedItem(class UJigsawItem_DataAsset_C* Container, class UJigsawItem_DataAsset_C* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "IsSupportedItem");

	Params::BP_JigMultiplayer_C_IsSupportedItem Parms{};

	Parms.Container = Container;
	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.IsValidPickup
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            PickupInfo_0                                           (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::IsValidPickup(struct FContainerPickupsInfo* PickupInfo_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "IsValidPickup");

	Params::BP_JigMultiplayer_C_IsValidPickup Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PickupInfo_0 != nullptr)
		*PickupInfo_0 = std::move(Parms.PickupInfo_0);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.IsVendor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::IsVendor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "IsVendor");

	Params::BP_JigMultiplayer_C_IsVendor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ItemDropRequest_Event_0
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ItemDropRequest_Event_0(class UJSI_Slot_C* ItemRef, int32 Count, class UJSIContainer_C* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ItemDropRequest_Event_0");

	Params::BP_JigMultiplayer_C_ItemDropRequest_Event_0 Parms{};

	Parms.ItemRef = ItemRef;
	Parms.Count = Count;
	Parms.Container = Container;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Jig_UnhandledEvent
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      DroppedItem                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::Jig_UnhandledEvent(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, int32 ToIndex, class UJSI_Slot_C* DroppedItem, bool Rotated, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Jig_UnhandledEvent");

	Params::BP_JigMultiplayer_C_Jig_UnhandledEvent Parms{};

	Parms.FromContainer = FromContainer;
	Parms.ToContainer = ToContainer;
	Parms.ToIndex = ToIndex;
	Parms.DroppedItem = DroppedItem;
	Parms.Rotated = Rotated;
	Parms.Amount = Amount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigCom_GetType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Type                                                   (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigCom_GetType(struct FGameplayTag* Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigCom_GetType");

	Params::BP_JigMultiplayer_C_JigCom_GetType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Type != nullptr)
		*Type = std::move(Parms.Type);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigCom_IsLootContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigCom_IsLootContainer(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigCom_IsLootContainer");

	Params::BP_JigMultiplayer_C_JigCom_IsLootContainer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigCom_IsMainCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigCom_IsMainCharacter(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigCom_IsMainCharacter");

	Params::BP_JigMultiplayer_C_JigCom_IsMainCharacter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigCom_IsPickup
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigCom_IsPickup(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigCom_IsPickup");

	Params::BP_JigMultiplayer_C_JigCom_IsPickup Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigCom_IsVendor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigCom_IsVendor(bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigCom_IsVendor");

	Params::BP_JigMultiplayer_C_JigCom_IsVendor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigComp_AddNewPendingRequest
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      NewItem                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigComp_AddNewPendingRequest(class UJSI_Slot_C* NewItem, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigComp_AddNewPendingRequest");

	Params::BP_JigMultiplayer_C_JigComp_AddNewPendingRequest Parms{};

	Parms.NewItem = NewItem;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigComp_CallRequestChamberUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ChamberContainerUID                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigComp_CallRequestChamberUID(const struct FGuid& ChamberContainerUID, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigComp_CallRequestChamberUID");

	Params::BP_JigMultiplayer_C_JigComp_CallRequestChamberUID Parms{};

	Parms.ChamberContainerUID = std::move(ChamberContainerUID);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigComp_CallRequestReload
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UnloadUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UnloadToContainerUID                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRot                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ReloadUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ReloadToContainerUID                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           WeaponRef                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigComp_CallRequestReload(const struct FGuid& UnloadUID, const struct FGuid& UnloadToContainerUID, int32 ToIndex, bool FinalRot, const struct FGuid& ReloadUID, const struct FGuid& ReloadToContainerUID, class AActor* WeaponRef, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigComp_CallRequestReload");

	Params::BP_JigMultiplayer_C_JigComp_CallRequestReload Parms{};

	Parms.UnloadUID = std::move(UnloadUID);
	Parms.UnloadToContainerUID = std::move(UnloadToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.FinalRot = FinalRot;
	Parms.ReloadUID = std::move(ReloadUID);
	Parms.ReloadToContainerUID = std::move(ReloadToContainerUID);
	Parms.WeaponRef = WeaponRef;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigComp_CallRequestReloadInternal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            MagContainerUID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            AmmoToAdd                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MaxCap                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigComp_CallRequestReloadInternal(const struct FGuid& MagContainerUID, const struct FGuid& AmmoToAdd, int32 MaxCap, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigComp_CallRequestReloadInternal");

	Params::BP_JigMultiplayer_C_JigComp_CallRequestReloadInternal Parms{};

	Parms.MagContainerUID = std::move(MagContainerUID);
	Parms.AmmoToAdd = std::move(AmmoToAdd);
	Parms.MaxCap = MaxCap;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigComp_CallServerChamberWeapon
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ChamberContainerUID                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            MagContainerUID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            BulletToChamberUID                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ChamberContainerIndex                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    SendChamberUID_                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigComp_CallServerChamberWeapon(const struct FGuid& ChamberContainerUID, const struct FGuid& MagContainerUID, const struct FGuid& BulletToChamberUID, int32 ChamberContainerIndex, bool SendChamberUID_, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigComp_CallServerChamberWeapon");

	Params::BP_JigMultiplayer_C_JigComp_CallServerChamberWeapon Parms{};

	Parms.ChamberContainerUID = std::move(ChamberContainerUID);
	Parms.MagContainerUID = std::move(MagContainerUID);
	Parms.BulletToChamberUID = std::move(BulletToChamberUID);
	Parms.ChamberContainerIndex = ChamberContainerIndex;
	Parms.SendChamberUID_ = SendChamberUID_;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigComp_CallServerConsumeRequest
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UActorComponent*                  TargetComp                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           CustomData                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigComp_CallServerConsumeRequest(class UActorComponent* TargetComp, const struct FGuid& ItemUID, int32 Amount, const class FString& CustomData, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigComp_CallServerConsumeRequest");

	Params::BP_JigMultiplayer_C_JigComp_CallServerConsumeRequest Parms{};

	Parms.TargetComp = TargetComp;
	Parms.ItemUID = std::move(ItemUID);
	Parms.Amount = Amount;
	Parms.CustomData = std::move(CustomData);

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigComp_ContextTryEquip
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  RootContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigComp_ContextTryEquip(class UJSI_Slot_C* Item, class UJSIContainer_C* RootContainer, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigComp_ContextTryEquip");

	Params::BP_JigMultiplayer_C_JigComp_ContextTryEquip Parms{};

	Parms.Item = Item;
	Parms.RootContainer = RootContainer;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigComp_ContextTryUnequip
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  RootContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigComp_ContextTryUnequip(class UJSI_Slot_C* Item, class UJSIContainer_C* RootContainer, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigComp_ContextTryUnequip");

	Params::BP_JigMultiplayer_C_JigComp_ContextTryUnequip Parms{};

	Parms.Item = Item;
	Parms.RootContainer = RootContainer;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigComp_ContextTryUnloadAmmo
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  RootContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigComp_ContextTryUnloadAmmo(class UJSI_Slot_C* Item, class UJSIContainer_C* RootContainer, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigComp_ContextTryUnloadAmmo");

	Params::BP_JigMultiplayer_C_JigComp_ContextTryUnloadAmmo Parms{};

	Parms.Item = Item;
	Parms.RootContainer = RootContainer;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigComp_GetInventoryWidgetRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      UserWidget                                             (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigComp_GetInventoryWidgetRef(class UUserWidget** UserWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigComp_GetInventoryWidgetRef");

	Params::BP_JigMultiplayer_C_JigComp_GetInventoryWidgetRef Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (UserWidget != nullptr)
		*UserWidget = Parms.UserWidget;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigTryAddGetPendingRef
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRepItemInfo                     Info                                                   (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool                                    CheckStacking                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      OutputPin                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Stack_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigTryAddGetPendingRef(const struct FRepItemInfo& Info, bool CheckStacking, class UJSI_Slot_C** OutputPin, bool* Stack_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigTryAddGetPendingRef");

	Params::BP_JigMultiplayer_C_JigTryAddGetPendingRef Parms{};

	Parms.Info = std::move(Info);
	Parms.CheckStacking = CheckStacking;

	UObject::ProcessEvent(Func, &Parms);

	if (OutputPin != nullptr)
		*OutputPin = Parms.OutputPin;

	if (Stack_ != nullptr)
		*Stack_ = Parms.Stack_;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JigTryAddItemSomewhere
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             LocalComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Added_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UID                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JigTryAddItemSomewhere(class UBP_JigMultiplayer_C* LocalComp, class UJigsawItem_DataAsset_C* ItemId, int32 Count, bool* Added_, struct FGuid* UID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JigTryAddItemSomewhere");

	Params::BP_JigMultiplayer_C_JigTryAddItemSomewhere Parms{};

	Parms.LocalComp = LocalComp;
	Parms.ItemId = ItemId;
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);

	if (Added_ != nullptr)
		*Added_ = Parms.Added_;

	if (UID != nullptr)
		*UID = std::move(Parms.UID);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JSI_CheckIfCanAddActorToContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    TestOnly_                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToSpecificContainer                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            AddtoUID                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            TempItemUID                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      JigItemRef                                             (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JSI_CheckIfCanAddActorToContainer(class AActor* ActorRef, bool TestOnly_, class UJSIContainer_C* ToSpecificContainer, int32 Index_0, bool Rotated, bool* Result, struct FGuid* AddtoUID, struct FGuid* TempItemUID, int32* ToIndex, bool* FinalRotation, class UJSI_Slot_C** JigItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JSI_CheckIfCanAddActorToContainer");

	Params::BP_JigMultiplayer_C_JSI_CheckIfCanAddActorToContainer Parms{};

	Parms.ActorRef = ActorRef;
	Parms.TestOnly_ = TestOnly_;
	Parms.ToSpecificContainer = ToSpecificContainer;
	Parms.Index_0 = Index_0;
	Parms.Rotated = Rotated;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (AddtoUID != nullptr)
		*AddtoUID = std::move(Parms.AddtoUID);

	if (TempItemUID != nullptr)
		*TempItemUID = std::move(Parms.TempItemUID);

	if (ToIndex != nullptr)
		*ToIndex = Parms.ToIndex;

	if (FinalRotation != nullptr)
		*FinalRotation = Parms.FinalRotation;

	if (JigItemRef != nullptr)
		*JigItemRef = Parms.JigItemRef;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JSI_CheckIfCanAddItemToContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  AddToContainer                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JSI_CheckIfCanAddItemToContainer(class UJSI_Slot_C* ItemRef, bool* Result, class UJSIContainer_C** AddToContainer, int32* ToIndex, bool* FinalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JSI_CheckIfCanAddItemToContainer");

	Params::BP_JigMultiplayer_C_JSI_CheckIfCanAddItemToContainer Parms{};

	Parms.ItemRef = ItemRef;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (AddToContainer != nullptr)
		*AddToContainer = Parms.AddToContainer;

	if (ToIndex != nullptr)
		*ToIndex = Parms.ToIndex;

	if (FinalRotation != nullptr)
		*FinalRotation = Parms.FinalRotation;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JSI_CheckIfCanAddStackItemToContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      WithItem                                               (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JSI_CheckIfCanAddStackItemToContainer(class UJSI_Slot_C* ItemRef, bool* Result, class UJSI_Slot_C** WithItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JSI_CheckIfCanAddStackItemToContainer");

	Params::BP_JigMultiplayer_C_JSI_CheckIfCanAddStackItemToContainer Parms{};

	Parms.ItemRef = ItemRef;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (WithItem != nullptr)
		*WithItem = Parms.WithItem;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JSI_CheckIfEnoughSpaceToPickupActor
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JSI_CheckIfEnoughSpaceToPickupActor(class AActor* ActorRef, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JSI_CheckIfEnoughSpaceToPickupActor");

	Params::BP_JigMultiplayer_C_JSI_CheckIfEnoughSpaceToPickupActor Parms{};

	Parms.ActorRef = ActorRef;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JSI_TryEquipToMain
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           PickupRef                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  TargetContainer                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    OnlyTest_                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  EquipTo                                                (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JSI_TryEquipToMain(class AActor* PickupRef, class UJSIContainer_C* TargetContainer, bool OnlyTest_, class UJSIContainer_C** EquipTo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JSI_TryEquipToMain");

	Params::BP_JigMultiplayer_C_JSI_TryEquipToMain Parms{};

	Parms.PickupRef = PickupRef;
	Parms.TargetContainer = TargetContainer;
	Parms.OnlyTest_ = OnlyTest_;

	UObject::ProcessEvent(Func, &Parms);

	if (EquipTo != nullptr)
		*EquipTo = Parms.EquipTo;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.JSIFindEmptySpot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::JSIFindEmptySpot(class UJSIContainer_C* Container, class UJSI_Slot_C* Item, bool* Found, int32* Index_0, bool* FinalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "JSIFindEmptySpot");

	Params::BP_JigMultiplayer_C_JSIFindEmptySpot Parms{};

	Parms.Container = Container;
	Parms.Item = Item;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;

	if (FinalRotation != nullptr)
		*FinalRotation = Parms.FinalRotation;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.LoadJigComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    ActionbarUIDs                                          (Parm, OutParm)

bool UBP_JigMultiplayer_C::LoadJigComponent(TArray<struct FGuid>* ActionbarUIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "LoadJigComponent");

	Params::BP_JigMultiplayer_C_LoadJigComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ActionbarUIDs != nullptr)
		*ActionbarUIDs = std::move(Parms.ActionbarUIDs);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.LogData
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::LogData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "LogData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.MainDeepSearchContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  Array_Element                                          (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::MainDeepSearchContainer(const struct FGuid& UID, class UJSIContainer_C** Array_Element)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "MainDeepSearchContainer");

	Params::BP_JigMultiplayer_C_MainDeepSearchContainer Parms{};

	Parms.UID = std::move(UID);

	UObject::ProcessEvent(Func, &Parms);

	if (Array_Element != nullptr)
		*Array_Element = Parms.Array_Element;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.MC_AddNewItem
// (Net, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FContainerPickupsInfo            ItemInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FContainerPickupsInfo>    Content                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::MC_AddNewItem(const struct FContainerPickupsInfo& ItemInfo, const TArray<struct FContainerPickupsInfo>& Content)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "MC_AddNewItem");

	Params::BP_JigMultiplayer_C_MC_AddNewItem Parms{};

	Parms.ItemInfo = std::move(ItemInfo);
	Parms.Content = std::move(Content);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.MC_ItemRemoved
// (Net, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::MC_ItemRemoved(const struct FGuid& ItemUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "MC_ItemRemoved");

	Params::BP_JigMultiplayer_C_MC_ItemRemoved Parms{};

	Parms.ItemUID = std::move(ItemUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.MC_MoveItemToIndex
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             TargetComp                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::MC_MoveItemToIndex(class UBP_JigMultiplayer_C* TargetComp, const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool FinalRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "MC_MoveItemToIndex");

	Params::BP_JigMultiplayer_C_MC_MoveItemToIndex Parms{};

	Parms.TargetComp = TargetComp;
	Parms.ItemUID = std::move(ItemUID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.FinalRotation = FinalRotation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.MC_NewItemAdded
// (Net, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRepItemInfo                     ItemInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_UpdateCount                   UpdateCount                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_SubContainerInfo>      SubContainers                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::MC_NewItemAdded(const struct FRepItemInfo& ItemInfo, const struct FGuid& UID, const struct FGuid& ToContainerUID, int32 ToIndex, bool FinalRotation, const struct FS_UpdateCount& UpdateCount, TArray<struct FS_SubContainerInfo>& SubContainers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "MC_NewItemAdded");

	Params::BP_JigMultiplayer_C_MC_NewItemAdded Parms{};

	Parms.ItemInfo = std::move(ItemInfo);
	Parms.UID = std::move(UID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.FinalRotation = FinalRotation;
	Parms.UpdateCount = std::move(UpdateCount);
	Parms.SubContainers = std::move(SubContainers);

	UObject::ProcessEvent(Func, &Parms);

	SubContainers = std::move(Parms.SubContainers);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.MC_OnPendingDone
// (Net, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FContainerPickupsInfo>    Item                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::MC_OnPendingDone(const TArray<struct FContainerPickupsInfo>& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "MC_OnPendingDone");

	Params::BP_JigMultiplayer_C_MC_OnPendingDone Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.MC_SameCompUpdateSplitRequest
// (Net, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            SourceUID                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SourceNewCount                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRepItemInfo                     NewItem                                                (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FGuid                            NewItemUID                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::MC_SameCompUpdateSplitRequest(const struct FGuid& SourceUID, int32 SourceNewCount, const struct FRepItemInfo& NewItem, const struct FGuid& NewItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool Rotated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "MC_SameCompUpdateSplitRequest");

	Params::BP_JigMultiplayer_C_MC_SameCompUpdateSplitRequest Parms{};

	Parms.SourceUID = std::move(SourceUID);
	Parms.SourceNewCount = SourceNewCount;
	Parms.NewItem = std::move(NewItem);
	Parms.NewItemUID = std::move(NewItemUID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.Rotated = Rotated;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.MC_UpdateCount
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            RemovePending                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::MC_UpdateCount(const struct FGuid& ItemUID, int32 NewCount, const struct FGuid& RemovePending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "MC_UpdateCount");

	Params::BP_JigMultiplayer_C_MC_UpdateCount Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.NewCount = NewCount;
	Parms.RemovePending = std::move(RemovePending);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.MC_UpdateCounts
// (Net, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_UpdateCount>           Counts                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::MC_UpdateCounts(const TArray<struct FS_UpdateCount>& Counts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "MC_UpdateCounts");

	Params::BP_JigMultiplayer_C_MC_UpdateCounts Parms{};

	Parms.Counts = std::move(Counts);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.MC_UpdateDurability
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        NewDurab                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::MC_UpdateDurability(const struct FGuid& ItemUID, const struct FVector2D& NewDurab)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "MC_UpdateDurability");

	Params::BP_JigMultiplayer_C_MC_UpdateDurability Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.NewDurab = std::move(NewDurab);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.MC_UpdateStack
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            DroppedUID                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   DropNewCount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            RecUID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   RecNewCount                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::MC_UpdateStack(const struct FGuid& DroppedUID, int32 DropNewCount, const struct FGuid& RecUID, int32 RecNewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "MC_UpdateStack");

	Params::BP_JigMultiplayer_C_MC_UpdateStack Parms{};

	Parms.DroppedUID = std::move(DroppedUID);
	Parms.DropNewCount = DropNewCount;
	Parms.RecUID = std::move(RecUID);
	Parms.RecNewCount = RecNewCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.MonitorContainerItems
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::MonitorContainerItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "MonitorContainerItems");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.OnItemAddedUpdateWeight
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FContainerPickupsInfo            Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FS_ReplicatedContainerInfo>Content                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FGuid                            OverrideInUID                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   OverrideCount                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::OnItemAddedUpdateWeight(struct FContainerPickupsInfo& Item, TArray<struct FS_ReplicatedContainerInfo>& Content, const struct FGuid& OverrideInUID, int32 OverrideCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "OnItemAddedUpdateWeight");

	Params::BP_JigMultiplayer_C_OnItemAddedUpdateWeight Parms{};

	Parms.Item = std::move(Item);
	Parms.Content = std::move(Content);
	Parms.OverrideInUID = std::move(OverrideInUID);
	Parms.OverrideCount = OverrideCount;

	UObject::ProcessEvent(Func, &Parms);

	Item = std::move(Parms.Item);
	Content = std::move(Parms.Content);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.OnItemRemovedUpdateWeight
// (Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FContainerPickupsInfo            Item                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FS_ReplicatedContainerInfo>Content                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// int32                                   OverrideCount                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::OnItemRemovedUpdateWeight(struct FContainerPickupsInfo& Item, TArray<struct FS_ReplicatedContainerInfo>& Content, int32 OverrideCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "OnItemRemovedUpdateWeight");

	Params::BP_JigMultiplayer_C_OnItemRemovedUpdateWeight Parms{};

	Parms.Item = std::move(Item);
	Parms.Content = std::move(Content);
	Parms.OverrideCount = OverrideCount;

	UObject::ProcessEvent(Func, &Parms);

	Item = std::move(Parms.Item);
	Content = std::move(Parms.Content);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.OnItemSplitRequest_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemSource                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlotIndex                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   TotalAmount                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SplitAmount                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::OnItemSplitRequest_Event(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* ItemSource, int32 ToSlotIndex, int32 TotalAmount, int32 SplitAmount, bool Rotated_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "OnItemSplitRequest_Event");

	Params::BP_JigMultiplayer_C_OnItemSplitRequest_Event Parms{};

	Parms.FromContainer = FromContainer;
	Parms.ToContainer = ToContainer;
	Parms.ItemSource = ItemSource;
	Parms.ToSlotIndex = ToSlotIndex;
	Parms.TotalAmount = TotalAmount;
	Parms.SplitAmount = SplitAmount;
	Parms.Rotated_ = Rotated_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.OnItemStackRequest_Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      DroppedItem                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ReceiverItem                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::OnItemStackRequest_Event(class UJSI_Slot_C* DroppedItem, class UJSI_Slot_C* ReceiverItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "OnItemStackRequest_Event");

	Params::BP_JigMultiplayer_C_OnItemStackRequest_Event Parms{};

	Parms.DroppedItem = DroppedItem;
	Parms.ReceiverItem = ReceiverItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.OnRep_MainContainersIDs
// (BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::OnRep_MainContainersIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "OnRep_MainContainersIDs");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Process Main Jig Containers
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Name_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    IsEquipTo                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NumOfColumns                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NumOfRows                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FRandomContainerItem>     DefaultContainerItems                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FGuid                            ContUID                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::Process_Main_Jig_Containers(class FName Name_0, bool IsEquipTo, int32 NumOfColumns, int32 NumOfRows, TArray<struct FRandomContainerItem>& DefaultContainerItems, struct FGuid* ContUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Process Main Jig Containers");

	Params::BP_JigMultiplayer_C_Process_Main_Jig_Containers Parms{};

	Parms.Name_0 = Name_0;
	Parms.IsEquipTo = IsEquipTo;
	Parms.NumOfColumns = NumOfColumns;
	Parms.NumOfRows = NumOfRows;
	Parms.DefaultContainerItems = std::move(DefaultContainerItems);

	UObject::ProcessEvent(Func, &Parms);

	DefaultContainerItems = std::move(Parms.DefaultContainerItems);

	if (ContUID != nullptr)
		*ContUID = std::move(Parms.ContUID);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Process Multiple
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FVector2D>                ContainerColRow                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FGuid>                    ContainerUIDs                                          (Parm, OutParm)

void UBP_JigMultiplayer_C::Process_Multiple(TArray<struct FVector2D>& ContainerColRow, TArray<struct FGuid>* ContainerUIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Process Multiple");

	Params::BP_JigMultiplayer_C_Process_Multiple Parms{};

	Parms.ContainerColRow = std::move(ContainerColRow);

	UObject::ProcessEvent(Func, &Parms);

	ContainerColRow = std::move(Parms.ContainerColRow);

	if (ContainerUIDs != nullptr)
		*ContainerUIDs = std::move(Parms.ContainerUIDs);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ProcessRefillContainer
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::ProcessRefillContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ProcessRefillContainer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UBP_JigMultiplayer_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.RefFillCapacityContainer
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          WithItem                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::RefFillCapacityContainer(const struct FGuid& UID, class UJigsawItem_DataAsset_C* WithItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "RefFillCapacityContainer");

	Params::BP_JigMultiplayer_C_RefFillCapacityContainer Parms{};

	Parms.UID = std::move(UID);
	Parms.WithItem = WithItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.RemoveGetInfo
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   RemoveCount                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            ItemInfo                                               (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FS_ReplicatedContainerInfo>RepContainers                                          (Parm, OutParm, ContainsInstancedReference)
// int32                                   VendorNewCount                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CountRemoved_                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::RemoveGetInfo(const struct FGuid& UID, int32 RemoveCount, struct FContainerPickupsInfo* ItemInfo, TArray<struct FS_ReplicatedContainerInfo>* RepContainers, int32* VendorNewCount, bool* CountRemoved_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "RemoveGetInfo");

	Params::BP_JigMultiplayer_C_RemoveGetInfo Parms{};

	Parms.UID = std::move(UID);
	Parms.RemoveCount = RemoveCount;

	UObject::ProcessEvent(Func, &Parms);

	if (ItemInfo != nullptr)
		*ItemInfo = std::move(Parms.ItemInfo);

	if (RepContainers != nullptr)
		*RepContainers = std::move(Parms.RepContainers);

	if (VendorNewCount != nullptr)
		*VendorNewCount = Parms.VendorNewCount;

	if (CountRemoved_ != nullptr)
		*CountRemoved_ = Parms.CountRemoved_;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.RemoveRequestByUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Removed                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::RemoveRequestByUID(const struct FGuid& UID, bool* Removed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "RemoveRequestByUID");

	Params::BP_JigMultiplayer_C_RemoveRequestByUID Parms{};

	Parms.UID = std::move(UID);

	UObject::ProcessEvent(Func, &Parms);

	if (Removed != nullptr)
		*Removed = Parms.Removed;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ReplaceLoadJigComponentByIndex
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           SaveName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// int32                                   UserIndex                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ReplaceContainerIndex                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    ActionbarUIDs                                          (Parm, OutParm)

bool UBP_JigMultiplayer_C::ReplaceLoadJigComponentByIndex(const class FString& SaveName, const int32 UserIndex, int32 ReplaceContainerIndex, TArray<struct FGuid>* ActionbarUIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ReplaceLoadJigComponentByIndex");

	Params::BP_JigMultiplayer_C_ReplaceLoadJigComponentByIndex Parms{};

	Parms.SaveName = std::move(SaveName);
	Parms.UserIndex = UserIndex;
	Parms.ReplaceContainerIndex = ReplaceContainerIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (ActionbarUIDs != nullptr)
		*ActionbarUIDs = std::move(Parms.ActionbarUIDs);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ResetInitComponent
// (BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::ResetInitComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ResetInitComponent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.Save One Jig ContainerByIndex
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           SaveName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// int32                                   UserIndex                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ContainerIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::Save_One_Jig_ContainerByIndex(const class FString& SaveName, const int32 UserIndex, int32 ContainerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "Save One Jig ContainerByIndex");

	Params::BP_JigMultiplayer_C_Save_One_Jig_ContainerByIndex Parms{};

	Parms.SaveName = std::move(SaveName);
	Parms.UserIndex = UserIndex;
	Parms.ContainerIndex = ContainerIndex;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SaveJigComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FGuid>                    ActionbarUIDs                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::SaveJigComponent(TArray<struct FGuid>& ActionbarUIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SaveJigComponent");

	Params::BP_JigMultiplayer_C_SaveJigComponent Parms{};

	Parms.ActionbarUIDs = std::move(ActionbarUIDs);

	UObject::ProcessEvent(Func, &Parms);

	ActionbarUIDs = std::move(Parms.ActionbarUIDs);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SaveMultipleJigContainersByIndexes
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           SaveName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// int32                                   UserIndex                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<int32>                           ContainerIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::SaveMultipleJigContainersByIndexes(const class FString& SaveName, const int32 UserIndex, TArray<int32>& ContainerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SaveMultipleJigContainersByIndexes");

	Params::BP_JigMultiplayer_C_SaveMultipleJigContainersByIndexes Parms{};

	Parms.SaveName = std::move(SaveName);
	Parms.UserIndex = UserIndex;
	Parms.ContainerIndex = std::move(ContainerIndex);

	UObject::ProcessEvent(Func, &Parms);

	ContainerIndex = std::move(Parms.ContainerIndex);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_FireArmChamberWeapon
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ChamberContainerUID                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            MagContainerUID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            BulletToChamberUID                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ChamberContainerIndex                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    SendChamberUID_                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_FireArmChamberWeapon(const struct FGuid& ChamberContainerUID, const struct FGuid& MagContainerUID, const struct FGuid& BulletToChamberUID, int32 ChamberContainerIndex, bool SendChamberUID_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_FireArmChamberWeapon");

	Params::BP_JigMultiplayer_C_SERVER_FireArmChamberWeapon Parms{};

	Parms.ChamberContainerUID = std::move(ChamberContainerUID);
	Parms.MagContainerUID = std::move(MagContainerUID);
	Parms.BulletToChamberUID = std::move(BulletToChamberUID);
	Parms.ChamberContainerIndex = ChamberContainerIndex;
	Parms.SendChamberUID_ = SendChamberUID_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_ForwardInteract
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     Option                                                 (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// struct FS_JigPayload                    Payload                                                (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_ForwardInteract(class AActor* Actor, const struct FGameplayTag& Option, const struct FS_JigPayload& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_ForwardInteract");

	Params::BP_JigMultiplayer_C_SERVER_ForwardInteract Parms{};

	Parms.Actor = Actor;
	Parms.Option = std::move(Option);
	Parms.Payload = std::move(Payload);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_LoadSaveDataFromClientSide
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FS_ReplicatedContainerInfo>MainJigContainers_0                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// TArray<struct FGuid>                    MainContainersIDs_0                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FS_InvWeight>             InventoryWeight_0                                      (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<struct FGuid>                    ActionbarUIDs                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::SERVER_LoadSaveDataFromClientSide(const TArray<struct FS_ReplicatedContainerInfo>& MainJigContainers_0, const TArray<struct FGuid>& MainContainersIDs_0, const TArray<struct FS_InvWeight>& InventoryWeight_0, const TArray<struct FGuid>& ActionbarUIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_LoadSaveDataFromClientSide");

	Params::BP_JigMultiplayer_C_SERVER_LoadSaveDataFromClientSide Parms{};

	Parms.MainJigContainers_0 = std::move(MainJigContainers_0);
	Parms.MainContainersIDs_0 = std::move(MainContainersIDs_0);
	Parms.InventoryWeight_0 = std::move(InventoryWeight_0);
	Parms.ActionbarUIDs = std::move(ActionbarUIDs);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestActorAddStackItem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            WithUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestActorAddStackItem(class AActor* ActorRef, const struct FGuid& WithUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestActorAddStackItem");

	Params::BP_JigMultiplayer_C_SERVER_RequestActorAddStackItem Parms{};

	Parms.ActorRef = ActorRef;
	Parms.WithUID = std::move(WithUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestAddActorToContainer
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            AddtoUID                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            TempUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    Stacks                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::SERVER_RequestAddActorToContainer(class AActor* ActorRef, const struct FGuid& AddtoUID, const struct FGuid& TempUID, int32 ToIndex, bool FinalRotation, const TArray<struct FGuid>& Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestAddActorToContainer");

	Params::BP_JigMultiplayer_C_SERVER_RequestAddActorToContainer Parms{};

	Parms.ActorRef = ActorRef;
	Parms.AddtoUID = std::move(AddtoUID);
	Parms.TempUID = std::move(TempUID);
	Parms.ToIndex = ToIndex;
	Parms.FinalRotation = FinalRotation;
	Parms.Stacks = std::move(Stacks);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestChamberUID
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ChamberContainerUID                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestChamberUID(const struct FGuid& ChamberContainerUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestChamberUID");

	Params::BP_JigMultiplayer_C_SERVER_RequestChamberUID Parms{};

	Parms.ChamberContainerUID = std::move(ChamberContainerUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestConsumeItem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             TargetComp                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           CustomData                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestConsumeItem(class UBP_JigMultiplayer_C* TargetComp, const struct FGuid& ItemUID, int32 Amount, const class FString& CustomData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestConsumeItem");

	Params::BP_JigMultiplayer_C_SERVER_RequestConsumeItem Parms{};

	Parms.TargetComp = TargetComp;
	Parms.ItemUID = std::move(ItemUID);
	Parms.Amount = Amount;
	Parms.CustomData = std::move(CustomData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestCraftItem
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             CompRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   CraftIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    ConsumeUIDs                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FGuid                            AddToContainer                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            TempUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            StackWith                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestCraftItem(class UBP_JigMultiplayer_C* CompRef, int32 CraftIndex, const TArray<struct FGuid>& ConsumeUIDs, const struct FGuid& AddToContainer, int32 ToIndex, bool FinalRotation, const struct FGuid& TempUID, const struct FGuid& StackWith)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestCraftItem");

	Params::BP_JigMultiplayer_C_SERVER_RequestCraftItem Parms{};

	Parms.CompRef = CompRef;
	Parms.CraftIndex = CraftIndex;
	Parms.ConsumeUIDs = std::move(ConsumeUIDs);
	Parms.AddToContainer = std::move(AddToContainer);
	Parms.ToIndex = ToIndex;
	Parms.FinalRotation = FinalRotation;
	Parms.TempUID = std::move(TempUID);
	Parms.StackWith = std::move(StackWith);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestCraftItemDrop
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             CompRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   CraftIndex                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    ConsumeUIDs                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::SERVER_RequestCraftItemDrop(class UBP_JigMultiplayer_C* CompRef, int32 CraftIndex, const TArray<struct FGuid>& ConsumeUIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestCraftItemDrop");

	Params::BP_JigMultiplayer_C_SERVER_RequestCraftItemDrop Parms{};

	Parms.CompRef = CompRef;
	Parms.CraftIndex = CraftIndex;
	Parms.ConsumeUIDs = std::move(ConsumeUIDs);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestData
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             JigMPCompRef                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestData(class UBP_JigMultiplayer_C* JigMPCompRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestData");

	Params::BP_JigMultiplayer_C_SERVER_RequestData Parms{};

	Parms.JigMPCompRef = JigMPCompRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestDataFromSave
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             JigMPCompRef                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestDataFromSave(class UBP_JigMultiplayer_C* JigMPCompRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestDataFromSave");

	Params::BP_JigMultiplayer_C_SERVER_RequestDataFromSave Parms{};

	Parms.JigMPCompRef = JigMPCompRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestDropItem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             CompTarget                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestDropItem(const struct FGuid& ItemUID, int32 Count, class UBP_JigMultiplayer_C* CompTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestDropItem");

	Params::BP_JigMultiplayer_C_SERVER_RequestDropItem Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.Count = Count;
	Parms.CompTarget = CompTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestEquipActorToContainer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToMainUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestEquipActorToContainer(class AActor* ActorRef, const struct FGuid& ToMainUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestEquipActorToContainer");

	Params::BP_JigMultiplayer_C_SERVER_RequestEquipActorToContainer Parms{};

	Parms.ActorRef = ActorRef;
	Parms.ToMainUID = std::move(ToMainUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestExpandContainer
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AddColumns                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AddRows                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestExpandContainer(const struct FGuid& ContainerUID, int32 AddColumns, int32 AddRows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestExpandContainer");

	Params::BP_JigMultiplayer_C_SERVER_RequestExpandContainer Parms{};

	Parms.ContainerUID = std::move(ContainerUID);
	Parms.AddColumns = AddColumns;
	Parms.AddRows = AddRows;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestLoadReplaceOneContainerByIndex
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           SaveName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// int32                                   UserIndex                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ReplaceContainerIndex                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestLoadReplaceOneContainerByIndex(const class FString& SaveName, const int32 UserIndex, int32 ReplaceContainerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestLoadReplaceOneContainerByIndex");

	Params::BP_JigMultiplayer_C_SERVER_RequestLoadReplaceOneContainerByIndex Parms{};

	Parms.SaveName = std::move(SaveName);
	Parms.UserIndex = UserIndex;
	Parms.ReplaceContainerIndex = ReplaceContainerIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestMoveItemToAnotherComp
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             From                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             To                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   VendorAmount                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            VendorMoneyToUID                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   VendorMoneyToIndex                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestMoveItemToAnotherComp(class UBP_JigMultiplayer_C* From, class UBP_JigMultiplayer_C* To, const struct FGuid& ItemUID, bool FinalRotation, int32 ToIndex, const struct FGuid& ToContainer, int32 VendorAmount, const struct FGuid& VendorMoneyToUID, int32 VendorMoneyToIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestMoveItemToAnotherComp");

	Params::BP_JigMultiplayer_C_SERVER_RequestMoveItemToAnotherComp Parms{};

	Parms.From = From;
	Parms.To = To;
	Parms.ItemUID = std::move(ItemUID);
	Parms.FinalRotation = FinalRotation;
	Parms.ToIndex = ToIndex;
	Parms.ToContainer = std::move(ToContainer);
	Parms.VendorAmount = VendorAmount;
	Parms.VendorMoneyToUID = std::move(VendorMoneyToUID);
	Parms.VendorMoneyToIndex = VendorMoneyToIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestReload
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UnloadUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UnloadToContainerUID                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRot                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ReloadUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ReloadToContainerUID                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           WeaponRef                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestReload(const struct FGuid& UnloadUID, const struct FGuid& UnloadToContainerUID, int32 ToIndex, bool FinalRot, const struct FGuid& ReloadUID, const struct FGuid& ReloadToContainerUID, class AActor* WeaponRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestReload");

	Params::BP_JigMultiplayer_C_SERVER_RequestReload Parms{};

	Parms.UnloadUID = std::move(UnloadUID);
	Parms.UnloadToContainerUID = std::move(UnloadToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.FinalRot = FinalRot;
	Parms.ReloadUID = std::move(ReloadUID);
	Parms.ReloadToContainerUID = std::move(ReloadToContainerUID);
	Parms.WeaponRef = WeaponRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestReloadInternal
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            MagContainerUID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            AmmoToAdd                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MaxCap                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestReloadInternal(const struct FGuid& MagContainerUID, const struct FGuid& AmmoToAdd, int32 MaxCap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestReloadInternal");

	Params::BP_JigMultiplayer_C_SERVER_RequestReloadInternal Parms{};

	Parms.MagContainerUID = std::move(MagContainerUID);
	Parms.AmmoToAdd = std::move(AmmoToAdd);
	Parms.MaxCap = MaxCap;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestRemoveItem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             TargetComp                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Amount                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CallbackToPlayer_                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestRemoveItem(class UBP_JigMultiplayer_C* TargetComp, const struct FGuid& ItemUID, int32 Amount, bool CallbackToPlayer_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestRemoveItem");

	Params::BP_JigMultiplayer_C_SERVER_RequestRemoveItem Parms{};

	Parms.TargetComp = TargetComp;
	Parms.ItemUID = std::move(ItemUID);
	Parms.Amount = Amount;
	Parms.CallbackToPlayer_ = CallbackToPlayer_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestSaveGame
// (Net, NetReliable, NetServer, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             MpRef                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    ActionbarUIDs                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::SERVER_RequestSaveGame(class UBP_JigMultiplayer_C* MpRef, const TArray<struct FGuid>& ActionbarUIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestSaveGame");

	Params::BP_JigMultiplayer_C_SERVER_RequestSaveGame Parms{};

	Parms.MpRef = MpRef;
	Parms.ActionbarUIDs = std::move(ActionbarUIDs);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestSaveOneJigContainerByIndex
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           SaveName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// int32                                   UserIndex                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ContainerIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestSaveOneJigContainerByIndex(const class FString& SaveName, const int32 UserIndex, int32 ContainerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestSaveOneJigContainerByIndex");

	Params::BP_JigMultiplayer_C_SERVER_RequestSaveOneJigContainerByIndex Parms{};

	Parms.SaveName = std::move(SaveName);
	Parms.UserIndex = UserIndex;
	Parms.ContainerIndex = ContainerIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestSplitItem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             FromComp                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             ToComp                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SplitAmount                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestSplitItem(class UBP_JigMultiplayer_C* FromComp, class UBP_JigMultiplayer_C* ToComp, const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, int32 SplitAmount, bool Rotated_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestSplitItem");

	Params::BP_JigMultiplayer_C_SERVER_RequestSplitItem Parms{};

	Parms.FromComp = FromComp;
	Parms.ToComp = ToComp;
	Parms.ItemUID = std::move(ItemUID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.SplitAmount = SplitAmount;
	Parms.Rotated_ = Rotated_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestStackItem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             FromCom                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             ToComp                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            DroppedUID                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ReceiverUID                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MaxStack                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestStackItem(class UBP_JigMultiplayer_C* FromCom, class UBP_JigMultiplayer_C* ToComp, const struct FGuid& DroppedUID, const struct FGuid& ReceiverUID, int32 MaxStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestStackItem");

	Params::BP_JigMultiplayer_C_SERVER_RequestStackItem Parms{};

	Parms.FromCom = FromCom;
	Parms.ToComp = ToComp;
	Parms.DroppedUID = std::move(DroppedUID);
	Parms.ReceiverUID = std::move(ReceiverUID);
	Parms.MaxStack = MaxStack;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_RequestSwapContainers
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            SecondContainerUID                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_RequestSwapContainers(const struct FGuid& ContainerUID, const struct FGuid& SecondContainerUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_RequestSwapContainers");

	Params::BP_JigMultiplayer_C_SERVER_RequestSwapContainers Parms{};

	Parms.ContainerUID = std::move(ContainerUID);
	Parms.SecondContainerUID = std::move(SecondContainerUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_SameContainer_MoveToIndex
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             JigMPCompRef                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   InContainerIndex                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_SameContainer_MoveToIndex(class UBP_JigMultiplayer_C* JigMPCompRef, const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool Rotated_, int32 InContainerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_SameContainer_MoveToIndex");

	Params::BP_JigMultiplayer_C_SERVER_SameContainer_MoveToIndex Parms{};

	Parms.JigMPCompRef = JigMPCompRef;
	Parms.ItemUID = std::move(ItemUID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.Rotated_ = Rotated_;
	Parms.InContainerIndex = InContainerIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SERVER_UpdateStatByUID
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     STAT_NAME                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// double                                  NewValue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SERVER_UpdateStatByUID(const struct FGuid& UID, const struct FGameplayTag& STAT_NAME, double NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SERVER_UpdateStatByUID");

	Params::BP_JigMultiplayer_C_SERVER_UpdateStatByUID Parms{};

	Parms.UID = std::move(UID);
	Parms.STAT_NAME = std::move(STAT_NAME);
	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ServerFindThenConsumeByItemID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ServerFindThenConsumeByItemID(class UJigsawItem_DataAsset_C* ItemId, int32 Count, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ServerFindThenConsumeByItemID");

	Params::BP_JigMultiplayer_C_ServerFindThenConsumeByItemID Parms{};

	Parms.ItemId = ItemId;
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ServerFunc_HandleMoveToCapacityContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             FromComp                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             ToComp                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Proceed_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Fail_                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ServerFunc_HandleMoveToCapacityContainer(class UBP_JigMultiplayer_C* FromComp, class UBP_JigMultiplayer_C* ToComp, const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool* Proceed_, bool* Fail_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ServerFunc_HandleMoveToCapacityContainer");

	Params::BP_JigMultiplayer_C_ServerFunc_HandleMoveToCapacityContainer Parms{};

	Parms.FromComp = FromComp;
	Parms.ToComp = ToComp;
	Parms.ItemUID = std::move(ItemUID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToIndex = ToIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Proceed_ != nullptr)
		*Proceed_ = Parms.Proceed_;

	if (Fail_ != nullptr)
		*Fail_ = Parms.Fail_;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ServerFunc_HandleRequestAddActorToContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            AddtoUID                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            TempUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FinalRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FGuid>                    Stacks                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UBP_JigMultiplayer_C::ServerFunc_HandleRequestAddActorToContainer(class AActor* ActorRef, const struct FGuid& AddtoUID, const struct FGuid& TempUID, int32 ToIndex, bool FinalRotation, TArray<struct FGuid>& Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ServerFunc_HandleRequestAddActorToContainer");

	Params::BP_JigMultiplayer_C_ServerFunc_HandleRequestAddActorToContainer Parms{};

	Parms.ActorRef = ActorRef;
	Parms.AddtoUID = std::move(AddtoUID);
	Parms.TempUID = std::move(TempUID);
	Parms.ToIndex = ToIndex;
	Parms.FinalRotation = FinalRotation;
	Parms.Stacks = std::move(Stacks);

	UObject::ProcessEvent(Func, &Parms);

	Stacks = std::move(Parms.Stacks);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ServerFunc_ProcessRequestStackAddActor
// (Protected, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            WithUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ServerFunc_ProcessRequestStackAddActor(class AActor* ActorRef, const struct FGuid& WithUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ServerFunc_ProcessRequestStackAddActor");

	Params::BP_JigMultiplayer_C_ServerFunc_ProcessRequestStackAddActor Parms{};

	Parms.ActorRef = ActorRef;
	Parms.WithUID = std::move(WithUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ServerFunc_RequestStackItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             FromCom                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             ToComp                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            DroppedUID                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ReceiverUID                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MaxStack                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ServerFunc_RequestStackItem(class UBP_JigMultiplayer_C* FromCom, class UBP_JigMultiplayer_C* ToComp, const struct FGuid& DroppedUID, const struct FGuid& ReceiverUID, int32 MaxStack, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ServerFunc_RequestStackItem");

	Params::BP_JigMultiplayer_C_ServerFunc_RequestStackItem Parms{};

	Parms.FromCom = FromCom;
	Parms.ToComp = ToComp;
	Parms.DroppedUID = std::move(DroppedUID);
	Parms.ReceiverUID = std::move(ReceiverUID);
	Parms.MaxStack = MaxStack;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ServerFunc_UpdateCustomDataByUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class FString>                   Keys                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class FString>                   Values                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Updated                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ServerFunc_UpdateCustomDataByUID(const struct FGuid& UID, TArray<class FString>& Keys, TArray<class FString>& Values, bool* Updated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ServerFunc_UpdateCustomDataByUID");

	Params::BP_JigMultiplayer_C_ServerFunc_UpdateCustomDataByUID Parms{};

	Parms.UID = std::move(UID);
	Parms.Keys = std::move(Keys);
	Parms.Values = std::move(Values);

	UObject::ProcessEvent(Func, &Parms);

	Keys = std::move(Parms.Keys);
	Values = std::move(Parms.Values);

	if (Updated != nullptr)
		*Updated = Parms.Updated;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ServerFunc_UpdateDurabilityByUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        NewDurability                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Updated                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ServerFunc_UpdateDurabilityByUID(const struct FGuid& UID, const struct FVector2D& NewDurability, bool* Updated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ServerFunc_UpdateDurabilityByUID");

	Params::BP_JigMultiplayer_C_ServerFunc_UpdateDurabilityByUID Parms{};

	Parms.UID = std::move(UID);
	Parms.NewDurability = std::move(NewDurability);

	UObject::ProcessEvent(Func, &Parms);

	if (Updated != nullptr)
		*Updated = Parms.Updated;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ServerFuncExpandContainer
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContainerUID                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AddColumns                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AddRows                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ServerFuncExpandContainer(const struct FGuid& ContainerUID, int32 AddColumns, int32 AddRows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ServerFuncExpandContainer");

	Params::BP_JigMultiplayer_C_ServerFuncExpandContainer Parms{};

	Parms.ContainerUID = std::move(ContainerUID);
	Parms.AddColumns = AddColumns;
	Parms.AddRows = AddRows;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ServerFuncHandleEquipActor
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToMainUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ServerFuncHandleEquipActor(class AActor* ActorRef, const struct FGuid& ToMainUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ServerFuncHandleEquipActor");

	Params::BP_JigMultiplayer_C_ServerFuncHandleEquipActor Parms{};

	Parms.ActorRef = ActorRef;
	Parms.ToMainUID = std::move(ToMainUID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ServerFuncUpdateDurabilityByUID
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  MinusDur                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DestroyItemIfZeroDur_                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  NewDur                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ServerFuncUpdateDurabilityByUID(const struct FGuid& UID, double MinusDur, bool DestroyItemIfZeroDur_, double* NewDur)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ServerFuncUpdateDurabilityByUID");

	Params::BP_JigMultiplayer_C_ServerFuncUpdateDurabilityByUID Parms{};

	Parms.UID = std::move(UID);
	Parms.MinusDur = MinusDur;
	Parms.DestroyItemIfZeroDur_ = DestroyItemIfZeroDur_;

	UObject::ProcessEvent(Func, &Parms);

	if (NewDur != nullptr)
		*NewDur = Parms.NewDur;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ServerHandleSplitRequest
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_JigMultiplayer_C*             FromComp                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             ToComp                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            ToContainerUID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SplitAmount                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ServerHandleSplitRequest(class UBP_JigMultiplayer_C* FromComp, class UBP_JigMultiplayer_C* ToComp, const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, int32 SplitAmount, bool Rotated_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ServerHandleSplitRequest");

	Params::BP_JigMultiplayer_C_ServerHandleSplitRequest Parms{};

	Parms.FromComp = FromComp;
	Parms.ToComp = ToComp;
	Parms.ItemUID = std::move(ItemUID);
	Parms.ToContainerUID = std::move(ToContainerUID);
	Parms.ToIndex = ToIndex;
	Parms.SplitAmount = SplitAmount;
	Parms.Rotated_ = Rotated_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ServerUpdateCountByUID
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ItemUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::ServerUpdateCountByUID(const struct FGuid& ItemUID, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ServerUpdateCountByUID");

	Params::BP_JigMultiplayer_C_ServerUpdateCountByUID Parms{};

	Parms.ItemUID = std::move(ItemUID);
	Parms.NewCount = NewCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SetActorRefByItemUID
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SetActorRefByItemUID(const struct FGuid& UID, class AActor* ActorRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SetActorRefByItemUID");

	Params::BP_JigMultiplayer_C_SetActorRefByItemUID Parms{};

	Parms.UID = std::move(UID);
	Parms.ActorRef = ActorRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SetContainerSettingsFromWidget
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::SetContainerSettingsFromWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SetContainerSettingsFromWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SetPermissions
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  JSITarget                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SetPermissions(class UJSIContainer_C* JSITarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SetPermissions");

	Params::BP_JigMultiplayer_C_SetPermissions Parms{};

	Parms.JSITarget = JSITarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SetPickupContainerData
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FContainerPickupsInfo            PickupInfo_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FS_ReplicatedContainerInfo>MainReplicatedContainers                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::SetPickupContainerData(const struct FContainerPickupsInfo& PickupInfo_0, TArray<struct FS_ReplicatedContainerInfo>& MainReplicatedContainers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SetPickupContainerData");

	Params::BP_JigMultiplayer_C_SetPickupContainerData Parms{};

	Parms.PickupInfo_0 = std::move(PickupInfo_0);
	Parms.MainReplicatedContainers = std::move(MainReplicatedContainers);

	UObject::ProcessEvent(Func, &Parms);

	MainReplicatedContainers = std::move(Parms.MainReplicatedContainers);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SetupInventoryWidget
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ClearInv_                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReInitWidget_                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ForceInitSP_                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UUserWidget*                      InventoryWidgetRef_0                                   (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SetupInventoryWidget(bool ClearInv_, bool ReInitWidget_, bool ForceInitSP_, class UUserWidget** InventoryWidgetRef_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SetupInventoryWidget");

	Params::BP_JigMultiplayer_C_SetupInventoryWidget Parms{};

	Parms.ClearInv_ = ClearInv_;
	Parms.ReInitWidget_ = ReInitWidget_;
	Parms.ForceInitSP_ = ForceInitSP_;

	UObject::ProcessEvent(Func, &Parms);

	if (InventoryWidgetRef_0 != nullptr)
		*InventoryWidgetRef_0 = Parms.InventoryWidgetRef_0;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SetupNewAddedItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  JSIRef                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// TArray<struct FContainerPickupsInfo>    AllItems                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::SetupNewAddedItem(class UJSIContainer_C* JSIRef, TArray<struct FContainerPickupsInfo>& AllItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SetupNewAddedItem");

	Params::BP_JigMultiplayer_C_SetupNewAddedItem Parms{};

	Parms.JSIRef = JSIRef;
	Parms.AllItems = std::move(AllItems);

	UObject::ProcessEvent(Func, &Parms);

	AllItems = std::move(Parms.AllItems);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SetupWidgetCleanupTimer
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::SetupWidgetCleanupTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SetupWidgetCleanupTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SetVendorPriceOfSoldItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FContainerPickupsInfo            Info                                                   (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FS_ReplicatedContainerInfo>Containers                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UBP_JigMultiplayer_C::SetVendorPriceOfSoldItem(struct FContainerPickupsInfo& Info, TArray<struct FS_ReplicatedContainerInfo>& Containers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SetVendorPriceOfSoldItem");

	Params::BP_JigMultiplayer_C_SetVendorPriceOfSoldItem Parms{};

	Parms.Info = std::move(Info);
	Parms.Containers = std::move(Containers);

	UObject::ProcessEvent(Func, &Parms);

	Info = std::move(Parms.Info);
	Containers = std::move(Parms.Containers);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.StartRefillTimer
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ClearContainer_                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::StartRefillTimer(bool ClearContainer_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "StartRefillTimer");

	Params::BP_JigMultiplayer_C_StartRefillTimer Parms{};

	Parms.ClearContainer_ = ClearContainer_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.SwapTwoItems
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            Item1                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            Item2                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   RemoveCount                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::SwapTwoItems(const struct FGuid& Item1, const struct FGuid& Item2, int32 RemoveCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "SwapTwoItems");

	Params::BP_JigMultiplayer_C_SwapTwoItems Parms{};

	Parms.Item1 = std::move(Item1);
	Parms.Item2 = std::move(Item2);
	Parms.RemoveCount = RemoveCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.TakeMoney
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Price                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          Currency                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FS_UpdateCount>           UpdateMoneyCount                                       (Parm, OutParm)

bool UBP_JigMultiplayer_C::TakeMoney(int32 Price, class UJigsawItem_DataAsset_C* Currency, TArray<struct FS_UpdateCount>* UpdateMoneyCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "TakeMoney");

	Params::BP_JigMultiplayer_C_TakeMoney Parms{};

	Parms.Price = Price;
	Parms.Currency = Currency;

	UObject::ProcessEvent(Func, &Parms);

	if (UpdateMoneyCount != nullptr)
		*UpdateMoneyCount = std::move(Parms.UpdateMoneyCount);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.ToggleInventory
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_JigMultiplayer_C::ToggleInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "ToggleInventory");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.TryAddNewItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_ReplicatedContainerInfo       RepContainer                                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// struct FRandomContainerItem             ItemToAdd                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// bool                                    CheckWeight_                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TryStacking_                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   CustomMaxStack                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FContainerPickupsInfo            AddedItemInfo                                          (Parm, OutParm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Added_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Stacked_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::TryAddNewItem(struct FS_ReplicatedContainerInfo& RepContainer, struct FRandomContainerItem& ItemToAdd, bool CheckWeight_, bool TryStacking_, int32 CustomMaxStack, struct FContainerPickupsInfo* AddedItemInfo, bool* Added_, bool* Stacked_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "TryAddNewItem");

	Params::BP_JigMultiplayer_C_TryAddNewItem Parms{};

	Parms.RepContainer = std::move(RepContainer);
	Parms.ItemToAdd = std::move(ItemToAdd);
	Parms.CheckWeight_ = CheckWeight_;
	Parms.TryStacking_ = TryStacking_;
	Parms.CustomMaxStack = CustomMaxStack;

	UObject::ProcessEvent(Func, &Parms);

	RepContainer = std::move(Parms.RepContainer);
	ItemToAdd = std::move(Parms.ItemToAdd);

	if (AddedItemInfo != nullptr)
		*AddedItemInfo = std::move(Parms.AddedItemInfo);

	if (Added_ != nullptr)
		*Added_ = Parms.Added_;

	if (Stacked_ != nullptr)
		*Stacked_ = Parms.Stacked_;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.UIDNotValid
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGuid                            InGuid                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBP_JigMultiplayer_C::UIDNotValid(const struct FGuid& InGuid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "UIDNotValid");

	Params::BP_JigMultiplayer_C_UIDNotValid Parms{};

	Parms.InGuid = std::move(InGuid);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.UpdateCountByByMotherUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            MotherUID                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Updated_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::UpdateCountByByMotherUID(const struct FGuid& MotherUID, int32 NewCount, bool* Updated_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "UpdateCountByByMotherUID");

	Params::BP_JigMultiplayer_C_UpdateCountByByMotherUID Parms{};

	Parms.MotherUID = std::move(MotherUID);
	Parms.NewCount = NewCount;

	UObject::ProcessEvent(Func, &Parms);

	if (Updated_ != nullptr)
		*Updated_ = Parms.Updated_;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.UpdatePickupInfo
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FContainerPickupsInfo            PickupInfo_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::UpdatePickupInfo(const struct FContainerPickupsInfo& PickupInfo_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "UpdatePickupInfo");

	Params::BP_JigMultiplayer_C_UpdatePickupInfo Parms{};

	Parms.PickupInfo_0 = std::move(PickupInfo_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.UpdateStatByUID
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UID                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     STAT_TAG                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// double                                  NewValue                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::UpdateStatByUID(const struct FGuid& UID, const struct FGameplayTag& STAT_TAG, double NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "UpdateStatByUID");

	Params::BP_JigMultiplayer_C_UpdateStatByUID Parms{};

	Parms.UID = std::move(UID);
	Parms.STAT_TAG = std::move(STAT_TAG);
	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.UpdateWeight
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ContUID                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Weight                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::UpdateWeight(const struct FGuid& ContUID, double Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "UpdateWeight");

	Params::BP_JigMultiplayer_C_UpdateWeight Parms{};

	Parms.ContUID = std::move(ContUID);
	Parms.Weight = Weight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.VendorCompareItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FContainerPickupsInfo            Item1                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// TArray<struct FS_ReplicatedContainerInfo>Item1SubContainers                                     (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FContainerPickupsInfo            Item2                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash)
// bool                                    Proceed_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::VendorCompareItems(struct FContainerPickupsInfo& Item1, TArray<struct FS_ReplicatedContainerInfo>& Item1SubContainers, struct FContainerPickupsInfo& Item2, bool* Proceed_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "VendorCompareItems");

	Params::BP_JigMultiplayer_C_VendorCompareItems Parms{};

	Parms.Item1 = std::move(Item1);
	Parms.Item1SubContainers = std::move(Item1SubContainers);
	Parms.Item2 = std::move(Item2);

	UObject::ProcessEvent(Func, &Parms);

	Item1 = std::move(Parms.Item1);
	Item1SubContainers = std::move(Parms.Item1SubContainers);
	Item2 = std::move(Parms.Item2);

	if (Proceed_ != nullptr)
		*Proceed_ = Parms.Proceed_;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.VendorTryStackMoney
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   MaxStack                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRepItemInfo                     Currency                                               (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool                                    Stacked_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::VendorTryStackMoney(int32 MaxStack, const struct FRepItemInfo& Currency, bool* Stacked_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "VendorTryStackMoney");

	Params::BP_JigMultiplayer_C_VendorTryStackMoney Parms{};

	Parms.MaxStack = MaxStack;
	Parms.Currency = std::move(Currency);

	UObject::ProcessEvent(Func, &Parms);

	if (Stacked_ != nullptr)
		*Stacked_ = Parms.Stacked_;
}


// Function BP_JigMultiplayer.BP_JigMultiplayer_C.WaitFullReplicationOfUIDs
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Reset_                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_JigMultiplayer_C::WaitFullReplicationOfUIDs(bool Reset_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_JigMultiplayer_C", "WaitFullReplicationOfUIDs");

	Params::BP_JigMultiplayer_C_WaitFullReplicationOfUIDs Parms{};

	Parms.Reset_ = Reset_;

	UObject::ProcessEvent(Func, &Parms);
}

}

