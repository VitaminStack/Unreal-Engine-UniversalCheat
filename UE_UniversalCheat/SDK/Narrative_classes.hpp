#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Narrative

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "Narrative_structs.hpp"
#include "CinematicCamera_structs.hpp"
#include "CinematicCamera_classes.hpp"
#include "MovieScene_structs.hpp"


namespace SDK
{

// Class Narrative.Dialogue
// 0x0388 (0x03B0 - 0x0028)
class UDialogue : public UObject
{
public:
	TArray<struct FSpeakerInfo>                   Speakers;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerSpeakerInfo                     PlayerSpeakerInfo;                                 // 0x0040(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FPlayerSpeakerInfo>             PartySpeakerInfo;                                  // 0x00F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bFreeMovement;                                     // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeExited;                                      // 0x0101(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoRotateSpeakers;                               // 0x0102(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoStopMovement;                                 // 0x0103(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0104(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultHeadBoneName;                               // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DialogueBlendOutTime;                              // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustPlayerTransform;                            // 0x0114(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0xB];                                      // 0x0115(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             PlayerAutoAdjustTransform;                         // 0x0120(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShakeBase>           DialogueCameraShake;                               // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      DialogueSoundAttenuation;                          // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNarrativeDialogueSequence*             DefaultDialogueShot;                               // 0x0190(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNarrativeComponent*                    OwningComp;                                        // 0x0198(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  OwningPawn;                                        // 0x01A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      OwningController;                                  // 0x01A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueNode_NPC*                      RootDialogue;                                      // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDialogueNode_NPC*>              NPCReplies;                                        // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UDialogueNode_Player*>           PlayerReplies;                                     // 0x01C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UDialogueNode_NPC*>              NPCReplyChain;                                     // 0x01D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UDialogueNode_Player*>           AvailableResponses;                                // 0x01E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UDialogueNode*                          CurrentNode;                                       // 0x01F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSpeakerInfo                           CurrentSpeaker;                                    // 0x0200(0x00B0)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentSpeakerAvatar;                              // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 CurrentListenerAvatar;                             // 0x02B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerState*                           CurrentPartySpeakerAvatar;                         // 0x02C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDialogueLine                          CurrentLine;                                       // 0x02C8(0x0040)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    DialogueSequencePlayer;                            // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNarrativeDialogueSequence*             CurrentDialogueSequence;                           // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           DialogueSpeakerMontage;                            // 0x0318(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        DialogueAudio;                                     // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDialoguePlayParams                    PlayParams;                                        // 0x0328(0x000C)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class AActor*>              SpeakerAvatars;                                    // 0x0338(0x0050)(Protected, NativeAccessSpecifierProtected)
	class AActor*                                 OldViewTarget;                                     // 0x0388(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimerHandle_NPCReplyFinished;                      // 0x0390(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimerHandle_PlayerReplyFinished;                   // 0x0398(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x10];                                     // 0x03A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustPlayerTransform();
	void BlendingOutFinished();
	void DestroySpeakerAvatar(const struct FSpeakerInfo& Info, class AActor* SpeakerAvatar);
	void EndCurrentLine();
	void FinishDialogueNode(class UDialogueNode* Node, const struct FDialogueLine& Line, const struct FSpeakerInfo& Speaker, class AActor* SpeakerActor, class AActor* ListenerActor);
	void FinishNPCDialogue();
	void FinishPlayerDialogue();
	float GetLineDuration(class UDialogueNode* Node, const struct FDialogueLine& Line);
	class FString GetStringVariable(const class UDialogueNode* Node, const struct FDialogueLine& Line, const class FString& VariableName);
	void K2_OnBeginDialogue();
	void K2_OnEndDialogue();
	class AActor* LinkSpeakerAvatar(const struct FSpeakerInfo& Info);
	void OnNPCDialogueLineFinished(class UDialogueNode_NPC* Node, const struct FDialogueLine& DialogueLine, const struct FSpeakerInfo& Speaker);
	void OnNPCDialogueLineStarted(class UDialogueNode_NPC* Node, const struct FDialogueLine& DialogueLine, const struct FSpeakerInfo& Speaker);
	void OnPlayerDialogueLineFinished(class UDialogueNode_Player* Node, const struct FDialogueLine& DialogueLine);
	void OnPlayerDialogueLineStarted(class UDialogueNode_Player* Node, const struct FDialogueLine& DialogueLine);
	void PlayDialogueAnimation(class UDialogueNode* Node, const struct FDialogueLine& Line, class AActor* Speaker, class AActor* Listener);
	void PlayDialogueNode(class UDialogueNode* Node, const struct FDialogueLine& Line, const struct FSpeakerInfo& Speaker, class AActor* SpeakerActor, class AActor* ListenerActor);
	void PlayDialogueSequence(class UNarrativeDialogueSequence* Sequence, class AActor* Speaker, class AActor* Listener);
	void PlayDialogueSound(const struct FDialogueLine& Line, class AActor* Speaker, class AActor* Listener);
	void PlayNextNPCReply();
	void PlayNPCDialogue(class UDialogueNode_NPC* NPCReply, const struct FDialogueLine& Line, const struct FSpeakerInfo& Speaker);
	void PlayPlayerDialogue(class UDialogueNode_Player* PlayerReply, const struct FDialogueLine& Line);
	bool SkipCurrentLine();
	void StopDialogueAnimation();
	void StopDialogueSequence();
	void TickDialogue(const float DeltaTime);

	bool CanSkipCurrentLine() const;
	class AActor* GetAvatar(const class FName& SpeakerID) const;
	struct FVector GetConversationCenterPoint() const;
	TArray<class UDialogueNode*> GetNodes() const;
	class AActor* GetPlayerAvatar() const;
	struct FVector GetSpeakerHeadLocation(class AActor* Actor) const;
	bool IsPartyDialogue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Dialogue">();
	}
	static class UDialogue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogue>();
	}
};
static_assert(alignof(UDialogue) == 0x000010, "Wrong alignment on UDialogue");
static_assert(sizeof(UDialogue) == 0x0003B0, "Wrong size on UDialogue");
static_assert(offsetof(UDialogue, Speakers) == 0x000028, "Member 'UDialogue::Speakers' has a wrong offset!");
static_assert(offsetof(UDialogue, PlayerSpeakerInfo) == 0x000040, "Member 'UDialogue::PlayerSpeakerInfo' has a wrong offset!");
static_assert(offsetof(UDialogue, PartySpeakerInfo) == 0x0000F0, "Member 'UDialogue::PartySpeakerInfo' has a wrong offset!");
static_assert(offsetof(UDialogue, bFreeMovement) == 0x000100, "Member 'UDialogue::bFreeMovement' has a wrong offset!");
static_assert(offsetof(UDialogue, bCanBeExited) == 0x000101, "Member 'UDialogue::bCanBeExited' has a wrong offset!");
static_assert(offsetof(UDialogue, bAutoRotateSpeakers) == 0x000102, "Member 'UDialogue::bAutoRotateSpeakers' has a wrong offset!");
static_assert(offsetof(UDialogue, bAutoStopMovement) == 0x000103, "Member 'UDialogue::bAutoStopMovement' has a wrong offset!");
static_assert(offsetof(UDialogue, Priority) == 0x000104, "Member 'UDialogue::Priority' has a wrong offset!");
static_assert(offsetof(UDialogue, DefaultHeadBoneName) == 0x000108, "Member 'UDialogue::DefaultHeadBoneName' has a wrong offset!");
static_assert(offsetof(UDialogue, DialogueBlendOutTime) == 0x000110, "Member 'UDialogue::DialogueBlendOutTime' has a wrong offset!");
static_assert(offsetof(UDialogue, bAdjustPlayerTransform) == 0x000114, "Member 'UDialogue::bAdjustPlayerTransform' has a wrong offset!");
static_assert(offsetof(UDialogue, PlayerAutoAdjustTransform) == 0x000120, "Member 'UDialogue::PlayerAutoAdjustTransform' has a wrong offset!");
static_assert(offsetof(UDialogue, DialogueCameraShake) == 0x000180, "Member 'UDialogue::DialogueCameraShake' has a wrong offset!");
static_assert(offsetof(UDialogue, DialogueSoundAttenuation) == 0x000188, "Member 'UDialogue::DialogueSoundAttenuation' has a wrong offset!");
static_assert(offsetof(UDialogue, DefaultDialogueShot) == 0x000190, "Member 'UDialogue::DefaultDialogueShot' has a wrong offset!");
static_assert(offsetof(UDialogue, OwningComp) == 0x000198, "Member 'UDialogue::OwningComp' has a wrong offset!");
static_assert(offsetof(UDialogue, OwningPawn) == 0x0001A0, "Member 'UDialogue::OwningPawn' has a wrong offset!");
static_assert(offsetof(UDialogue, OwningController) == 0x0001A8, "Member 'UDialogue::OwningController' has a wrong offset!");
static_assert(offsetof(UDialogue, RootDialogue) == 0x0001B0, "Member 'UDialogue::RootDialogue' has a wrong offset!");
static_assert(offsetof(UDialogue, NPCReplies) == 0x0001B8, "Member 'UDialogue::NPCReplies' has a wrong offset!");
static_assert(offsetof(UDialogue, PlayerReplies) == 0x0001C8, "Member 'UDialogue::PlayerReplies' has a wrong offset!");
static_assert(offsetof(UDialogue, NPCReplyChain) == 0x0001D8, "Member 'UDialogue::NPCReplyChain' has a wrong offset!");
static_assert(offsetof(UDialogue, AvailableResponses) == 0x0001E8, "Member 'UDialogue::AvailableResponses' has a wrong offset!");
static_assert(offsetof(UDialogue, CurrentNode) == 0x0001F8, "Member 'UDialogue::CurrentNode' has a wrong offset!");
static_assert(offsetof(UDialogue, CurrentSpeaker) == 0x000200, "Member 'UDialogue::CurrentSpeaker' has a wrong offset!");
static_assert(offsetof(UDialogue, CurrentSpeakerAvatar) == 0x0002B0, "Member 'UDialogue::CurrentSpeakerAvatar' has a wrong offset!");
static_assert(offsetof(UDialogue, CurrentListenerAvatar) == 0x0002B8, "Member 'UDialogue::CurrentListenerAvatar' has a wrong offset!");
static_assert(offsetof(UDialogue, CurrentPartySpeakerAvatar) == 0x0002C0, "Member 'UDialogue::CurrentPartySpeakerAvatar' has a wrong offset!");
static_assert(offsetof(UDialogue, CurrentLine) == 0x0002C8, "Member 'UDialogue::CurrentLine' has a wrong offset!");
static_assert(offsetof(UDialogue, DialogueSequencePlayer) == 0x000308, "Member 'UDialogue::DialogueSequencePlayer' has a wrong offset!");
static_assert(offsetof(UDialogue, CurrentDialogueSequence) == 0x000310, "Member 'UDialogue::CurrentDialogueSequence' has a wrong offset!");
static_assert(offsetof(UDialogue, DialogueSpeakerMontage) == 0x000318, "Member 'UDialogue::DialogueSpeakerMontage' has a wrong offset!");
static_assert(offsetof(UDialogue, DialogueAudio) == 0x000320, "Member 'UDialogue::DialogueAudio' has a wrong offset!");
static_assert(offsetof(UDialogue, PlayParams) == 0x000328, "Member 'UDialogue::PlayParams' has a wrong offset!");
static_assert(offsetof(UDialogue, SpeakerAvatars) == 0x000338, "Member 'UDialogue::SpeakerAvatars' has a wrong offset!");
static_assert(offsetof(UDialogue, OldViewTarget) == 0x000388, "Member 'UDialogue::OldViewTarget' has a wrong offset!");
static_assert(offsetof(UDialogue, TimerHandle_NPCReplyFinished) == 0x000390, "Member 'UDialogue::TimerHandle_NPCReplyFinished' has a wrong offset!");
static_assert(offsetof(UDialogue, TimerHandle_PlayerReplyFinished) == 0x000398, "Member 'UDialogue::TimerHandle_PlayerReplyFinished' has a wrong offset!");

// Class Narrative.DialogueAsset
// 0x0008 (0x0038 - 0x0030)
class UDialogueAsset final : public UDataAsset
{
public:
	class UDialogue*                              Dialogue;                                          // 0x0030(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueAsset">();
	}
	static class UDialogueAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueAsset>();
	}
};
static_assert(alignof(UDialogueAsset) == 0x000008, "Wrong alignment on UDialogueAsset");
static_assert(sizeof(UDialogueAsset) == 0x000038, "Wrong size on UDialogueAsset");
static_assert(offsetof(UDialogueAsset, Dialogue) == 0x000030, "Member 'UDialogueAsset::Dialogue' has a wrong offset!");

// Class Narrative.DialogueBlueprintGeneratedClass
// 0x0008 (0x0370 - 0x0368)
class UDialogueBlueprintGeneratedClass final : public UBlueprintGeneratedClass
{
public:
	class UDialogue*                              DialogueTemplate;                                  // 0x0368(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueBlueprintGeneratedClass">();
	}
	static class UDialogueBlueprintGeneratedClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueBlueprintGeneratedClass>();
	}
};
static_assert(alignof(UDialogueBlueprintGeneratedClass) == 0x000008, "Wrong alignment on UDialogueBlueprintGeneratedClass");
static_assert(sizeof(UDialogueBlueprintGeneratedClass) == 0x000370, "Wrong size on UDialogueBlueprintGeneratedClass");
static_assert(offsetof(UDialogueBlueprintGeneratedClass, DialogueTemplate) == 0x000368, "Member 'UDialogueBlueprintGeneratedClass::DialogueTemplate' has a wrong offset!");

// Class Narrative.NarrativeNodeBase
// 0x0038 (0x0060 - 0x0028)
class UNarrativeNodeBase : public UObject
{
public:
	struct FVector2D                              NodePos;                                           // 0x0028(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UNarrativeCondition*>            Conditions;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UNarrativeEvent*>                Events;                                            // 0x0048(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool AreConditionsMet(class APawn* Pawn, class APlayerController* Controller, class UNarrativeComponent* NarrativeComponent);
	void ProcessEvents(class APawn* Pawn, class APlayerController* Controller, class UNarrativeComponent* NarrativeComponent, const EEventRuntime Runtime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativeNodeBase">();
	}
	static class UNarrativeNodeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNarrativeNodeBase>();
	}
};
static_assert(alignof(UNarrativeNodeBase) == 0x000008, "Wrong alignment on UNarrativeNodeBase");
static_assert(sizeof(UNarrativeNodeBase) == 0x000060, "Wrong size on UNarrativeNodeBase");
static_assert(offsetof(UNarrativeNodeBase, NodePos) == 0x000028, "Member 'UNarrativeNodeBase::NodePos' has a wrong offset!");
static_assert(offsetof(UNarrativeNodeBase, Conditions) == 0x000038, "Member 'UNarrativeNodeBase::Conditions' has a wrong offset!");
static_assert(offsetof(UNarrativeNodeBase, Events) == 0x000048, "Member 'UNarrativeNodeBase::Events' has a wrong offset!");
static_assert(offsetof(UNarrativeNodeBase, ID) == 0x000058, "Member 'UNarrativeNodeBase::ID' has a wrong offset!");

// Class Narrative.DialogueNode
// 0x00E8 (0x0148 - 0x0060)
class UDialogueNode : public UNarrativeNodeBase
{
public:
	struct FDialogueLine                          Line;                                              // 0x0060(0x0040)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FDialogueLine>                  AlternativeLines;                                  // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnDialogueFinished;                                // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FDialogueLine                          PlayedLine;                                        // 0x00C0(0x0040)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UDialogueNode_NPC*>              NPCReplies;                                        // 0x0100(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UDialogueNode_Player*>           PlayerReplies;                                     // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UDialogue*                              OwningDialogue;                                    // 0x0120(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNarrativeComponent*                    OwningComponent;                                   // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OnPlayNodeFuncName;                                // 0x0130(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DirectedAtSpeakerID;                               // 0x0138(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSkippable;                                      // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueNode">();
	}
	static class UDialogueNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueNode>();
	}
};
static_assert(alignof(UDialogueNode) == 0x000008, "Wrong alignment on UDialogueNode");
static_assert(sizeof(UDialogueNode) == 0x000148, "Wrong size on UDialogueNode");
static_assert(offsetof(UDialogueNode, Line) == 0x000060, "Member 'UDialogueNode::Line' has a wrong offset!");
static_assert(offsetof(UDialogueNode, AlternativeLines) == 0x0000A0, "Member 'UDialogueNode::AlternativeLines' has a wrong offset!");
static_assert(offsetof(UDialogueNode, OnDialogueFinished) == 0x0000B0, "Member 'UDialogueNode::OnDialogueFinished' has a wrong offset!");
static_assert(offsetof(UDialogueNode, PlayedLine) == 0x0000C0, "Member 'UDialogueNode::PlayedLine' has a wrong offset!");
static_assert(offsetof(UDialogueNode, NPCReplies) == 0x000100, "Member 'UDialogueNode::NPCReplies' has a wrong offset!");
static_assert(offsetof(UDialogueNode, PlayerReplies) == 0x000110, "Member 'UDialogueNode::PlayerReplies' has a wrong offset!");
static_assert(offsetof(UDialogueNode, OwningDialogue) == 0x000120, "Member 'UDialogueNode::OwningDialogue' has a wrong offset!");
static_assert(offsetof(UDialogueNode, OwningComponent) == 0x000128, "Member 'UDialogueNode::OwningComponent' has a wrong offset!");
static_assert(offsetof(UDialogueNode, OnPlayNodeFuncName) == 0x000130, "Member 'UDialogueNode::OnPlayNodeFuncName' has a wrong offset!");
static_assert(offsetof(UDialogueNode, DirectedAtSpeakerID) == 0x000138, "Member 'UDialogueNode::DirectedAtSpeakerID' has a wrong offset!");
static_assert(offsetof(UDialogueNode, bIsSkippable) == 0x000140, "Member 'UDialogueNode::bIsSkippable' has a wrong offset!");

// Class Narrative.DialogueNode_NPC
// 0x0010 (0x0158 - 0x0148)
class UDialogueNode_NPC final : public UDialogueNode
{
public:
	class UNarrativeDialogueSequence*             SelectingReplyShot;                                // 0x0148(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpeakerID;                                         // 0x0150(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class FName GetSpeakerID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueNode_NPC">();
	}
	static class UDialogueNode_NPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueNode_NPC>();
	}
};
static_assert(alignof(UDialogueNode_NPC) == 0x000008, "Wrong alignment on UDialogueNode_NPC");
static_assert(sizeof(UDialogueNode_NPC) == 0x000158, "Wrong size on UDialogueNode_NPC");
static_assert(offsetof(UDialogueNode_NPC, SelectingReplyShot) == 0x000148, "Member 'UDialogueNode_NPC::SelectingReplyShot' has a wrong offset!");
static_assert(offsetof(UDialogueNode_NPC, SpeakerID) == 0x000150, "Member 'UDialogueNode_NPC::SpeakerID' has a wrong offset!");

// Class Narrative.DialogueNode_Player
// 0x0038 (0x0180 - 0x0148)
class UDialogueNode_Player final : public UDialogueNode
{
public:
	class FText                                   OptionText;                                        // 0x0148(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   HintText;                                          // 0x0160(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bAutoSelect;                                       // 0x0178(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_179[0x7];                                      // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetHintText(class UDialogue* InDialogue) const;
	class FText GetOptionText(class UDialogue* InDialogue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogueNode_Player">();
	}
	static class UDialogueNode_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogueNode_Player>();
	}
};
static_assert(alignof(UDialogueNode_Player) == 0x000008, "Wrong alignment on UDialogueNode_Player");
static_assert(sizeof(UDialogueNode_Player) == 0x000180, "Wrong size on UDialogueNode_Player");
static_assert(offsetof(UDialogueNode_Player, OptionText) == 0x000148, "Member 'UDialogueNode_Player::OptionText' has a wrong offset!");
static_assert(offsetof(UDialogueNode_Player, HintText) == 0x000160, "Member 'UDialogueNode_Player::HintText' has a wrong offset!");
static_assert(offsetof(UDialogueNode_Player, bAutoSelect) == 0x000178, "Member 'UDialogueNode_Player::bAutoSelect' has a wrong offset!");

// Class Narrative.NarrativeComponent
// 0x0210 (0x02B0 - 0x00A0)
class UNarrativeComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class UNarrativeDataTask* NarrativeTask, const class FString& Name)> OnNarrativeDataTaskCompleted;                      // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UQuest* Quest, class UQuestBranch* Branch)> OnQuestBranchCompleted;                            // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UQuest* Quest, class UQuestState* NewState)> OnQuestNewState;                                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UQuest* Quest, class UNarrativeTask* ProgressedTask, class UQuestBranch* Branch, int32 OldProgress, int32 NewProgress)> OnQuestTaskProgressChanged;                        // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UQuest* Quest, class UNarrativeTask* CompletedTask, class UQuestBranch* Branch)> OnQuestTaskCompleted;                              // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UQuest* Quest, class FText& QuestSucceededMessage)> OnQuestSucceeded;                                  // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UQuest* Quest, class FText& QuestFailedMessage)> OnQuestFailed;                                     // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UQuest* Quest)> OnQuestStarted;                                    // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UQuest* Quest)> OnQuestForgotten;                                  // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UQuest* Quest)> OnQuestRestarted;                                  // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& SaveGameName)> OnBeginSave;                                       // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& SaveGameName)> OnSaveComplete;                                    // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& SaveGameName)> OnBeginLoad;                                       // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& SaveGameName)> OnLoadComplete;                                    // 0x0170(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UNarrativePartyComponent* NewParty, class UNarrativePartyComponent* LeftParty)> OnJoinedParty;                                     // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UNarrativePartyComponent* LeftParty)> OnLeaveParty;                                      // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDialogue* Dialogue)> OnDialogueBegan;                                   // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDialogue* Dialogue, bool bStartingNewDialogue)> OnDialogueFinished;                                // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDialogue* Dialogue, class UDialogueNode_Player* PlayerReply)> OnDialogueOptionSelected;                          // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDialogue* Dialogue, TArray<class UDialogueNode_Player*>& PlayerReplies)> OnDialogueRepliesAvailable;                        // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDialogue* Dialogue, class UDialogueNode_NPC* Node, struct FDialogueLine& DialogueLine, struct FSpeakerInfo& Speaker)> OnNPCDialogueLineStarted;                          // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDialogue* Dialogue, class UDialogueNode_NPC* Node, struct FDialogueLine& DialogueLine, struct FSpeakerInfo& Speaker)> OnNPCDialogueLineFinished;                         // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDialogue* Dialogue, class UDialogueNode_Player* Node, struct FDialogueLine& DialogueLine)> OnPlayerDialogueLineStarted;                       // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UDialogue* Dialogue, class UDialogueNode_Player* Node, struct FDialogueLine& DialogueLine)> OnPlayerDialogueLineFinished;                      // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FNarrativeUpdate>               PendingUpdateList;                                 // 0x0220(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<class UQuest*>                         QuestList;                                         // 0x0230(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UDialogue*                              CurrentDialogue;                                   // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    MasterTaskList;                                    // 0x0248(0x0050)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNarrativePartyComponent*               PartyComponent;                                    // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      OwnerPC;                                           // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool BeginDialogue(TSubclassOf<class UDialogue> Dialogue, const struct FDialoguePlayParams& PlayParams);
	void BeginLoad(const class FString& SaveName);
	class UQuest* BeginQuest(TSubclassOf<class UQuest> QuestClass, class FName StartFromID);
	void BeginSave(const class FString& SaveName);
	void ClientBeginDialogue(TSubclassOf<class UDialogue> Dialogue, const TArray<class FName>& NPCReplyChainIDs, const TArray<class FName>& AvailableResponseIDs);
	void ClientBeginPartyDialogue(TSubclassOf<class UDialogue> Dialogue, const TArray<class FName>& NPCReplyChainIDs, const TArray<class FName>& AvailableResponseIDs);
	void ClientExitDialogue();
	void ClientExitPartyDialogue();
	void ClientReceiveSave(const TArray<struct FNarrativeSavedQuest>& SavedQuests, const TArray<class FString>& Tasks, const TArray<int32>& Quantities);
	void ClientRecieveDialogueChunk(const TArray<class FName>& NPCReplyChainIDs, const TArray<class FName>& AvailableResponseIDs);
	void ClientSelectDialogueOption(const class FName& OptionID, class APlayerState* Selector);
	bool DeleteSave(const class FString& SaveName, const int32 Slot);
	void DialogueBegan(class UDialogue* Dialogue);
	void DialogueFinished(class UDialogue* Dialogue, const bool bStartingNewDialogue);
	void DialogueLineFinished(class UDialogue* Dialogue, class UDialogueNode* Node, const struct FDialogueLine& DialogueLine);
	void DialogueLineStarted(class UDialogue* Dialogue, class UDialogueNode* Node, const struct FDialogueLine& DialogueLine);
	void DialogueRepliesAvailable(class UDialogue* Dialogue, const TArray<class UDialogueNode_Player*>& PlayerReplies);
	bool ForgetQuest(TSubclassOf<class UQuest> QuestClass);
	int32 GetNumberOfTimesTaskWasCompleted(const class UNarrativeDataTask* Task, const class FString& Name_0);
	bool HasCompletedTask(const class UNarrativeDataTask* Task, const class FString& Name_0, const int32 Quantity);
	bool HasDialogueAvailable(TSubclassOf<class UDialogue> Dialogue, const struct FDialoguePlayParams& PlayParams);
	bool IsInDialogue();
	bool Load(const class FString& SaveName, const int32 Slot);
	void LoadComplete(const class FString& SaveName);
	void NarrativeDataTaskCompleted(const class UNarrativeDataTask* NarrativeTask, const class FString& Name_0);
	void OnRep_PartyComponent(class UNarrativePartyComponent* OldPartyComponent);
	void OnRep_PendingUpdateList();
	void QuestBranchCompleted(const class UQuest* Quest, const class UQuestBranch* Branch);
	void QuestFailed(const class UQuest* Quest, const class FText& QuestFailedMessage);
	void QuestForgotten(const class UQuest* Quest);
	void QuestNewState(class UQuest* Quest, const class UQuestState* NewState);
	void QuestStarted(const class UQuest* Quest);
	void QuestSucceeded(const class UQuest* Quest, const class FText& QuestSucceededMessage);
	void QuestTaskCompleted(const class UQuest* Quest, const class UNarrativeTask* Task, const class UQuestBranch* Branch);
	void QuestTaskProgressMade(const class UQuest* Quest, const class UNarrativeTask* Task, const class UQuestBranch* Branch, int32 OldProgress, int32 NewProgress);
	bool RestartQuest(TSubclassOf<class UQuest> QuestClass, class FName StartFromID);
	bool Save(const class FString& SaveName, const int32 Slot);
	void SaveComplete(const class FString& SaveName);
	void ServerSelectDialogueOption(const class FName& OptionID);
	void ServerTryExitDialogue();
	void ServerTrySkipCurrentDialogueLine();
	void TryExitDialogue();
	void TrySelectDialogueOption(class UDialogueNode_Player* Option);
	bool TrySkipCurrentDialogueLine();

	TArray<class UQuest*> GetAllQuests() const;
	class UDialogue* GetCurrentDialogue() const;
	TArray<class UQuest*> GetFailedQuests() const;
	TArray<class UQuest*> GetInProgressQuests() const;
	class APlayerController* GetOwningController() const;
	class APawn* GetOwningPawn() const;
	class UNarrativePartyComponent* GetParty() const;
	class UQuest* GetQuestInstance(TSubclassOf<class UQuest> QuestClass) const;
	TArray<class UQuest*> GetSucceededQuests() const;
	bool IsQuestFailed(TSubclassOf<class UQuest> QuestClass) const;
	bool IsQuestFinished(TSubclassOf<class UQuest> QuestClass) const;
	bool IsQuestInProgress(TSubclassOf<class UQuest> QuestClass) const;
	bool IsQuestStartedOrFinished(TSubclassOf<class UQuest> QuestClass) const;
	bool IsQuestSucceeded(TSubclassOf<class UQuest> QuestClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativeComponent">();
	}
	static class UNarrativeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNarrativeComponent>();
	}
};
static_assert(alignof(UNarrativeComponent) == 0x000008, "Wrong alignment on UNarrativeComponent");
static_assert(sizeof(UNarrativeComponent) == 0x0002B0, "Wrong size on UNarrativeComponent");
static_assert(offsetof(UNarrativeComponent, OnNarrativeDataTaskCompleted) == 0x0000A0, "Member 'UNarrativeComponent::OnNarrativeDataTaskCompleted' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnQuestBranchCompleted) == 0x0000B0, "Member 'UNarrativeComponent::OnQuestBranchCompleted' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnQuestNewState) == 0x0000C0, "Member 'UNarrativeComponent::OnQuestNewState' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnQuestTaskProgressChanged) == 0x0000D0, "Member 'UNarrativeComponent::OnQuestTaskProgressChanged' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnQuestTaskCompleted) == 0x0000E0, "Member 'UNarrativeComponent::OnQuestTaskCompleted' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnQuestSucceeded) == 0x0000F0, "Member 'UNarrativeComponent::OnQuestSucceeded' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnQuestFailed) == 0x000100, "Member 'UNarrativeComponent::OnQuestFailed' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnQuestStarted) == 0x000110, "Member 'UNarrativeComponent::OnQuestStarted' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnQuestForgotten) == 0x000120, "Member 'UNarrativeComponent::OnQuestForgotten' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnQuestRestarted) == 0x000130, "Member 'UNarrativeComponent::OnQuestRestarted' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnBeginSave) == 0x000140, "Member 'UNarrativeComponent::OnBeginSave' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnSaveComplete) == 0x000150, "Member 'UNarrativeComponent::OnSaveComplete' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnBeginLoad) == 0x000160, "Member 'UNarrativeComponent::OnBeginLoad' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnLoadComplete) == 0x000170, "Member 'UNarrativeComponent::OnLoadComplete' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnJoinedParty) == 0x000180, "Member 'UNarrativeComponent::OnJoinedParty' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnLeaveParty) == 0x000190, "Member 'UNarrativeComponent::OnLeaveParty' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnDialogueBegan) == 0x0001A0, "Member 'UNarrativeComponent::OnDialogueBegan' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnDialogueFinished) == 0x0001B0, "Member 'UNarrativeComponent::OnDialogueFinished' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnDialogueOptionSelected) == 0x0001C0, "Member 'UNarrativeComponent::OnDialogueOptionSelected' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnDialogueRepliesAvailable) == 0x0001D0, "Member 'UNarrativeComponent::OnDialogueRepliesAvailable' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnNPCDialogueLineStarted) == 0x0001E0, "Member 'UNarrativeComponent::OnNPCDialogueLineStarted' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnNPCDialogueLineFinished) == 0x0001F0, "Member 'UNarrativeComponent::OnNPCDialogueLineFinished' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnPlayerDialogueLineStarted) == 0x000200, "Member 'UNarrativeComponent::OnPlayerDialogueLineStarted' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OnPlayerDialogueLineFinished) == 0x000210, "Member 'UNarrativeComponent::OnPlayerDialogueLineFinished' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, PendingUpdateList) == 0x000220, "Member 'UNarrativeComponent::PendingUpdateList' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, QuestList) == 0x000230, "Member 'UNarrativeComponent::QuestList' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, CurrentDialogue) == 0x000240, "Member 'UNarrativeComponent::CurrentDialogue' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, MasterTaskList) == 0x000248, "Member 'UNarrativeComponent::MasterTaskList' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, PartyComponent) == 0x0002A0, "Member 'UNarrativeComponent::PartyComponent' has a wrong offset!");
static_assert(offsetof(UNarrativeComponent, OwnerPC) == 0x0002A8, "Member 'UNarrativeComponent::OwnerPC' has a wrong offset!");

// Class Narrative.NarrativeCondition
// 0x0008 (0x0030 - 0x0028)
class UNarrativeCondition : public UObject
{
public:
	bool                                          bNot;                                              // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EPartyConditionPolicy                         PartyConditionPolicy;                              // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool CheckCondition(class APawn* Pawn, class APlayerController* Controller, class UNarrativeComponent* NarrativeComponent);
	class FString GetGraphDisplayText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativeCondition">();
	}
	static class UNarrativeCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNarrativeCondition>();
	}
};
static_assert(alignof(UNarrativeCondition) == 0x000008, "Wrong alignment on UNarrativeCondition");
static_assert(sizeof(UNarrativeCondition) == 0x000030, "Wrong size on UNarrativeCondition");
static_assert(offsetof(UNarrativeCondition, bNot) == 0x000028, "Member 'UNarrativeCondition::bNot' has a wrong offset!");
static_assert(offsetof(UNarrativeCondition, PartyConditionPolicy) == 0x00002C, "Member 'UNarrativeCondition::PartyConditionPolicy' has a wrong offset!");

// Class Narrative.NarrativeDataTask
// 0x0058 (0x0088 - 0x0030)
class UNarrativeDataTask final : public UDataAsset
{
public:
	class FString                                 TaskName;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TaskDescription;                                   // 0x0040(0x0018)(Edit, NativeAccessSpecifierPublic)
	class FString                                 ArgumentName;                                      // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TaskCategory;                                      // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DefaultArgument;                                   // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativeDataTask">();
	}
	static class UNarrativeDataTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNarrativeDataTask>();
	}
};
static_assert(alignof(UNarrativeDataTask) == 0x000008, "Wrong alignment on UNarrativeDataTask");
static_assert(sizeof(UNarrativeDataTask) == 0x000088, "Wrong size on UNarrativeDataTask");
static_assert(offsetof(UNarrativeDataTask, TaskName) == 0x000030, "Member 'UNarrativeDataTask::TaskName' has a wrong offset!");
static_assert(offsetof(UNarrativeDataTask, TaskDescription) == 0x000040, "Member 'UNarrativeDataTask::TaskDescription' has a wrong offset!");
static_assert(offsetof(UNarrativeDataTask, ArgumentName) == 0x000058, "Member 'UNarrativeDataTask::ArgumentName' has a wrong offset!");
static_assert(offsetof(UNarrativeDataTask, TaskCategory) == 0x000068, "Member 'UNarrativeDataTask::TaskCategory' has a wrong offset!");
static_assert(offsetof(UNarrativeDataTask, DefaultArgument) == 0x000078, "Member 'UNarrativeDataTask::DefaultArgument' has a wrong offset!");

// Class Narrative.NarrativeDefaultCinecam
// 0x0000 (0x0A20 - 0x0A20)
class ANarrativeDefaultCinecam final : public ACineCameraActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativeDefaultCinecam">();
	}
	static class ANarrativeDefaultCinecam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANarrativeDefaultCinecam>();
	}
};
static_assert(alignof(ANarrativeDefaultCinecam) == 0x000010, "Wrong alignment on ANarrativeDefaultCinecam");
static_assert(sizeof(ANarrativeDefaultCinecam) == 0x000A20, "Wrong size on ANarrativeDefaultCinecam");

// Class Narrative.NarrativeDialogueSequence
// 0x0130 (0x0158 - 0x0028)
class UNarrativeDialogueSequence final : public UObject
{
public:
	class FText                                   FriendlyShotName;                                  // 0x0028(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class ULevelSequence*>                 SequenceAssets;                                    // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FMovieSceneSequencePlaybackSettings    PlaybackSettings;                                  // 0x0050(0x0020)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPlateCropSettings                     CropSettings;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bShouldRestart : 1;                                // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAnchorOriginRule                             AnchorOriginRule;                                  // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AnchorOriginNudge;                                 // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnchorRotationRule                           AnchorRotationRule;                                // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnchorAvatarCustomID;                              // 0x009C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUse180DegreeRule;                                 // 0x00A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnitsY180DegreeRule;                               // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DegreesYaw180DegreeRule;                           // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FShotTrackingSettings                  LookatTrackingSettings;                            // 0x00B0(0x0030)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FShotTrackingSettings                  FocusTrackingSettings;                             // 0x00E0(0x0030)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDrawDebugFocusPoint;                              // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  Speaker;                                           // 0x0114(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  Listener;                                          // 0x011C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  AnchorActor;                                       // 0x0124(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  LookAtActor;                                       // 0x012C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  FocusActor;                                        // 0x0134(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ALevelSequenceActor>     SequenceActor;                                     // 0x013C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class ACineCameraActor>        Cinecam;                                           // 0x0144(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UDialogue>               Dialogue;                                          // 0x014C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndSequence();
	class FText GetGraphDisplayText();
	struct FTransform GetShotAnchorTransform();
	void OnStop();
	void PlaySequence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativeDialogueSequence">();
	}
	static class UNarrativeDialogueSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNarrativeDialogueSequence>();
	}
};
static_assert(alignof(UNarrativeDialogueSequence) == 0x000008, "Wrong alignment on UNarrativeDialogueSequence");
static_assert(sizeof(UNarrativeDialogueSequence) == 0x000158, "Wrong size on UNarrativeDialogueSequence");
static_assert(offsetof(UNarrativeDialogueSequence, FriendlyShotName) == 0x000028, "Member 'UNarrativeDialogueSequence::FriendlyShotName' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, SequenceAssets) == 0x000040, "Member 'UNarrativeDialogueSequence::SequenceAssets' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, PlaybackSettings) == 0x000050, "Member 'UNarrativeDialogueSequence::PlaybackSettings' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, CropSettings) == 0x000070, "Member 'UNarrativeDialogueSequence::CropSettings' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, AnchorOriginRule) == 0x000078, "Member 'UNarrativeDialogueSequence::AnchorOriginRule' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, AnchorOriginNudge) == 0x000080, "Member 'UNarrativeDialogueSequence::AnchorOriginNudge' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, AnchorRotationRule) == 0x000098, "Member 'UNarrativeDialogueSequence::AnchorRotationRule' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, AnchorAvatarCustomID) == 0x00009C, "Member 'UNarrativeDialogueSequence::AnchorAvatarCustomID' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, bUse180DegreeRule) == 0x0000A4, "Member 'UNarrativeDialogueSequence::bUse180DegreeRule' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, UnitsY180DegreeRule) == 0x0000A8, "Member 'UNarrativeDialogueSequence::UnitsY180DegreeRule' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, DegreesYaw180DegreeRule) == 0x0000AC, "Member 'UNarrativeDialogueSequence::DegreesYaw180DegreeRule' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, LookatTrackingSettings) == 0x0000B0, "Member 'UNarrativeDialogueSequence::LookatTrackingSettings' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, FocusTrackingSettings) == 0x0000E0, "Member 'UNarrativeDialogueSequence::FocusTrackingSettings' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, bDrawDebugFocusPoint) == 0x000110, "Member 'UNarrativeDialogueSequence::bDrawDebugFocusPoint' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, Speaker) == 0x000114, "Member 'UNarrativeDialogueSequence::Speaker' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, Listener) == 0x00011C, "Member 'UNarrativeDialogueSequence::Listener' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, AnchorActor) == 0x000124, "Member 'UNarrativeDialogueSequence::AnchorActor' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, LookAtActor) == 0x00012C, "Member 'UNarrativeDialogueSequence::LookAtActor' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, FocusActor) == 0x000134, "Member 'UNarrativeDialogueSequence::FocusActor' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, SequenceActor) == 0x00013C, "Member 'UNarrativeDialogueSequence::SequenceActor' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, Cinecam) == 0x000144, "Member 'UNarrativeDialogueSequence::Cinecam' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSequence, Dialogue) == 0x00014C, "Member 'UNarrativeDialogueSequence::Dialogue' has a wrong offset!");

// Class Narrative.NarrativeDialogueSettings
// 0x0020 (0x0048 - 0x0028)
class UNarrativeDialogueSettings final : public UObject
{
public:
	float                                         DialogueLineAudioSilence;                          // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDialogueTextDisplayTime;                        // 0x002C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LettersPerSecondLineDuration;                      // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSelectSingleResponse;                         // 0x0034(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableVerticalWiring;                             // 0x0035(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   SpeakerColors;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativeDialogueSettings">();
	}
	static class UNarrativeDialogueSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNarrativeDialogueSettings>();
	}
};
static_assert(alignof(UNarrativeDialogueSettings) == 0x000008, "Wrong alignment on UNarrativeDialogueSettings");
static_assert(sizeof(UNarrativeDialogueSettings) == 0x000048, "Wrong size on UNarrativeDialogueSettings");
static_assert(offsetof(UNarrativeDialogueSettings, DialogueLineAudioSilence) == 0x000028, "Member 'UNarrativeDialogueSettings::DialogueLineAudioSilence' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSettings, MinDialogueTextDisplayTime) == 0x00002C, "Member 'UNarrativeDialogueSettings::MinDialogueTextDisplayTime' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSettings, LettersPerSecondLineDuration) == 0x000030, "Member 'UNarrativeDialogueSettings::LettersPerSecondLineDuration' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSettings, bAutoSelectSingleResponse) == 0x000034, "Member 'UNarrativeDialogueSettings::bAutoSelectSingleResponse' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSettings, bEnableVerticalWiring) == 0x000035, "Member 'UNarrativeDialogueSettings::bEnableVerticalWiring' has a wrong offset!");
static_assert(offsetof(UNarrativeDialogueSettings, SpeakerColors) == 0x000038, "Member 'UNarrativeDialogueSettings::SpeakerColors' has a wrong offset!");

// Class Narrative.NarrativeEvent
// 0x0008 (0x0030 - 0x0028)
class UNarrativeEvent : public UObject
{
public:
	bool                                          bRefireOnLoad;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEventRuntime                                 EventRuntime;                                      // 0x0029(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EPartyEventPolicy                             PartyEventPolicy;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ExecuteEvent(class APawn* Pawn, class APlayerController* Controller, class UNarrativeComponent* NarrativeComponent);
	class FString GetGraphDisplayText();
	class FText GetHintText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativeEvent">();
	}
	static class UNarrativeEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNarrativeEvent>();
	}
};
static_assert(alignof(UNarrativeEvent) == 0x000008, "Wrong alignment on UNarrativeEvent");
static_assert(sizeof(UNarrativeEvent) == 0x000030, "Wrong size on UNarrativeEvent");
static_assert(offsetof(UNarrativeEvent, bRefireOnLoad) == 0x000028, "Member 'UNarrativeEvent::bRefireOnLoad' has a wrong offset!");
static_assert(offsetof(UNarrativeEvent, EventRuntime) == 0x000029, "Member 'UNarrativeEvent::EventRuntime' has a wrong offset!");
static_assert(offsetof(UNarrativeEvent, PartyEventPolicy) == 0x00002C, "Member 'UNarrativeEvent::PartyEventPolicy' has a wrong offset!");

// Class Narrative.NarrativeFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UNarrativeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CompleteLooseNarrativeDataTask(class UNarrativeComponent* Target, const class FString& Argument, const int32 Quantity);
	static bool CompleteNarrativeDataTask(class UNarrativeComponent* Target, const class UNarrativeDataTask* Task, const class FString& Argument, const int32 Quantity);
	static class UNarrativeComponent* GetNarrativeComponent(const class UObject* WorldContextObject);
	static class UNarrativeComponent* GetNarrativeComponentFromTarget(class AActor* Target);
	static class UNarrativeDataTask* GetTaskByName(const class UObject* WorldContextObject, const class FString& EventName);
	static class FString MakeDisplayString(const class FString& String);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativeFunctionLibrary">();
	}
	static class UNarrativeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNarrativeFunctionLibrary>();
	}
};
static_assert(alignof(UNarrativeFunctionLibrary) == 0x000008, "Wrong alignment on UNarrativeFunctionLibrary");
static_assert(sizeof(UNarrativeFunctionLibrary) == 0x000028, "Wrong size on UNarrativeFunctionLibrary");

// Class Narrative.NarrativePartyComponent
// 0x0028 (0x02D8 - 0x02B0)
class UNarrativePartyComponent final : public UNarrativeComponent
{
public:
	EPartyDialogueControlPolicy                   PartyDialogueControlPolicy;                        // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNarrativeComponent*>            PartyMembers;                                      // 0x02B8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class APlayerState*>                   PartyMemberStates;                                 // 0x02C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	bool AddPartyMember(class UNarrativeComponent* Member);
	bool IsPartyLeader(class APlayerState* Member);
	bool RemovePartyMember(class UNarrativeComponent* Member);

	class UNarrativeComponent* GetPartyLeader() const;
	TArray<class UNarrativeComponent*> GetPartyMembers() const;
	TArray<class APlayerState*> GetPartyMemberStates() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativePartyComponent">();
	}
	static class UNarrativePartyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNarrativePartyComponent>();
	}
};
static_assert(alignof(UNarrativePartyComponent) == 0x000008, "Wrong alignment on UNarrativePartyComponent");
static_assert(sizeof(UNarrativePartyComponent) == 0x0002D8, "Wrong size on UNarrativePartyComponent");
static_assert(offsetof(UNarrativePartyComponent, PartyDialogueControlPolicy) == 0x0002B0, "Member 'UNarrativePartyComponent::PartyDialogueControlPolicy' has a wrong offset!");
static_assert(offsetof(UNarrativePartyComponent, PartyMembers) == 0x0002B8, "Member 'UNarrativePartyComponent::PartyMembers' has a wrong offset!");
static_assert(offsetof(UNarrativePartyComponent, PartyMemberStates) == 0x0002C8, "Member 'UNarrativePartyComponent::PartyMemberStates' has a wrong offset!");

// Class Narrative.NarrativeQuestSettings
// 0x0008 (0x0030 - 0x0028)
class UNarrativeQuestSettings final : public UObject
{
public:
	bool                                          bResetTasksWhenCompleted;                          // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativeQuestSettings">();
	}
	static class UNarrativeQuestSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNarrativeQuestSettings>();
	}
};
static_assert(alignof(UNarrativeQuestSettings) == 0x000008, "Wrong alignment on UNarrativeQuestSettings");
static_assert(sizeof(UNarrativeQuestSettings) == 0x000030, "Wrong size on UNarrativeQuestSettings");
static_assert(offsetof(UNarrativeQuestSettings, bResetTasksWhenCompleted) == 0x000028, "Member 'UNarrativeQuestSettings::bResetTasksWhenCompleted' has a wrong offset!");

// Class Narrative.NarrativeSaveGame
// 0x0060 (0x0088 - 0x0028)
class UNarrativeSaveGame final : public USaveGame
{
public:
	TArray<struct FNarrativeSavedQuest>           SavedQuests;                                       // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    MasterTaskList;                                    // 0x0038(0x0050)(Edit, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativeSaveGame">();
	}
	static class UNarrativeSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNarrativeSaveGame>();
	}
};
static_assert(alignof(UNarrativeSaveGame) == 0x000008, "Wrong alignment on UNarrativeSaveGame");
static_assert(sizeof(UNarrativeSaveGame) == 0x000088, "Wrong size on UNarrativeSaveGame");
static_assert(offsetof(UNarrativeSaveGame, SavedQuests) == 0x000028, "Member 'UNarrativeSaveGame::SavedQuests' has a wrong offset!");
static_assert(offsetof(UNarrativeSaveGame, MasterTaskList) == 0x000038, "Member 'UNarrativeSaveGame::MasterTaskList' has a wrong offset!");

// Class Narrative.NarrativeTaskManager
// 0x0050 (0x0080 - 0x0030)
class UNarrativeTaskManager final : public UGameInstanceSubsystem
{
public:
	TMap<class FString, class UNarrativeDataTask*> NarrativeTaskMap;                                  // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativeTaskManager">();
	}
	static class UNarrativeTaskManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNarrativeTaskManager>();
	}
};
static_assert(alignof(UNarrativeTaskManager) == 0x000008, "Wrong alignment on UNarrativeTaskManager");
static_assert(sizeof(UNarrativeTaskManager) == 0x000080, "Wrong size on UNarrativeTaskManager");
static_assert(offsetof(UNarrativeTaskManager, NarrativeTaskMap) == 0x000030, "Member 'UNarrativeTaskManager::NarrativeTaskMap' has a wrong offset!");

// Class Narrative.Quest
// 0x0148 (0x0170 - 0x0028)
class UQuest : public UObject
{
public:
	class UQuestState*                            CurrentState;                                      // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   QuestName;                                         // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   QuestDescription;                                  // 0x0048(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bSaveQuest;                                        // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTracked;                                          // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UQuestState*>                    InheritableStates;                                 // 0x0068(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EQuestCompletion                              QuestCompletion;                                   // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UQuestState*                            QuestStartState;                                   // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UQuestState*>                    States;                                            // 0x0088(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UQuestBranch*>                   Branches;                                          // 0x0098(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         QuestActors;                                       // 0x00A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UQuestState*>                    ReachedStates;                                     // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UNarrativeComponent*                    OwningComp;                                        // 0x00C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APawn*                                  OwningPawn;                                        // 0x00D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      OwningController;                                  // 0x00D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UQuest* Quest, class UQuestBranch* Branch)> QuestBranchCompleted;                              // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UQuest* Quest, class UQuestState* NewState)> QuestNewState;                                     // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UQuest* Quest, class UNarrativeTask* ProgressedTask, class UQuestBranch* Branch, int32 OldProgress, int32 NewProgress)> QuestTaskProgressChanged;                          // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UQuest* Quest, class UNarrativeTask* CompletedTask, class UQuestBranch* Branch)> QuestTaskCompleted;                                // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UQuest* Quest, class FText& QuestSucceededMessage)> QuestSucceeded;                                    // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UQuest* Quest, class FText& QuestFailedMessage)> QuestFailed;                                       // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UQuest* Quest)> QuestStarted;                                      // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UQuest* Quest)> QuestForgotten;                                    // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	TMulticastInlineDelegate<void(class UQuest* Quest)> QuestRestarted;                                    // 0x0160(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void BPOnQuestBranchCompleted(const class UQuest* Quest, const class UQuestBranch* Branch);
	void BPOnQuestFailed(const class UQuest* Quest, const class FText& QuestFailedMessage);
	void BPOnQuestNewState(class UQuest* Quest, const class UQuestState* NewState);
	void BPOnQuestStarted(const class UQuest* Quest);
	void BPOnQuestSucceeded(const class UQuest* Quest, const class FText& QuestSucceededMessage);
	void BPOnQuestTaskCompleted(const class UQuest* Quest, const class UNarrativeTask* Task, const class UQuestBranch* Step);
	void BPOnQuestTaskProgressChanged(const class UQuest* Quest, const class UNarrativeTask* Task, const class UQuestBranch* Step, int32 CurrentProgress, int32 RequiredProgress);
	void BPOnTrackedChanged(const class UQuest* Quest, const bool bNewTracked);
	void BPPreQuestStarted(const class UQuest* Quest);
	void EnterState(class UQuestState* NewState);
	void FailQuest(const class FText& QuestFailedMessage);
	void OnQuestBranchCompleted(const class UQuestBranch* Branch);
	void OnQuestTaskCompleted(const class UNarrativeTask* Task, const class UQuestBranch* Branch);
	void OnQuestTaskProgressChanged(const class UNarrativeTask* Task, const class UQuestBranch* Step, int32 CurrentProgress, int32 RequiredProgress);
	void SetQuestDescription(const class FText& NewDescription);
	void SetQuestName(const class FText& NewName);
	void SetTracked(const bool bNewTracked);
	class AActor* SpawnQuestActor(TSubclassOf<class AActor> ActorClass, const struct FTransform& ActorTransform);
	void SucceedQuest(const class FText& QuestSucceededMessage);

	class UQuestBranch* GetBranch(class FName ID) const;
	TArray<class UQuestBranch*> GetBranches() const;
	TArray<class APlayerController*> GetGroupMembers() const;
	TArray<class UQuestNode*> GetNodes() const;
	class UNarrativeComponent* GetOwningComp() const;
	class APlayerController* GetOwningController() const;
	class APawn* GetOwningPawn() const;
	EQuestCompletion GetQuestCompletion() const;
	class FText GetQuestDescription() const;
	class FText GetQuestName() const;
	class UQuestState* GetQuestStartState() const;
	class UQuestState* GetState(class FName ID) const;
	TArray<class UQuestState*> GetStates() const;
	bool IsTracked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Quest">();
	}
	static class UQuest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuest>();
	}
};
static_assert(alignof(UQuest) == 0x000008, "Wrong alignment on UQuest");
static_assert(sizeof(UQuest) == 0x000170, "Wrong size on UQuest");
static_assert(offsetof(UQuest, CurrentState) == 0x000028, "Member 'UQuest::CurrentState' has a wrong offset!");
static_assert(offsetof(UQuest, QuestName) == 0x000030, "Member 'UQuest::QuestName' has a wrong offset!");
static_assert(offsetof(UQuest, QuestDescription) == 0x000048, "Member 'UQuest::QuestDescription' has a wrong offset!");
static_assert(offsetof(UQuest, bSaveQuest) == 0x000060, "Member 'UQuest::bSaveQuest' has a wrong offset!");
static_assert(offsetof(UQuest, bTracked) == 0x000061, "Member 'UQuest::bTracked' has a wrong offset!");
static_assert(offsetof(UQuest, InheritableStates) == 0x000068, "Member 'UQuest::InheritableStates' has a wrong offset!");
static_assert(offsetof(UQuest, QuestCompletion) == 0x000078, "Member 'UQuest::QuestCompletion' has a wrong offset!");
static_assert(offsetof(UQuest, QuestStartState) == 0x000080, "Member 'UQuest::QuestStartState' has a wrong offset!");
static_assert(offsetof(UQuest, States) == 0x000088, "Member 'UQuest::States' has a wrong offset!");
static_assert(offsetof(UQuest, Branches) == 0x000098, "Member 'UQuest::Branches' has a wrong offset!");
static_assert(offsetof(UQuest, QuestActors) == 0x0000A8, "Member 'UQuest::QuestActors' has a wrong offset!");
static_assert(offsetof(UQuest, ReachedStates) == 0x0000B8, "Member 'UQuest::ReachedStates' has a wrong offset!");
static_assert(offsetof(UQuest, OwningComp) == 0x0000C8, "Member 'UQuest::OwningComp' has a wrong offset!");
static_assert(offsetof(UQuest, OwningPawn) == 0x0000D0, "Member 'UQuest::OwningPawn' has a wrong offset!");
static_assert(offsetof(UQuest, OwningController) == 0x0000D8, "Member 'UQuest::OwningController' has a wrong offset!");
static_assert(offsetof(UQuest, QuestBranchCompleted) == 0x0000E0, "Member 'UQuest::QuestBranchCompleted' has a wrong offset!");
static_assert(offsetof(UQuest, QuestNewState) == 0x0000F0, "Member 'UQuest::QuestNewState' has a wrong offset!");
static_assert(offsetof(UQuest, QuestTaskProgressChanged) == 0x000100, "Member 'UQuest::QuestTaskProgressChanged' has a wrong offset!");
static_assert(offsetof(UQuest, QuestTaskCompleted) == 0x000110, "Member 'UQuest::QuestTaskCompleted' has a wrong offset!");
static_assert(offsetof(UQuest, QuestSucceeded) == 0x000120, "Member 'UQuest::QuestSucceeded' has a wrong offset!");
static_assert(offsetof(UQuest, QuestFailed) == 0x000130, "Member 'UQuest::QuestFailed' has a wrong offset!");
static_assert(offsetof(UQuest, QuestStarted) == 0x000140, "Member 'UQuest::QuestStarted' has a wrong offset!");
static_assert(offsetof(UQuest, QuestForgotten) == 0x000150, "Member 'UQuest::QuestForgotten' has a wrong offset!");
static_assert(offsetof(UQuest, QuestRestarted) == 0x000160, "Member 'UQuest::QuestRestarted' has a wrong offset!");

// Class Narrative.QuestBlueprintGeneratedClass
// 0x0008 (0x0370 - 0x0368)
class UQuestBlueprintGeneratedClass final : public UBlueprintGeneratedClass
{
public:
	class UQuest*                                 QuestTemplate;                                     // 0x0368(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestBlueprintGeneratedClass">();
	}
	static class UQuestBlueprintGeneratedClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestBlueprintGeneratedClass>();
	}
};
static_assert(alignof(UQuestBlueprintGeneratedClass) == 0x000008, "Wrong alignment on UQuestBlueprintGeneratedClass");
static_assert(sizeof(UQuestBlueprintGeneratedClass) == 0x000370, "Wrong size on UQuestBlueprintGeneratedClass");
static_assert(offsetof(UQuestBlueprintGeneratedClass, QuestTemplate) == 0x000368, "Member 'UQuestBlueprintGeneratedClass::QuestTemplate' has a wrong offset!");

// Class Narrative.QuestNode
// 0x0028 (0x0088 - 0x0060)
class UQuestNode : public UNarrativeNodeBase
{
public:
	class FText                                   Description;                                       // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   OnEnteredFuncName;                                 // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UQuest*                                 OwningQuest;                                       // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestNode">();
	}
	static class UQuestNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestNode>();
	}
};
static_assert(alignof(UQuestNode) == 0x000008, "Wrong alignment on UQuestNode");
static_assert(sizeof(UQuestNode) == 0x000088, "Wrong size on UQuestNode");
static_assert(offsetof(UQuestNode, Description) == 0x000060, "Member 'UQuestNode::Description' has a wrong offset!");
static_assert(offsetof(UQuestNode, OnEnteredFuncName) == 0x000078, "Member 'UQuestNode::OnEnteredFuncName' has a wrong offset!");
static_assert(offsetof(UQuestNode, OwningQuest) == 0x000080, "Member 'UQuestNode::OwningQuest' has a wrong offset!");

// Class Narrative.QuestState
// 0x0018 (0x00A0 - 0x0088)
class UQuestState final : public UQuestNode
{
public:
	TArray<class UQuestBranch*>                   Branches;                                          // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EStateNodeType                                StateNodeType;                                     // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestState">();
	}
	static class UQuestState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestState>();
	}
};
static_assert(alignof(UQuestState) == 0x000008, "Wrong alignment on UQuestState");
static_assert(sizeof(UQuestState) == 0x0000A0, "Wrong size on UQuestState");
static_assert(offsetof(UQuestState, Branches) == 0x000088, "Member 'UQuestState::Branches' has a wrong offset!");
static_assert(offsetof(UQuestState, StateNodeType) == 0x000098, "Member 'UQuestState::StateNodeType' has a wrong offset!");

// Class Narrative.QuestBranch
// 0x0020 (0x00A8 - 0x0088)
class UQuestBranch final : public UQuestNode
{
public:
	TArray<class UNarrativeTask*>                 QuestTasks;                                        // 0x0088(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UQuestState*                            DestinationState;                                  // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"QuestBranch">();
	}
	static class UQuestBranch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UQuestBranch>();
	}
};
static_assert(alignof(UQuestBranch) == 0x000008, "Wrong alignment on UQuestBranch");
static_assert(sizeof(UQuestBranch) == 0x0000A8, "Wrong size on UQuestBranch");
static_assert(offsetof(UQuestBranch, QuestTasks) == 0x000088, "Member 'UQuestBranch::QuestTasks' has a wrong offset!");
static_assert(offsetof(UQuestBranch, bHidden) == 0x000098, "Member 'UQuestBranch::bHidden' has a wrong offset!");
static_assert(offsetof(UQuestBranch, DestinationState) == 0x0000A0, "Member 'UQuestBranch::DestinationState' has a wrong offset!");

// Class Narrative.NarrativeTask
// 0x0060 (0x0088 - 0x0028)
class UNarrativeTask : public UObject
{
public:
	int32                                         RequiredQuantity;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DescriptionOverride;                               // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bOptional;                                         // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TickInterval;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentProgress;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNarrativeComponent*                    OwningComp;                                        // 0x0058(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APawn*                                  OwningPawn;                                        // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerController*                      OwningController;                                  // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UQuest*                                 OwningQuest;                                       // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddProgress(const int32 ProgressToAdd);
	void CompleteTask();
	void K2_BeginTask();
	void K2_EndTask();
	void K2_OnTaskCompleted();
	void SetProgress(const int32 NewProgress);
	void TickTask();

	class UQuestBranch* GetOwningBranch() const;
	class FText GetTaskDescription() const;
	class FText GetTaskNodeDescription() const;
	class FText GetTaskProgressText() const;
	bool IsComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NarrativeTask">();
	}
	static class UNarrativeTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNarrativeTask>();
	}
};
static_assert(alignof(UNarrativeTask) == 0x000008, "Wrong alignment on UNarrativeTask");
static_assert(sizeof(UNarrativeTask) == 0x000088, "Wrong size on UNarrativeTask");
static_assert(offsetof(UNarrativeTask, RequiredQuantity) == 0x000028, "Member 'UNarrativeTask::RequiredQuantity' has a wrong offset!");
static_assert(offsetof(UNarrativeTask, DescriptionOverride) == 0x000030, "Member 'UNarrativeTask::DescriptionOverride' has a wrong offset!");
static_assert(offsetof(UNarrativeTask, bOptional) == 0x000048, "Member 'UNarrativeTask::bOptional' has a wrong offset!");
static_assert(offsetof(UNarrativeTask, bHidden) == 0x000049, "Member 'UNarrativeTask::bHidden' has a wrong offset!");
static_assert(offsetof(UNarrativeTask, TickInterval) == 0x00004C, "Member 'UNarrativeTask::TickInterval' has a wrong offset!");
static_assert(offsetof(UNarrativeTask, CurrentProgress) == 0x000050, "Member 'UNarrativeTask::CurrentProgress' has a wrong offset!");
static_assert(offsetof(UNarrativeTask, OwningComp) == 0x000058, "Member 'UNarrativeTask::OwningComp' has a wrong offset!");
static_assert(offsetof(UNarrativeTask, OwningPawn) == 0x000060, "Member 'UNarrativeTask::OwningPawn' has a wrong offset!");
static_assert(offsetof(UNarrativeTask, OwningController) == 0x000068, "Member 'UNarrativeTask::OwningController' has a wrong offset!");
static_assert(offsetof(UNarrativeTask, OwningQuest) == 0x000070, "Member 'UNarrativeTask::OwningQuest' has a wrong offset!");

}

