#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: EasyMultiSave

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "EasyMultiSave_structs.hpp"


namespace SDK
{

// Class EasyMultiSave.EMSActorSaveInterface
// 0x0000 (0x0028 - 0x0028)
class IEMSActorSaveInterface final : public IInterface
{
public:
	void ActorLoaded();
	void ActorPreLoad();
	void ActorPreSave();
	void ActorSaved();
	void ComponentsToSave(TArray<class UActorComponent*>* Components);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EMSActorSaveInterface">();
	}
	static class IEMSActorSaveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEMSActorSaveInterface>();
	}
};
static_assert(alignof(IEMSActorSaveInterface) == 0x000008, "Wrong alignment on IEMSActorSaveInterface");
static_assert(sizeof(IEMSActorSaveInterface) == 0x000028, "Wrong size on IEMSActorSaveInterface");

// Class EasyMultiSave.EMSAsyncCheck
// 0x0048 (0x0078 - 0x0030)
class UEMSAsyncCheck final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UEMSObject*                             EMS;                                               // 0x0050(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UEMSAsyncCheck* CheckSaveFiles(class UObject* WorldContextObject, ESaveFileCheckType CheckType, const class FString& CustomSaveName, bool bCompareGameVersion);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EMSAsyncCheck">();
	}
	static class UEMSAsyncCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEMSAsyncCheck>();
	}
};
static_assert(alignof(UEMSAsyncCheck) == 0x000008, "Wrong alignment on UEMSAsyncCheck");
static_assert(sizeof(UEMSAsyncCheck) == 0x000078, "Wrong size on UEMSAsyncCheck");
static_assert(offsetof(UEMSAsyncCheck, OnCompleted) == 0x000030, "Member 'UEMSAsyncCheck::OnCompleted' has a wrong offset!");
static_assert(offsetof(UEMSAsyncCheck, OnFailed) == 0x000040, "Member 'UEMSAsyncCheck::OnFailed' has a wrong offset!");
static_assert(offsetof(UEMSAsyncCheck, EMS) == 0x000050, "Member 'UEMSAsyncCheck::EMS' has a wrong offset!");

// Class EasyMultiSave.EMSAsyncLoadGame
// 0x0058 (0x0088 - 0x0030)
class UEMSAsyncLoadGame final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEMSObject*                             EMS;                                               // 0x0058(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x28];                                      // 0x0060(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UEMSAsyncLoadGame* AsyncLoadActors(class UObject* WorldContextObject, int32 Data, bool bFullReload);
	static void AutoLoadLevelActors(class UEMSObject* EMSObject);
	static void FinishTaskThreadSafe(const TWeakObjectPtr<class UEMSAsyncLoadGame> InTask);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EMSAsyncLoadGame">();
	}
	static class UEMSAsyncLoadGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEMSAsyncLoadGame>();
	}
};
static_assert(alignof(UEMSAsyncLoadGame) == 0x000008, "Wrong alignment on UEMSAsyncLoadGame");
static_assert(sizeof(UEMSAsyncLoadGame) == 0x000088, "Wrong size on UEMSAsyncLoadGame");
static_assert(offsetof(UEMSAsyncLoadGame, OnCompleted) == 0x000030, "Member 'UEMSAsyncLoadGame::OnCompleted' has a wrong offset!");
static_assert(offsetof(UEMSAsyncLoadGame, OnFailed) == 0x000040, "Member 'UEMSAsyncLoadGame::OnFailed' has a wrong offset!");
static_assert(offsetof(UEMSAsyncLoadGame, EMS) == 0x000058, "Member 'UEMSAsyncLoadGame::EMS' has a wrong offset!");

// Class EasyMultiSave.EMSAsyncSaveGame
// 0x0038 (0x0068 - 0x0030)
class UEMSAsyncSaveGame final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEMSObject*                             EMS;                                               // 0x0058(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UEMSAsyncSaveGame* AsyncSaveActors(class UObject* WorldContextObject, int32 Data);
	static void AutoSaveLevelActors(class UEMSObject* EMSObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EMSAsyncSaveGame">();
	}
	static class UEMSAsyncSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEMSAsyncSaveGame>();
	}
};
static_assert(alignof(UEMSAsyncSaveGame) == 0x000008, "Wrong alignment on UEMSAsyncSaveGame");
static_assert(sizeof(UEMSAsyncSaveGame) == 0x000068, "Wrong size on UEMSAsyncSaveGame");
static_assert(offsetof(UEMSAsyncSaveGame, OnCompleted) == 0x000030, "Member 'UEMSAsyncSaveGame::OnCompleted' has a wrong offset!");
static_assert(offsetof(UEMSAsyncSaveGame, OnFailed) == 0x000040, "Member 'UEMSAsyncSaveGame::OnFailed' has a wrong offset!");
static_assert(offsetof(UEMSAsyncSaveGame, EMS) == 0x000058, "Member 'UEMSAsyncSaveGame::EMS' has a wrong offset!");

// Class EasyMultiSave.EMSAsyncStream
// 0x0100 (0x0130 - 0x0030)
class UEMSAsyncStream final : public UBlueprintAsyncActionBase
{
public:
	class ULevel*                                 StreamingLevel;                                    // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEMSObject*                             EMS;                                               // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         StreamActors;                                      // 0x0048(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class FName, TWeakObjectPtr<class AActor>> StreamActorsMap;                                   // 0x0058(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FMultiLevelStreamingData               PrunedData;                                        // 0x00A8(0x0070)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x18];                                     // 0x0118(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool InitStreamingLoadTask(class UEMSObject* EMSObject, class ULevel* InLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EMSAsyncStream">();
	}
	static class UEMSAsyncStream* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEMSAsyncStream>();
	}
};
static_assert(alignof(UEMSAsyncStream) == 0x000008, "Wrong alignment on UEMSAsyncStream");
static_assert(sizeof(UEMSAsyncStream) == 0x000130, "Wrong size on UEMSAsyncStream");
static_assert(offsetof(UEMSAsyncStream, StreamingLevel) == 0x000030, "Member 'UEMSAsyncStream::StreamingLevel' has a wrong offset!");
static_assert(offsetof(UEMSAsyncStream, EMS) == 0x000040, "Member 'UEMSAsyncStream::EMS' has a wrong offset!");
static_assert(offsetof(UEMSAsyncStream, StreamActors) == 0x000048, "Member 'UEMSAsyncStream::StreamActors' has a wrong offset!");
static_assert(offsetof(UEMSAsyncStream, StreamActorsMap) == 0x000058, "Member 'UEMSAsyncStream::StreamActorsMap' has a wrong offset!");
static_assert(offsetof(UEMSAsyncStream, PrunedData) == 0x0000A8, "Member 'UEMSAsyncStream::PrunedData' has a wrong offset!");

// Class EasyMultiSave.EMSAsyncWait
// 0x0028 (0x0058 - 0x0030)
class UEMSAsyncWait final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnCompleted;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UEMSObject*                             EMS;                                               // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UEMSAsyncWait* AsyncWaitForOperation(class UObject* WorldContextObject, EAsyncCheckType CheckType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EMSAsyncWait">();
	}
	static class UEMSAsyncWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEMSAsyncWait>();
	}
};
static_assert(alignof(UEMSAsyncWait) == 0x000008, "Wrong alignment on UEMSAsyncWait");
static_assert(sizeof(UEMSAsyncWait) == 0x000058, "Wrong size on UEMSAsyncWait");
static_assert(offsetof(UEMSAsyncWait, OnCompleted) == 0x000030, "Member 'UEMSAsyncWait::OnCompleted' has a wrong offset!");
static_assert(offsetof(UEMSAsyncWait, EMS) == 0x000040, "Member 'UEMSAsyncWait::EMS' has a wrong offset!");

// Class EasyMultiSave.EMSCompSaveInterface
// 0x0000 (0x0028 - 0x0028)
class IEMSCompSaveInterface final : public IInterface
{
public:
	void ComponentLoaded();
	void ComponentPreSave();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EMSCompSaveInterface">();
	}
	static class IEMSCompSaveInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEMSCompSaveInterface>();
	}
};
static_assert(alignof(IEMSCompSaveInterface) == 0x000008, "Wrong alignment on IEMSCompSaveInterface");
static_assert(sizeof(IEMSCompSaveInterface) == 0x000028, "Wrong size on IEMSCompSaveInterface");

// Class EasyMultiSave.EMSCustomSaveGame
// 0x0028 (0x0050 - 0x0028)
class UEMSCustomSaveGame : public USaveGame
{
public:
	class FString                                 SaveGameName;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSaveSlot;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x17];                                      // 0x0039(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EMSCustomSaveGame">();
	}
	static class UEMSCustomSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEMSCustomSaveGame>();
	}
};
static_assert(alignof(UEMSCustomSaveGame) == 0x000008, "Wrong alignment on UEMSCustomSaveGame");
static_assert(sizeof(UEMSCustomSaveGame) == 0x000050, "Wrong size on UEMSCustomSaveGame");
static_assert(offsetof(UEMSCustomSaveGame, SaveGameName) == 0x000028, "Member 'UEMSCustomSaveGame::SaveGameName' has a wrong offset!");
static_assert(offsetof(UEMSCustomSaveGame, bUseSaveSlot) == 0x000038, "Member 'UEMSCustomSaveGame::bUseSaveSlot' has a wrong offset!");

// Class EasyMultiSave.EMSFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UEMSFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearMultiLevelSave(class UObject* WorldContextObject);
	static void ClearWorldPartition(class UObject* WorldContextObject);
	static void DeleteAllSaveDataForSlot(class UObject* WorldContextObject, const class FString& SaveGameName);
	static bool DeleteCustomPlayerFile(class UObject* WorldContextObject, const class FString& Filename);
	static void DeleteCustomSave(class UObject* WorldContextObject, class UEMSCustomSaveGame* SaveGame);
	static void DeleteSaveUser(class UObject* WorldContextObject, const class FString& username);
	static bool DoesSaveSlotExist(class UObject* WorldContextObject, const class FString& SaveGameName, bool bComplete);
	static void ExportSaveThumbnail(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const class FString& SaveGameName);
	static TArray<class FString> GetAllSaveUsers(class UObject* WorldContextObject);
	static class UEMSCustomSaveGame* GetCustomSave(class UObject* WorldContextObject, TSubclassOf<class UEMSCustomSaveGame> SaveGameClass, const class FString& SaveSlot, const class FString& Filename);
	static class UEMSInfoSaveGame* GetNamedSlotInfo(class UObject* WorldContextObject, const class FString& SaveGameName);
	static class UEMSInfoSaveGame* GetSlotInfoSaveGame(class UObject* WorldContextObject, class FString* SaveGameName);
	static TArray<class FString> GetSortedSaveSlots(class UObject* WorldContextObject);
	static class UTexture2D* ImportSaveThumbnail(class UObject* WorldContextObject, const class FString& SaveGameName);
	static bool IsLevelStreamingActive(class UObject* WorldContextObject);
	static bool IsSavingOrLoading(class UObject* WorldContextObject);
	static bool IsWorldPartition(class UObject* WorldContextObject);
	static bool LoadPlayerActorsCustom(class AController* Controller, const class FString& Filename);
	static class UObject* LoadRawObject(class AActor* WorldContextActor, const struct FRawObjectSaveData& Data);
	static bool SaveCustom(class UObject* WorldContextObject, class UEMSCustomSaveGame* SaveGame);
	static bool SavePlayerActorsCustom(class AController* Controller, const class FString& Filename);
	static bool SaveRawObject(class AActor* WorldContextActor, const struct FRawObjectSaveData& Data);
	static void SetActorSaveProperties(class UObject* WorldContextObject, bool bSkipSave, bool bPersistent, bool bSkipTransform, ELoadedStateMod LoadedState);
	static void SetCurrentSaveGameName(class UObject* WorldContextObject, const class FString& SaveGameName);
	static void SetCurrentSaveUserName(class UObject* WorldContextObject, const class FString& username);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EMSFunctionLibrary">();
	}
	static class UEMSFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEMSFunctionLibrary>();
	}
};
static_assert(alignof(UEMSFunctionLibrary) == 0x000008, "Wrong alignment on UEMSFunctionLibrary");
static_assert(sizeof(UEMSFunctionLibrary) == 0x000028, "Wrong size on UEMSFunctionLibrary");

// Class EasyMultiSave.EMSInfoSaveGame
// 0x0030 (0x0058 - 0x0028)
class UEMSInfoSaveGame final : public USaveGame
{
public:
	struct FSaveSlotInfo                          SlotInfo;                                          // 0x0028(0x0030)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EMSInfoSaveGame">();
	}
	static class UEMSInfoSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEMSInfoSaveGame>();
	}
};
static_assert(alignof(UEMSInfoSaveGame) == 0x000008, "Wrong alignment on UEMSInfoSaveGame");
static_assert(sizeof(UEMSInfoSaveGame) == 0x000058, "Wrong size on UEMSInfoSaveGame");
static_assert(offsetof(UEMSInfoSaveGame, SlotInfo) == 0x000028, "Member 'UEMSInfoSaveGame::SlotInfo' has a wrong offset!");

// Class EasyMultiSave.EMSObject
// 0x0520 (0x0550 - 0x0030)
class UEMSObject final : public UGameInstanceSubsystem
{
public:
	class FString                                 CurrentSaveGameName;                               // 0x0030(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrentSaveUserName;                               // 0x0040(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class APlayerController* LoadedPlayer)> OnPlayerLoaded;                                    // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<TSoftObjectPtr<class AActor>>& LoadedActors)> OnLevelLoaded;                                     // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(TArray<TSoftObjectPtr<class AActor>>& LoadedActors)> OnPartitionLoaded;                                 // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0xB8];                                      // 0x0080(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          ActorList;                                         // 0x0138(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class FName, TWeakObjectPtr<class AActor>> ActorMap;                                          // 0x0148(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FLevelArchive>                  LevelArchiveList;                                  // 0x0198(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FMultiLevelStreamingData               MultiLevelStreamData;                              // 0x01A8(0x0070)(Transient, NativeAccessSpecifierPrivate)
	struct FPlayerStackArchive                    PlayerStackData;                                   // 0x0218(0x0100)(Transient, NativeAccessSpecifierPrivate)
	TArray<struct FActorSaveData>                 SavedActors;                                       // 0x0318(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FActorSaveData>                 SavedActorsPruned;                                 // 0x0328(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FLevelScriptSaveData>           SavedScripts;                                      // 0x0338(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FGameObjectSaveData                    SavedGameMode;                                     // 0x0348(0x0020)(Transient, NativeAccessSpecifierPrivate)
	struct FGameObjectSaveData                    SavedGameState;                                    // 0x0368(0x0020)(Transient, NativeAccessSpecifierPrivate)
	struct FControllerSaveData                    SavedController;                                   // 0x0388(0x0038)(Transient, NativeAccessSpecifierPrivate)
	struct FPawnSaveData                          SavedPawn;                                         // 0x03C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	struct FGameObjectSaveData                    SavedPlayerState;                                  // 0x0410(0x0020)(Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, class UEMSInfoSaveGame*>  CachedSaveSlots;                                   // 0x0430(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class FString, class UEMSCustomSaveGame*> CachedCustomSaves;                                 // 0x0480(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FActorSaveData>                 WorldPartitionActors;                              // 0x04D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FActorSaveData>                 DestroyedActors;                                   // 0x04E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class AActor>, struct FGameObjectSaveData> RawObjectData;                                     // 0x04F0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class AActor>>          RealLoadedActors;                                  // 0x0540(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EMSObject">();
	}
	static class UEMSObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEMSObject>();
	}
};
static_assert(alignof(UEMSObject) == 0x000008, "Wrong alignment on UEMSObject");
static_assert(sizeof(UEMSObject) == 0x000550, "Wrong size on UEMSObject");
static_assert(offsetof(UEMSObject, CurrentSaveGameName) == 0x000030, "Member 'UEMSObject::CurrentSaveGameName' has a wrong offset!");
static_assert(offsetof(UEMSObject, CurrentSaveUserName) == 0x000040, "Member 'UEMSObject::CurrentSaveUserName' has a wrong offset!");
static_assert(offsetof(UEMSObject, OnPlayerLoaded) == 0x000050, "Member 'UEMSObject::OnPlayerLoaded' has a wrong offset!");
static_assert(offsetof(UEMSObject, OnLevelLoaded) == 0x000060, "Member 'UEMSObject::OnLevelLoaded' has a wrong offset!");
static_assert(offsetof(UEMSObject, OnPartitionLoaded) == 0x000070, "Member 'UEMSObject::OnPartitionLoaded' has a wrong offset!");
static_assert(offsetof(UEMSObject, ActorList) == 0x000138, "Member 'UEMSObject::ActorList' has a wrong offset!");
static_assert(offsetof(UEMSObject, ActorMap) == 0x000148, "Member 'UEMSObject::ActorMap' has a wrong offset!");
static_assert(offsetof(UEMSObject, LevelArchiveList) == 0x000198, "Member 'UEMSObject::LevelArchiveList' has a wrong offset!");
static_assert(offsetof(UEMSObject, MultiLevelStreamData) == 0x0001A8, "Member 'UEMSObject::MultiLevelStreamData' has a wrong offset!");
static_assert(offsetof(UEMSObject, PlayerStackData) == 0x000218, "Member 'UEMSObject::PlayerStackData' has a wrong offset!");
static_assert(offsetof(UEMSObject, SavedActors) == 0x000318, "Member 'UEMSObject::SavedActors' has a wrong offset!");
static_assert(offsetof(UEMSObject, SavedActorsPruned) == 0x000328, "Member 'UEMSObject::SavedActorsPruned' has a wrong offset!");
static_assert(offsetof(UEMSObject, SavedScripts) == 0x000338, "Member 'UEMSObject::SavedScripts' has a wrong offset!");
static_assert(offsetof(UEMSObject, SavedGameMode) == 0x000348, "Member 'UEMSObject::SavedGameMode' has a wrong offset!");
static_assert(offsetof(UEMSObject, SavedGameState) == 0x000368, "Member 'UEMSObject::SavedGameState' has a wrong offset!");
static_assert(offsetof(UEMSObject, SavedController) == 0x000388, "Member 'UEMSObject::SavedController' has a wrong offset!");
static_assert(offsetof(UEMSObject, SavedPawn) == 0x0003C0, "Member 'UEMSObject::SavedPawn' has a wrong offset!");
static_assert(offsetof(UEMSObject, SavedPlayerState) == 0x000410, "Member 'UEMSObject::SavedPlayerState' has a wrong offset!");
static_assert(offsetof(UEMSObject, CachedSaveSlots) == 0x000430, "Member 'UEMSObject::CachedSaveSlots' has a wrong offset!");
static_assert(offsetof(UEMSObject, CachedCustomSaves) == 0x000480, "Member 'UEMSObject::CachedCustomSaves' has a wrong offset!");
static_assert(offsetof(UEMSObject, WorldPartitionActors) == 0x0004D0, "Member 'UEMSObject::WorldPartitionActors' has a wrong offset!");
static_assert(offsetof(UEMSObject, DestroyedActors) == 0x0004E0, "Member 'UEMSObject::DestroyedActors' has a wrong offset!");
static_assert(offsetof(UEMSObject, RawObjectData) == 0x0004F0, "Member 'UEMSObject::RawObjectData' has a wrong offset!");
static_assert(offsetof(UEMSObject, RealLoadedActors) == 0x000540, "Member 'UEMSObject::RealLoadedActors' has a wrong offset!");

// Class EasyMultiSave.EMSPluginSettings
// 0x00B8 (0x00E0 - 0x0028)
class UEMSPluginSettings final : public UObject
{
public:
	class FString                                 DefaultSaveGameName;                               // 0x0028(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftClassPath                         SlotInfoSaveGameClass;                             // 0x0038(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFileSaveMethod                               FileSaveMethod;                                    // 0x0058(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoBackup;                                       // 0x0059(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoSaveStructs;                                  // 0x005A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroyActors;                                // 0x005B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdvancedSpawnCheck;                               // 0x005C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultiThreadSaving;                                // 0x005D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELoadMethod                                   LoadMethod;                                        // 0x005E(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F[0x1];                                       // 0x005F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DeferredLoadStackSize;                             // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AsyncWaitDelay;                                    // 0x0064(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreSaveOnGameThread;                              // 0x0068(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMultiLevelSaveMethod                         MultiLevelSaving;                                  // 0x0069(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDynamicLevelStreaming;                            // 0x006A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWorldPartitionMethod                         WorldPartitionSaving;                              // 0x006B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWorldPartitionInit                           WorldPartitionInit;                                // 0x006C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WorldPartitionInitTime;                            // 0x0070(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldPartitionInitThreshold;                       // 0x0074(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EThumbnailImageFormat                         ThumbnailFormat;                                   // 0x0078(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        SaveGameVersion;                                   // 0x007C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOldPackageEngine                             MigratedSaveEngineVersion;                         // 0x0080(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMigratedSaveActorVersionCheck;                    // 0x0081(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FSoftClassPath>    RuntimeClasses;                                    // 0x0088(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	float                                         WorldPartitionInitPollingRate;                     // 0x00D8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentPlayer;                                 // 0x00DC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistentGameMode;                               // 0x00DD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EMSPluginSettings">();
	}
	static class UEMSPluginSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEMSPluginSettings>();
	}
};
static_assert(alignof(UEMSPluginSettings) == 0x000008, "Wrong alignment on UEMSPluginSettings");
static_assert(sizeof(UEMSPluginSettings) == 0x0000E0, "Wrong size on UEMSPluginSettings");
static_assert(offsetof(UEMSPluginSettings, DefaultSaveGameName) == 0x000028, "Member 'UEMSPluginSettings::DefaultSaveGameName' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, SlotInfoSaveGameClass) == 0x000038, "Member 'UEMSPluginSettings::SlotInfoSaveGameClass' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, FileSaveMethod) == 0x000058, "Member 'UEMSPluginSettings::FileSaveMethod' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, bAutoBackup) == 0x000059, "Member 'UEMSPluginSettings::bAutoBackup' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, bAutoSaveStructs) == 0x00005A, "Member 'UEMSPluginSettings::bAutoSaveStructs' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, bAutoDestroyActors) == 0x00005B, "Member 'UEMSPluginSettings::bAutoDestroyActors' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, bAdvancedSpawnCheck) == 0x00005C, "Member 'UEMSPluginSettings::bAdvancedSpawnCheck' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, bMultiThreadSaving) == 0x00005D, "Member 'UEMSPluginSettings::bMultiThreadSaving' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, LoadMethod) == 0x00005E, "Member 'UEMSPluginSettings::LoadMethod' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, DeferredLoadStackSize) == 0x000060, "Member 'UEMSPluginSettings::DeferredLoadStackSize' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, AsyncWaitDelay) == 0x000064, "Member 'UEMSPluginSettings::AsyncWaitDelay' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, bPreSaveOnGameThread) == 0x000068, "Member 'UEMSPluginSettings::bPreSaveOnGameThread' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, MultiLevelSaving) == 0x000069, "Member 'UEMSPluginSettings::MultiLevelSaving' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, bDynamicLevelStreaming) == 0x00006A, "Member 'UEMSPluginSettings::bDynamicLevelStreaming' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, WorldPartitionSaving) == 0x00006B, "Member 'UEMSPluginSettings::WorldPartitionSaving' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, WorldPartitionInit) == 0x00006C, "Member 'UEMSPluginSettings::WorldPartitionInit' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, WorldPartitionInitTime) == 0x000070, "Member 'UEMSPluginSettings::WorldPartitionInitTime' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, WorldPartitionInitThreshold) == 0x000074, "Member 'UEMSPluginSettings::WorldPartitionInitThreshold' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, ThumbnailFormat) == 0x000078, "Member 'UEMSPluginSettings::ThumbnailFormat' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, SaveGameVersion) == 0x00007C, "Member 'UEMSPluginSettings::SaveGameVersion' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, MigratedSaveEngineVersion) == 0x000080, "Member 'UEMSPluginSettings::MigratedSaveEngineVersion' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, bMigratedSaveActorVersionCheck) == 0x000081, "Member 'UEMSPluginSettings::bMigratedSaveActorVersionCheck' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, RuntimeClasses) == 0x000088, "Member 'UEMSPluginSettings::RuntimeClasses' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, WorldPartitionInitPollingRate) == 0x0000D8, "Member 'UEMSPluginSettings::WorldPartitionInitPollingRate' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, bPersistentPlayer) == 0x0000DC, "Member 'UEMSPluginSettings::bPersistentPlayer' has a wrong offset!");
static_assert(offsetof(UEMSPluginSettings, bPersistentGameMode) == 0x0000DD, "Member 'UEMSPluginSettings::bPersistentGameMode' has a wrong offset!");

}

