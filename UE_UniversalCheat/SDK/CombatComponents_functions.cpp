#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CombatComponents

#include "Basic.hpp"

#include "CombatComponents_classes.hpp"
#include "CombatComponents_parameters.hpp"


namespace SDK
{

// Function CombatComponents.CCCollisionHandlerComponent.ActivateCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECCCollisionPart                        CollisionPart                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCCCollisionHandlerComponent::ActivateCollision(ECCCollisionPart CollisionPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCollisionHandlerComponent", "ActivateCollision");

	Params::CCCollisionHandlerComponent_ActivateCollision Parms{};

	Parms.CollisionPart = CollisionPart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCCollisionHandlerComponent.ClearHitActors
// (Final, Native, Public, BlueprintCallable)

void UCCCollisionHandlerComponent::ClearHitActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCollisionHandlerComponent", "ClearHitActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCCollisionHandlerComponent.DeactivateCollision
// (Final, Native, Public, BlueprintCallable)

void UCCCollisionHandlerComponent::DeactivateCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCollisionHandlerComponent", "DeactivateCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCCollisionHandlerComponent.DrawDebugTrace
// (Final, Native, Private, HasDefaults)
// Parameters:
// struct FVector                          Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCCCollisionHandlerComponent::DrawDebugTrace(const struct FVector& Start, const struct FVector& End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCollisionHandlerComponent", "DrawDebugTrace");

	Params::CCCollisionHandlerComponent_DrawDebugTrace Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCCollisionHandlerComponent.DrawHitSphere
// (Final, Native, Private, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCCCollisionHandlerComponent::DrawHitSphere(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCollisionHandlerComponent", "DrawHitSphere");

	Params::CCCollisionHandlerComponent_DrawHitSphere Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCCollisionHandlerComponent.OnRep_IsCollisionActivated
// (Final, Native, Protected)

void UCCCollisionHandlerComponent::OnRep_IsCollisionActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCollisionHandlerComponent", "OnRep_IsCollisionActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCCollisionHandlerComponent.SetActiveCollisionPart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECCCollisionPart                        CollisionPart                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCCCollisionHandlerComponent::SetActiveCollisionPart(ECCCollisionPart CollisionPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCollisionHandlerComponent", "SetActiveCollisionPart");

	Params::CCCollisionHandlerComponent_SetActiveCollisionPart Parms{};

	Parms.CollisionPart = CollisionPart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCCollisionHandlerComponent.TraceCheckLoop
// (Final, Native, Protected)

void UCCCollisionHandlerComponent::TraceCheckLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCollisionHandlerComponent", "TraceCheckLoop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCCollisionHandlerComponent.UpdateCollidingComponent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     Sockets                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCCCollisionHandlerComponent::UpdateCollidingComponent(class UPrimitiveComponent* Component, const TArray<class FName>& Sockets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCollisionHandlerComponent", "UpdateCollidingComponent");

	Params::CCCollisionHandlerComponent_UpdateCollidingComponent Parms{};

	Parms.Component = Component;
	Parms.Sockets = std::move(Sockets);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCCollisionHandlerComponent.UpdateCollidingComponents
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FCCCollidingComponent>    collidingComponents                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCCCollisionHandlerComponent::UpdateCollidingComponents(const TArray<struct FCCCollidingComponent>& collidingComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCollisionHandlerComponent", "UpdateCollidingComponents");

	Params::CCCollisionHandlerComponent_UpdateCollidingComponents Parms{};

	Parms.collidingComponents = std::move(collidingComponents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCCollisionHandlerComponent.GetActivatedCollisionPart
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECCCollisionPart                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECCCollisionPart UCCCollisionHandlerComponent::GetActivatedCollisionPart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCollisionHandlerComponent", "GetActivatedCollisionPart");

	Params::CCCollisionHandlerComponent_GetActivatedCollisionPart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CombatComponents.CCCollisionHandlerComponent.IsCollisionActivated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCCCollisionHandlerComponent::IsCollisionActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCCollisionHandlerComponent", "IsCollisionActivated");

	Params::CCCollisionHandlerComponent_IsCollisionActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CombatComponents.CCRotatingOwnerComponent.NotifyOnRotatingEnd
// (Final, Native, Protected)

void UCCRotatingOwnerComponent::NotifyOnRotatingEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCRotatingOwnerComponent", "NotifyOnRotatingEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCRotatingOwnerComponent.NotifyOnRotatingStart
// (Final, Native, Protected)

void UCCRotatingOwnerComponent::NotifyOnRotatingStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCRotatingOwnerComponent", "NotifyOnRotatingStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCRotatingOwnerComponent.SetOwnerRotation
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FRotator                         NewRotation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UCCRotatingOwnerComponent::SetOwnerRotation(const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCRotatingOwnerComponent", "SetOwnerRotation");

	Params::CCRotatingOwnerComponent_SetOwnerRotation Parms{};

	Parms.NewRotation = std::move(NewRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCRotatingOwnerComponent.StartRotating
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   degressPerSecond                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCCRotatingOwnerComponent::StartRotating(float Time, float degressPerSecond)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCRotatingOwnerComponent", "StartRotating");

	Params::CCRotatingOwnerComponent_StartRotating Parms{};

	Parms.Time = Time;
	Parms.degressPerSecond = degressPerSecond;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCRotatingOwnerComponent.StartRotatingWithLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MaxPossibleRotation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   degressPerSecond                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCCRotatingOwnerComponent::StartRotatingWithLimit(float MaxPossibleRotation, float degressPerSecond)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCRotatingOwnerComponent", "StartRotatingWithLimit");

	Params::CCRotatingOwnerComponent_StartRotatingWithLimit Parms{};

	Parms.MaxPossibleRotation = MaxPossibleRotation;
	Parms.degressPerSecond = degressPerSecond;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCRotatingOwnerComponent.StopRotating
// (Final, Native, Public, BlueprintCallable)

void UCCRotatingOwnerComponent::StopRotating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCRotatingOwnerComponent", "StopRotating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function CombatComponents.CCRotatingOwnerComponent.IsRotating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCCRotatingOwnerComponent::IsRotating() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCRotatingOwnerComponent", "IsRotating");

	Params::CCRotatingOwnerComponent_IsRotating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function CombatComponents.CCRotatingOwnerInterface.GetDesiredRotation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ICCRotatingOwnerInterface::GetDesiredRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CCRotatingOwnerInterface", "GetDesiredRotation");

	Params::CCRotatingOwnerInterface_GetDesiredRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

