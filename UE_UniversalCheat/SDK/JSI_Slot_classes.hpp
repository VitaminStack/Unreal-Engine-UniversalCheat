#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JSI_Slot

#include "Basic.hpp"

#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "InputCore_structs.hpp"
#include "S_ItemStat_structs.hpp"


namespace SDK
{

// WidgetBlueprintGeneratedClass JSI_Slot.JSI_Slot_C
// 0x0330 (0x05F0 - 0x02C0)
class UJSI_Slot_C final : public UUserWidget
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x02C0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UWidgetAnimation*                       FadeInOut;                                         // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, RepSkip, NoDestructor, HasGetValueTypeHash)
	class UTextBlock*                             Durability;                                        // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UOverlay*                               MainSlotOverlay;                                   // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UTextBlock*                             ObjItemName;                                       // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UTextBlock*                             PriceCount;                                        // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UScaleBox*                              ScaleBox_133;                                      // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class USizeBox*                               SizeBox;                                           // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UBorder*                                SlotBorder;                                        // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UImage*                                 SlotFrameImg;                                      // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UImage*                                 SlotHighlight;                                     // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UImage*                                 SlotImage;                                         // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UTextBlock*                             StockCount;                                        // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UTextBlock*                             TextCout;                                          // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UVerticalBox*                           VerticalBox_0;                                     // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	int32                                         SlotIndex;                                         // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_33C[0x4];                                      // 0x033C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Size;                                              // 0x0340(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	struct FSlateColor                            OnHoverTint;                                       // 0x0350(0x0014)(Edit, BlueprintVisible, ExposeOnSpawn)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               Image;                                             // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          Highlighted_;                                      // 0x0370(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UJSIContainer_C*                        ContainerMother;                                   // 0x0378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	struct FKey                                   RotateKey;                                         // 0x0380(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          IsFixedSlot_;                                      // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ParentID;                                          // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UContainerWindowWidget_C*               WindowContainer;                                   // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          IsLocked_;                                         // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             FrameImageRect;                                    // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	double                                        OpacityValue;                                      // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          DragHighlighted_;                                  // 0x03C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOnHoverTooltipWidget_C*                OnHoverWidget;                                     // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          SortHighlighted_;                                  // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ShouldUpdateCapacity_;                             // 0x03D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HideOnDrag;                                        // 0x03D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsPending;                                         // 0x03D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UJSI_Slot_C*                            HostedItem;                                        // 0x03D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	TArray<class UJSI_Slot_C*>                    ArrayOfHostingItem;                                // 0x03E0(0x0010)(Edit, BlueprintVisible, ContainsInstancedReference)
	class UJSIContainer_C*                        SlotContainer;                                     // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	struct FLinearColor                           LastRarityColor;                                   // 0x03F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UTextureRenderTarget2D*                 RenderTargetSnap;                                  // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          MouseEnter_;                                       // 0x0410(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_411[0x7];                                      // 0x0411(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBP_InspectorCanvas_C*                  CanvasBP;                                          // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          ShouldRestoreImage;                                // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_421[0x7];                                      // 0x0421(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PendingSnapAttachements;                           // 0x0428(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UBP_ItemSnapLoading_C*                  LoadingSnap;                                       // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UUserWidget*                            InspectorWidget;                                   // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          PendingSnap;                                       // 0x0448(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_449[0x7];                                      // 0x0449(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              OriginalSize;                                      // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         InitCapacity;                                      // 0x0460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_464[0x4];                                      // 0x0464(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             FrameImage;                                        // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UJigsawItem_DataAsset_C*                JigDataAsset;                                      // 0x0470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FGameplayTag                           Rarity;                                            // 0x0478(0x0008)(Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          SlotRotated_;                                      // 0x0480(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EDragPivot                                    DragBehaviour;                                     // 0x0481(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          SnapIsOnStandby;                                   // 0x0482(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_483[0x5];                                      // 0x0483(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UJSI_Slot_C*                            MirroredActionbar;                                 // 0x0488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	double                                        ItemWeight;                                        // 0x0490(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector2D                              SlotVector;                                        // 0x0498(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	struct FVector2D                              DragOffset;                                        // 0x04A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UOverlaySlot*                           OverlayRef;                                        // 0x04B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	struct FVector2D                              LastClickLoc;                                      // 0x04C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          DragDisabled_;                                     // 0x04D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsEmpty;                                           // 0x04D1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_4D2[0x2];                                      // 0x04D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Row;                                               // 0x04D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	int32                                         Column;                                            // 0x04D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          HighlightOnHover_;                                 // 0x04DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_4DD[0x3];                                      // 0x04DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DropSupportedItems;                                // 0x04E0(0x0020)(Edit, BlueprintVisible, ExposeOnSpawn)
	bool                                          AllowInteractionOnSort;                            // 0x0500(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_501[0x7];                                      // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        SortHighlightOpacity;                              // 0x0508(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMulticastInlineDelegate<void()>              OnItemDestructEvent;                               // 0x0510(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	struct FGuid                                  ItemUniqueID;                                      // 0x0520(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         ItemCount;                                         // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ItemDim;                                           // 0x0538(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ItemRotated_;                                      // 0x0548(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_549[0x7];                                      // 0x0549(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            SpecialContainerRef;                               // 0x0550(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	double                                        Price;                                             // 0x0558(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        Dur;                                               // 0x0560(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        MaxDur;                                            // 0x0568(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UTexture*                               InvTexture;                                        // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UTexture*                               EquipTexture;                                      // 0x0578(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<struct FS_ItemStat>                    ItemStats;                                         // 0x0580(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UBP_PendingTimer_C*                     PendingTimer;                                      // 0x0590(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          CTRL_Down;                                         // 0x0598(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          SHIFT_Down;                                        // 0x0599(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ALT_Down;                                          // 0x059A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_59B[0x5];                                      // 0x059B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class FString>            CustomData;                                        // 0x05A0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)

public:
	bool AbleToStackTo_(class UJSI_Slot_C* ToItem);
	void AdaptImageToActionbar(class UTextureRenderTarget2D* RenderTargetSnap_0);
	void AddToXY(int32 X, int32 Y, struct FVector2D* SlotDimension);
	void AdjustImageScale();
	void CanOpenSpecialContainer_(bool* Return_value);
	void CanStack_(bool* CanStack, bool* FreeSpaceAvailable);
	void CapacityContainer_GetLastItem(class UJSI_Slot_C** Output);
	void ChangePrice(double Price_0);
	void ChangeRarity(const struct FGameplayTag& Rarity_0, bool* Changed_);
	void CheckIfScaleIsNeeded();
	void CheckRootContainer(class UJSI_Slot_C* DraggedItem, bool* CanAdd_);
	void ClearImageScale();
	void ClearPendingAttachments();
	void ClearSlot();
	void Construct();
	void ConstructInitialize();
	void DeepSearch_GetAllItems(TArray<class UJSI_Slot_C*>& ArrItemsByRef);
	void Destruct();
	void DetectChange(class UJSI_Slot_C* DroppedSlotRef, bool DraggedRotated_, bool* NOChange);
	void ExecuteUbergraph_JSI_Slot(int32 EntryPoint);
	class UWidget* Get_SlotBorder_ToolTipWidget_0();
	void GetBorderColorByRarity(const struct FGameplayTag& Rarity_0, struct FLinearColor* Color);
	void GetClickLocation(const struct FGeometry& Geometry, const struct FPointerEvent& MouseEvents, struct FVector2D* Output_Get);
	void GetContainerCapacity(int32* Cap, int32* MaxCapacity);
	void GetContainerOneRef(class UUserWidget** ContainerRef);
	void GetContainerRef(class UUserWidget** SpecialContainerRef_0, class UJSIContainer_C** SlotContainer_0, bool* IsSpecialContainer);
	void GetContainers(TArray<class UJSIContainer_C*>* Container);
	void GetCount(int32* Count);
	void GetCSlotFromHosted(class UJSIContainer_C** SlotContainer_0);
	void GetCurrency(class FText* Currency);
	void GetDefaultWeight(double* Weight);
	void GetDurability(double* Durability_0, double* MaxDurability);
	int32 GetFreeSpace();
	void GetHostedSlot(class UJSI_Slot_C** HostingItem);
	void GetItemID(class FName* ItemId);
	void GetItemName(class FText* Name_0);
	void GetJigDA(class UJigsawItem_DataAsset_C** JigDataAsset_0);
	void GetJigItemImage(class UTexture** TextureRef);
	void GetLenOfItemsInContainer(int32* Output_Get);
	void GetMaxStack(bool CheckCapacityContainer_, int32* MaxStack);
	void GetPendingAttachments(TArray<class FName>* PendingSnapAttachements_0);
	void GetPrice(double* Price_0);
	void GetSlotDim(struct FVector2D* SlotDimension);
	void GetSlotDimUnrotated(struct FVector2D* SlotDimension);
	void GetSlotIndexOnDrop(int32* SlotIndex_0);
	void GetSlotSize(struct FVector2D* Size_0);
	void GetSpecialContainerRef(class UUserWidget** SpecialContainerRef_0);
	void GetStatByName(const struct FGameplayTag& STAT_TAG, bool* Found, struct FS_ItemStat* Stat);
	void GetStats(TArray<struct FS_ItemStat>* ItemStats_0);
	void GetType(struct FGameplayTag* Type);
	void GetUniqueID(struct FGuid* UniqueServerID);
	double GetWeight();
	void HandleSizeBox();
	bool HasPendingAttachments();
	void HideCapacity();
	void Initialize();
	void IsALTDown(bool* CTRL_Down_0);
	bool ISCapacityContainer();
	void IsContainer_(bool* IsContainer__0);
	void IsCTRLDown(bool* CTRL_Down_0);
	void IsEmptySlot(bool* IsEmpty_0);
	void IsItemPending_(bool* IsPending_0);
	void IsPendingSnap_(bool* PendingSnap_0);
	bool isRotated_();
	void IsSHIFTDown(bool* CTRL_Down_0);
	void IsSnapOnStandBy(bool* SnapIsOnStandby_0);
	bool IsSpecialContainer_();
	void IsStillValid(class UJSI_Slot_C* Slot_0, bool* Valid);
	void LockSlot();
	struct FEventReply On_MouseDoubleClick(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);
	void OnDone_Event_0();
	void OnDragCancelled(const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation);
	void OnDragDetected(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation** Operation);
	void OnDragEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation);
	bool OnDrop(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation);
	struct FEventReply OnFocusReceived(const struct FGeometry& MyGeometry, const struct FFocusEvent& InFocusEvent);
	void OnItemMoved();
	struct FEventReply OnMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);
	struct FEventReply OnMouseButtonUp(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);
	void OnMouseEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);
	void OnMouseLeave(const struct FPointerEvent& MouseEvent);
	void OnVisualDragHighlight(bool Value);
	void OptimizeFixedSlot();
	void PreConstruct(bool IsDesignTime);
	struct FEventReply ProcessMouseDown(struct FGeometry& Geo, struct FPointerEvent& Pointer);
	void RefreshOnDragEnter(class UDragDropOperation* Op);
	void RemoveCount(int32 RemoveNum, bool RemoveAllIfCount_Num_, bool CallOnStackChanged_, bool* Removed_, int32* NewCount);
	void RemoveFromJSIParent(bool* Removed);
	void ResetOpacity();
	void ResizeSlot(const struct FVector2D& NewSize, bool ResizeImage_, struct FVector2D* Size_0);
	void Rotate_Image_Default(bool Rotated_);
	void RotateEquippedImage();
	void RotateSlot(bool Rotate_, bool FlipVector_);
	void SetCapacity(int32 CurrentCap, bool Unknown_);
	void SetControllerHighlight(bool Value);
	void SetDynamicInfo(class UJigsawItem_DataAsset_C* JigDataAsset_0);
	void SetHighlight(bool Highlight_, const struct FSlateColor& HighlightColor, bool HideImage_, bool* Highlight);
	void SetHostedSlot(class UJSI_Slot_C* HostingItem);
	void SetHostingArray(TArray<class UJSI_Slot_C*>& ArrayOfHostingItem_0);
	void SetItemDim(const struct FVector2D& ItemDim_0);
	void SetJigBrushSize(class UImage* Target, const struct FVector2D& Image_Size);
	void SetMaxCount(bool CallOnStackChanged_, int32* Count);
	void SetOverlaySlot(class UOverlaySlot* OverlayRef_0);
	void SetPending(bool Pending_, double PlaybackSpeed, double TimerInSec);
	void SetPendingAttachments(TArray<class FName>& PendingSnapAttachements_0);
	void SetRarityColor();
	void SetSlotContainerRef(class UJSIContainer_C* SlotContainer_0, class UJSI_Slot_C** Output_Get);
	void SetSlotImageVisibility(ESlateVisibility InVisibility);
	void SetSnapImagePending(bool PendingInspect);
	void SetSnapOnStandBy(bool SnapIsOnStandby_0);
	void SetSortHighlight(bool IsFaded, bool AllowInteractionOnSort_0);
	void SetSpecialContainer(class UUserWidget* SpecialContainerRef_0);
	void SetStatByName(const struct FGameplayTag& STAT_TAG, double MinVal, double MaxVal, bool* Found, struct FS_ItemStat* Stat);
	void SetUniqueID(const struct FGuid& ID, struct FGuid* UniqueID);
	void ShowHideDisplayName(bool Hide_);
	void ShowWeaponMagSize(int32 CurrentCap, int32 MaxCap);
	void TogleHighlight();
	void TryUseBullet(bool* Return, struct FGuid* UID, class UJSI_Slot_C** ItemUsed);
	void UnhandledGetTargetContainer(class UJSIContainer_C* Container1, class UJSIContainer_C* Container2, class UJSIContainer_C** Target);
	void UnlockSlot();
	void Update_OnCountChanged(class UJSI_Slot_C* ItemRef, int32 OldCount, int32 NewCount);
	void Update_OnItemAdded(class UJSI_Slot_C* ItemRef);
	void Update_OnItemRemoved(class UJSI_Slot_C* ItemRef);
	void UpdateCapacity(const class FText& UpdateCountText);
	void UpdateCount(int32 NewCount, bool CallOnStackChanged_, bool SkipIfCapContainer, int32* Count);
	void UpdateCustom_Data(TArray<class FString>& Key, TArray<class FString>& Value);
	void UpdateDurability(const struct FVector2D& NewDur);
	void UpdateImage(class UTexture* NewTexture, bool SetInInfo_, bool* Updated);
	void UpdateInfo(class UObject* Image_0, const struct FVector2D& Image_Size);
	void UpdateItemSnap(bool IsActionbar_);
	void UpdateMaterialRarity();
	void UpdateStats(TArray<struct FS_ItemStat>& Stats);
	void UpdateStockCount(int32 NewCount);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"JSI_Slot_C">();
	}
	static class UJSI_Slot_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJSI_Slot_C>();
	}
};
static_assert(alignof(UJSI_Slot_C) == 0x000008, "Wrong alignment on UJSI_Slot_C");
static_assert(sizeof(UJSI_Slot_C) == 0x0005F0, "Wrong size on UJSI_Slot_C");
static_assert(offsetof(UJSI_Slot_C, UberGraphFrame) == 0x0002C0, "Member 'UJSI_Slot_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, FadeInOut) == 0x0002C8, "Member 'UJSI_Slot_C::FadeInOut' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, Durability) == 0x0002D0, "Member 'UJSI_Slot_C::Durability' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, MainSlotOverlay) == 0x0002D8, "Member 'UJSI_Slot_C::MainSlotOverlay' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ObjItemName) == 0x0002E0, "Member 'UJSI_Slot_C::ObjItemName' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, PriceCount) == 0x0002E8, "Member 'UJSI_Slot_C::PriceCount' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ScaleBox_133) == 0x0002F0, "Member 'UJSI_Slot_C::ScaleBox_133' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SizeBox) == 0x0002F8, "Member 'UJSI_Slot_C::SizeBox' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SlotBorder) == 0x000300, "Member 'UJSI_Slot_C::SlotBorder' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SlotFrameImg) == 0x000308, "Member 'UJSI_Slot_C::SlotFrameImg' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SlotHighlight) == 0x000310, "Member 'UJSI_Slot_C::SlotHighlight' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SlotImage) == 0x000318, "Member 'UJSI_Slot_C::SlotImage' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, StockCount) == 0x000320, "Member 'UJSI_Slot_C::StockCount' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, TextCout) == 0x000328, "Member 'UJSI_Slot_C::TextCout' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, VerticalBox_0) == 0x000330, "Member 'UJSI_Slot_C::VerticalBox_0' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SlotIndex) == 0x000338, "Member 'UJSI_Slot_C::SlotIndex' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, Size) == 0x000340, "Member 'UJSI_Slot_C::Size' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, OnHoverTint) == 0x000350, "Member 'UJSI_Slot_C::OnHoverTint' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, Image) == 0x000368, "Member 'UJSI_Slot_C::Image' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, Highlighted_) == 0x000370, "Member 'UJSI_Slot_C::Highlighted_' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ContainerMother) == 0x000378, "Member 'UJSI_Slot_C::ContainerMother' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, RotateKey) == 0x000380, "Member 'UJSI_Slot_C::RotateKey' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, IsFixedSlot_) == 0x000398, "Member 'UJSI_Slot_C::IsFixedSlot_' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ParentID) == 0x00039C, "Member 'UJSI_Slot_C::ParentID' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, WindowContainer) == 0x0003A0, "Member 'UJSI_Slot_C::WindowContainer' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, IsLocked_) == 0x0003A8, "Member 'UJSI_Slot_C::IsLocked_' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, FrameImageRect) == 0x0003B0, "Member 'UJSI_Slot_C::FrameImageRect' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, OpacityValue) == 0x0003B8, "Member 'UJSI_Slot_C::OpacityValue' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, DragHighlighted_) == 0x0003C0, "Member 'UJSI_Slot_C::DragHighlighted_' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, OnHoverWidget) == 0x0003C8, "Member 'UJSI_Slot_C::OnHoverWidget' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SortHighlighted_) == 0x0003D0, "Member 'UJSI_Slot_C::SortHighlighted_' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ShouldUpdateCapacity_) == 0x0003D1, "Member 'UJSI_Slot_C::ShouldUpdateCapacity_' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, HideOnDrag) == 0x0003D2, "Member 'UJSI_Slot_C::HideOnDrag' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, IsPending) == 0x0003D3, "Member 'UJSI_Slot_C::IsPending' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, HostedItem) == 0x0003D8, "Member 'UJSI_Slot_C::HostedItem' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ArrayOfHostingItem) == 0x0003E0, "Member 'UJSI_Slot_C::ArrayOfHostingItem' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SlotContainer) == 0x0003F0, "Member 'UJSI_Slot_C::SlotContainer' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, LastRarityColor) == 0x0003F8, "Member 'UJSI_Slot_C::LastRarityColor' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, RenderTargetSnap) == 0x000408, "Member 'UJSI_Slot_C::RenderTargetSnap' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, MouseEnter_) == 0x000410, "Member 'UJSI_Slot_C::MouseEnter_' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, CanvasBP) == 0x000418, "Member 'UJSI_Slot_C::CanvasBP' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ShouldRestoreImage) == 0x000420, "Member 'UJSI_Slot_C::ShouldRestoreImage' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, PendingSnapAttachements) == 0x000428, "Member 'UJSI_Slot_C::PendingSnapAttachements' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, LoadingSnap) == 0x000438, "Member 'UJSI_Slot_C::LoadingSnap' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, InspectorWidget) == 0x000440, "Member 'UJSI_Slot_C::InspectorWidget' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, PendingSnap) == 0x000448, "Member 'UJSI_Slot_C::PendingSnap' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, OriginalSize) == 0x000450, "Member 'UJSI_Slot_C::OriginalSize' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, InitCapacity) == 0x000460, "Member 'UJSI_Slot_C::InitCapacity' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, FrameImage) == 0x000468, "Member 'UJSI_Slot_C::FrameImage' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, JigDataAsset) == 0x000470, "Member 'UJSI_Slot_C::JigDataAsset' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, Rarity) == 0x000478, "Member 'UJSI_Slot_C::Rarity' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SlotRotated_) == 0x000480, "Member 'UJSI_Slot_C::SlotRotated_' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, DragBehaviour) == 0x000481, "Member 'UJSI_Slot_C::DragBehaviour' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SnapIsOnStandby) == 0x000482, "Member 'UJSI_Slot_C::SnapIsOnStandby' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, MirroredActionbar) == 0x000488, "Member 'UJSI_Slot_C::MirroredActionbar' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ItemWeight) == 0x000490, "Member 'UJSI_Slot_C::ItemWeight' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SlotVector) == 0x000498, "Member 'UJSI_Slot_C::SlotVector' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, DragOffset) == 0x0004A8, "Member 'UJSI_Slot_C::DragOffset' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, OverlayRef) == 0x0004B8, "Member 'UJSI_Slot_C::OverlayRef' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, LastClickLoc) == 0x0004C0, "Member 'UJSI_Slot_C::LastClickLoc' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, DragDisabled_) == 0x0004D0, "Member 'UJSI_Slot_C::DragDisabled_' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, IsEmpty) == 0x0004D1, "Member 'UJSI_Slot_C::IsEmpty' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, Row) == 0x0004D4, "Member 'UJSI_Slot_C::Row' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, Column) == 0x0004D8, "Member 'UJSI_Slot_C::Column' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, HighlightOnHover_) == 0x0004DC, "Member 'UJSI_Slot_C::HighlightOnHover_' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, DropSupportedItems) == 0x0004E0, "Member 'UJSI_Slot_C::DropSupportedItems' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, AllowInteractionOnSort) == 0x000500, "Member 'UJSI_Slot_C::AllowInteractionOnSort' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SortHighlightOpacity) == 0x000508, "Member 'UJSI_Slot_C::SortHighlightOpacity' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, OnItemDestructEvent) == 0x000510, "Member 'UJSI_Slot_C::OnItemDestructEvent' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ItemUniqueID) == 0x000520, "Member 'UJSI_Slot_C::ItemUniqueID' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ItemCount) == 0x000530, "Member 'UJSI_Slot_C::ItemCount' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ItemDim) == 0x000538, "Member 'UJSI_Slot_C::ItemDim' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ItemRotated_) == 0x000548, "Member 'UJSI_Slot_C::ItemRotated_' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SpecialContainerRef) == 0x000550, "Member 'UJSI_Slot_C::SpecialContainerRef' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, Price) == 0x000558, "Member 'UJSI_Slot_C::Price' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, Dur) == 0x000560, "Member 'UJSI_Slot_C::Dur' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, MaxDur) == 0x000568, "Member 'UJSI_Slot_C::MaxDur' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, InvTexture) == 0x000570, "Member 'UJSI_Slot_C::InvTexture' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, EquipTexture) == 0x000578, "Member 'UJSI_Slot_C::EquipTexture' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ItemStats) == 0x000580, "Member 'UJSI_Slot_C::ItemStats' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, PendingTimer) == 0x000590, "Member 'UJSI_Slot_C::PendingTimer' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, CTRL_Down) == 0x000598, "Member 'UJSI_Slot_C::CTRL_Down' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, SHIFT_Down) == 0x000599, "Member 'UJSI_Slot_C::SHIFT_Down' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, ALT_Down) == 0x00059A, "Member 'UJSI_Slot_C::ALT_Down' has a wrong offset!");
static_assert(offsetof(UJSI_Slot_C, CustomData) == 0x0005A0, "Member 'UJSI_Slot_C::CustomData' has a wrong offset!");

}

