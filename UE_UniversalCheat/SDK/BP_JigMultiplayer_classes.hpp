#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_JigMultiplayer

#include "Basic.hpp"

#include "S_JigCompContentSettings_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "S_ReplicatedContainerInfo_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "S_InvWeight_structs.hpp"
#include "S_JigCrafting_structs.hpp"
#include "ContainerPickupsInfo_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_JigMultiplayer.BP_JigMultiplayer_C
// 0x0260 (0x0300 - 0x00A0)
class UBP_JigMultiplayer_C final : public UActorComponent
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x00A0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	TArray<struct FS_ReplicatedContainerInfo>     MainJigContainers;                                 // 0x00A8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<class UJSIContainer_C*>                LocalJSIContainers;                                // 0x00B8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	struct FGameplayTag                           MPComponentType;                                   // 0x00C8(0x0008)(Edit, BlueprintVisible, Net, NoDestructor, HasGetValueTypeHash)
	TArray<class UJSI_Slot_C*>                    PendingRequests;                                   // 0x00D0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<struct FGuid>                          MainContainersIDs;                                 // 0x00E0(0x0010)(Edit, BlueprintVisible, Net, DisableEditOnInstance, RepNotify)
	TArray<struct FS_JigCompContentSettings>      ContainersSettings;                                // 0x00F0(0x0010)(Edit, BlueprintVisible)
	double                                        RefillContainerTimerInSeconds;                     // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UClass*                                 InventoryWidgetClass;                              // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class UUserWidget*                            InventoryWidgetRef;                                // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	TArray<class AActor*>                         PendingActors;                                     // 0x0118(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)
	bool                                          DoesContainerRefillLoot_;                          // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IfPickup_CanLoot_;                                 // 0x0129(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          AllowDroppingItems;                                // 0x012A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_12B[0x5];                                      // 0x012B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FContainerPickupsInfo                  PickupInfo;                                        // 0x0130(0x00D8)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference, HasGetValueTypeHash)
	class UJigsawItem_DataAsset_C*                VendorAcceptedCurrencyID;                          // 0x0208(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	bool                                          VendorReSellSoldItems_;                            // 0x0210(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          AllowSellingItemsToVendor_;                        // 0x0211(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_212[0x6];                                      // 0x0212(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FS_JigCrafting>                 ItemsToCraft;                                      // 0x0218(0x0010)(Edit, BlueprintVisible)
	TArray<int32>                                 ExcludeMainContainerIndexesFromLoot;               // 0x0228(0x0010)(Edit, BlueprintVisible)
	struct FGuid                                  MonitorContainerUID;                               // 0x0238(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FGuid                                  PendingVendorContainerUID;                         // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         PendingVendorToIndex;                              // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          PendingVendorFinalRot;                             // 0x025C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_25D[0x3];                                      // 0x025D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ServerVendorRequestedBuyAmount;                    // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FS_InvWeight>                   InventoryWeight;                                   // 0x0268(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<int32>                                 ExcludeMainContainerIndexesFromVendorCurrency;     // 0x0278(0x0010)(Edit, BlueprintVisible)
	bool                                          DebugContent_;                                     // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Looted_;                                           // 0x0289(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_28A[0x6];                                      // 0x028A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           RefillTimerHandle;                                 // 0x0290(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<struct FContainerPickupsInfo>          PendingCraftingItems;                              // 0x0298(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<double>                                PendingCraftingTimers;                             // 0x02A8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	struct FTimerHandle                           CraftingTimerHandle;                               // 0x02B8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TMulticastInlineDelegate<void()>              OnWeightUpdated;                                   // 0x02C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void(bool Opened_)>  OnInventoryOpenClose;                              // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void()>              ClientSaveDataReceived;                            // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void()>              OnRefillContainer;                                 // 0x02F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)

public:
	void AddItemFromComp(struct FContainerPickupsInfo& ItemInfo, TArray<struct FS_ReplicatedContainerInfo>& SubContainers, const struct FGuid& ToUID, bool FinalRotation, int32 ToIndex, int32 VendorAmount, bool* VendorCountUpdate);
	void AddItemToContainerByName(class FName ContainerName, class UJigsawItem_DataAsset_C* ItemId, int32 Count, bool TopLevelContainersOnly_, class UJigsawItem_DataAsset_C* ItemInside, int32 ItemInsideCount);
	void AddJSIContainer(const class UJSIContainer_C*& InputPin);
	void AddNewItemSomewhere(class UJigsawItem_DataAsset_C* ItemId, int32 Count, class UJigsawItem_DataAsset_C* ItemInside, int32 ItemInsideCount, bool DropIfFailedToAdd_, bool* Added, bool* Dropped_, struct FGuid* ItemUID, struct FGuid* AddedToUID);
	void AddNewItemToSlot(struct FContainerPickupsInfo& ItemInfo, const struct FGuid& ToContainer, int32 ToIndex, TArray<struct FS_ReplicatedContainerInfo>& ContainerContent, bool SetUID_, bool* Added, struct FContainerPickupsInfo* AddedItemInfo);
	void AddNewPendingRequest(const class UJSI_Slot_C*& NewItem);
	void AdjustCrafting();
	void AdjustEquipToContainerSettings();
	void AdjustNewContainerSize(class UJigsawItem_DataAsset_C* DA);
	void BindMainEvents(class UJSIContainer_C* Container);
	void BuildContainerSlots(TArray<struct FS_ContainerSlots>& SlotArr, int32 Columns, int32 Rows);
	void BuildDataToContainer(TArray<struct FContainerPickupsInfo>& Data);
	void BulkUpdateStats(const struct FGameplayTag& StatTag, double Value, bool Override_);
	void CanAddItem(struct FContainerPickupsInfo& Info, const struct FGuid& ToContainerUID, int32 Index_0, bool FinalRotation, bool* Result, bool* ToMain_);
	void CanAddToContainerIgnoreIndexes(struct FS_ReplicatedContainerInfo& RepContainer, int32 ToIndex, const struct FVector2D& Vec, TArray<int32>& Ignore, bool* Proceed);
	void CanLootPickup_(bool* Result);
	void CheckCanClearContainer(bool* Result);
	bool CheckCapacityContainer(const struct FRepItemInfo& ContainerInfo, const struct FGuid& ToContainerUID, int32* FreeSpace, TArray<class UJigsawItem_DataAsset_C*>* AvailableIDs, int32* Index_0);
	void CheckContainerRefill(bool BeginPlay_);
	void CheckCraftingIngredients(const struct FRepItemInfo& RequiredItem, TArray<struct FGuid>& Exclude, TArray<class UJSI_Slot_C*>* ItemFound_Element);
	void CheckIfCapacityContainer(const struct FGuid& ItemMotherUID, bool* IsCapacity);
	bool CheckIfHasEnoughMoney(int32 Price, class UJigsawItem_DataAsset_C* Currency);
	void CheckIfItemsExist(TArray<class UJigsawItem_DataAsset_C*>& Items, bool* Result);
	void ClearContainer(bool ResetInit_);
	void ClearContainerWidgets();
	void ClearJSIItems();
	void CLIENT_AddActorToContainerSUCCESS(class AActor* ActorRef, const struct FContainerPickupsInfo& ItemAdded, const TArray<struct FContainerPickupsInfo>& ContainerContent, const struct FGuid& TempUID, const TArray<struct FS_UpdateCount>& UpdateCounts);
	void CLIENT_AddNewItem(const struct FContainerPickupsInfo& ItemInfo, const TArray<struct FContainerPickupsInfo>& Content, class UBP_JigMultiplayer_C* Comp, const struct FGuid& PendingUID);
	void CLIENT_AddStackActorResponse(bool Success, const struct FGuid& ItemUID, int32 NewCount, class AActor* ActorRef);
	void CLIENT_ContainerDataResponse(const TArray<struct FGuid>& MainContainersUIDs, const TArray<struct FContainerPickupsInfo>& ContainerItems, class UBP_JigMultiplayer_C* JigMPCompRef, const TArray<struct FGuid>& ActionbarUIDs);
	void CLIENT_DropRequestFailed(const struct FGuid& ItemUID);
	void CLIENT_EquipActorSuccess(class AActor* ActorRef, const struct FContainerPickupsInfo& ItemAdded, const TArray<struct FContainerPickupsInfo>& ContainerContent);
	void CLIENT_ExpandContainer(const struct FGuid& ContainerUID, int32 AddedColumn, int32 AddedRow);
	void CLIENT_ItemCraftedResponse(const struct FGuid& TempUID, const struct FContainerPickupsInfo& ItemAdded, bool Success_, const TArray<struct FGuid>& UpdateUIDs, TArray<int32>& WithCounts, bool IsCraftingStation_, const struct FContainerPickupsInfo& ItemInside);
	void CLIENT_ItemRemoved(const struct FGuid& UID, class UBP_JigMultiplayer_C* Comp, bool SkipPendingRequests_);
	void CLIENT_MoveItemToIndex(const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool FinalRotation);
	void CLIENT_MoveToIndexFailed(const TArray<struct FGuid>& ItemUID, class UBP_JigMultiplayer_C* JijgCompTarget);
	void CLIENT_NewItemAdded(const struct FRepItemInfo& ItemInfo, const struct FGuid& UID, const struct FGuid& ToContainerUID, int32 ToIndex, bool FinalRotation, const struct FS_UpdateCount& UpdateCount, const struct FGuid& RemovePending, TArray<struct FS_SubContainerInfo>& SubContainers);
	void CLIENT_OnStatsUpdated(const TArray<struct FGuid>& UID, const struct FGameplayTag& STAT_NAME, const TArray<double>& Values);
	void CLIENT_OnStatUpdated(const struct FGuid& UID, const struct FGameplayTag& STAT_TAG, double NewValue);
	void CLIENT_ReloadResponse(bool Success_, const struct FGuid& UnloadUID, const struct FGuid& UnloadToContainerUID, int32 ToIndex, bool FinalRot, const struct FGuid& ReloadUID, const struct FGuid& ReloadToContainerUID);
	void CLIENT_RequestAddActorToContainerFAILED(class AActor* ActorRef, const struct FGuid& TempUID);
	void CLIENT_RequestEquipResponseFailed(const struct FGuid& MainContainerUID, class AActor* ActorRef);
	void Client_SameCompUpdateSplitRequest(const struct FGuid& SourceUID, int32 SourceNewCount, const struct FRepItemInfo& NewItem, const struct FGuid& NewItemUID, const struct FGuid& ToContainerUID, int32 ToSlot, bool Rotated);
	void CLIENT_SwapContainersResponse(const struct FGuid& ContainerUID, const struct FGuid& SecondContainerUID, bool Success);
	void CLIENT_UpdateChamberBulletUID(const struct FGuid& NewUID);
	void CLIENT_UpdateCount(class UBP_JigMultiplayer_C* TargetComp, const struct FGuid& ItemUID, int32 NewCount, const struct FGuid& RemovedPending);
	void CLIENT_UpdateCounts(const TArray<struct FS_UpdateCount>& Counts, const struct FGuid& TempUID);
	void CLIENT_UpdateCustomValues(const struct FGuid& ItemUID, const TArray<class FString>& Keys, const TArray<class FString>& Values);
	void CLIENT_UpdateDurability(const struct FGuid& ItemUID, const struct FVector2D& NewDurab);
	void CLIENT_UpdateStack(const struct FGuid& DroppedUID, int32 DropNewCount, const struct FGuid& RecUID, int32 RecNewCount);
	void ClientFunc_CheckIfCanStackAddActor(class AActor* ActorRef, bool TestOnlly, bool* Handled, struct FGuid* WithUID, TArray<struct FGuid>* PartialStacks);
	void ClientFunc_GetDesiredMoneyLocation(class UBP_JigMultiplayer_C* VendorCom, class UJSI_Slot_C* DroppedItem, bool* Found, struct FGuid* ToContainerID, int32* ToIndex);
	void ClientFunc_HandleActorAddedToContainer(class AActor* ActorRef, const struct FContainerPickupsInfo& ItemAdded, const TArray<struct FContainerPickupsInfo>& ContainerContent, const struct FGuid& TempUID, TArray<struct FS_UpdateCount>& UpdateCounts);
	void ClientFunc_UpdateCustomData(const struct FGuid& ItemUID, TArray<class FString>& Keys, TArray<class FString>& Values);
	void ClientFunc_UpdateDurability(const struct FGuid& ItemUID, const struct FVector2D& NewDurab);
	void ClientFunc_UpdateStatByUID(const struct FGuid& UID, const struct FGameplayTag& STAT_TAG, double NewValue);
	void ClientFuncHandleReloadResponse(bool Success_, const struct FGuid& UnloadUID, const struct FGuid& UnloadToContainerUID, int32 ToIndex, bool FinalRot, const struct FGuid& ReloadUID, const struct FGuid& ReloadToContainerUID);
	void ClientFuncItemCrafted(const struct FGuid& TempUID, const struct FContainerPickupsInfo& ItemAdded, bool Success_, TArray<struct FGuid>& UpdateUIDs, TArray<int32>& WithCounts, bool IsCraftingStation_, const struct FContainerPickupsInfo& ItemInside);
	void ClientHandleTwoContainersSwap(const struct FGuid& ContainerUID, const struct FGuid& SecondContainerUID, bool Success);
	void ClientSetupSwappingTwoContainers(const struct FGuid& Container, const struct FGuid& SecondaryContainer);
	void ClientUpdateCount(const struct FGuid& ItemUID, int32 NewCount, bool RemoveIf0);
	void Context_TryEquip(class UJSI_Slot_C* EquippedItem, class UJSIContainer_C* JSIRootCont);
	void Context_TryUnequip(class UJSI_Slot_C* EquippedItem, class UJSIContainer_C* JSIRootCont);
	void Context_TryUnloadAmmo(class UJSI_Slot_C* ItemRef, class UJSIContainer_C* RootContainer);
	bool Controller_();
	void DeepSearchForContainer(const struct FGuid& UID, class UJSIContainer_C* Target, class UJSIContainer_C** Array_Element);
	void DeepSearchForItem(const struct FGuid& UID, class UJSI_Slot_C** ItemFound);
	void DetectDuplicateIDs(bool* Result);
	void Drop_ItemOverItem_Event_0(class UJSI_Slot_C* ItemReceiver, class UJSI_Slot_C* ItemDropped, class UJSIContainer_C* ItemReceiverContainer, class UJSIContainer_C* ItemDroppedContainer);
	void DropAllItems();
	void EventOnInventoryAction(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* DroppedSlotRef, class UJSI_Slot_C* SlotReceiverRef, int32 ToSlotIndex, bool Rotated_);
	void EventOnJigItemMouseButtonDown(class UJSIContainer_C* Container, class UJSI_Slot_C* SlotRef, const struct FKey& Button);
	void ExecuteUbergraph_BP_JigMultiplayer(int32 EntryPoint);
	void Find_Actor_Ref_byItemUID(const struct FGuid& UID, class AActor** PickupRef);
	void Find_Pickup_Ref_by_AttachmentMotherUID(const struct FGuid& ContainerUID, class AActor** PickupRef, struct FGuid* ItemUID);
	void FindAndConsume(class UJigsawItem_DataAsset_C* ItemDA, int32 Count);
	void FindCraftingIngredient(class UUserWidget* OneCont, class UJigsawItem_DataAsset_C* ID, int32 Count, TArray<struct FGuid>& Exclude, TArray<class UJSI_Slot_C*>* OutputPin, bool* Result);
	void FindItemByMotherUID(const struct FGuid& MotherUID, bool* Found_, struct FContainerPickupsInfo* FoundItem);
	void FindItemBySubContainerUID(struct FGuid& UID, bool* Found, struct FGuid* ItemUID);
	void FindItemByUID(const struct FGuid& UID, class UJSI_Slot_C** Found);
	void FindItemInContainer(class UJSIContainer_C* InContainer, const struct FGuid& UID, class UJSI_Slot_C** Found);
	void FindJigContainerByUID(struct FGuid& UID, struct FS_ReplicatedContainerInfo* Output, int32* Index_0);
	void FindJigItemByDA(class UJigsawItem_DataAsset_C* DA, const struct FGameplayTagContainer& SearchOnlyInSlots, bool DeepSearch_, bool SearchInEquipTo_, int32 RequiredAmount, bool* Result, class UJSI_Slot_C** Found);
	void FindJSIContainer(const struct FGuid& UID, class UJSIContainer_C** JSIRef, bool* Found);
	void FindRootContainer(const struct FGuid& ContainerUID, struct FGuid* RootCUID);
	void FindRootContainer_Pure(const struct FGuid& ContainerUID, struct FGuid* RootCUID);
	void FireArmChamberWeapon(const struct FGuid& ChamberContainerUID, const struct FGuid& MagContainerUID, const struct FGuid& BulletToChamberUID, int32 ChamberContainerIndex, bool SendChamberUID_);
	void FireArmGetChamberUID(const struct FGuid& ChamberContainerUID);
	void FixUpReferences();
	void FuncHandleCraftingTimers();
	void FuncHandleStackResponse(const struct FGuid& DroppedUID, int32 DropNewCount, const struct FGuid& RecUID, int32 RecNewCount);
	void Generate_AddNewItemToContainer(const struct FGuid& ToContainerUID, class UJigsawItem_DataAsset_C* ItemId, int32 Count, struct FContainerPickupsInfo* AddedItemInfo, bool* Added_);
	void GenerateRandomStats(const struct FS_RandomStatsConfig& RandomConfig, TArray<struct FS_ItemStat>& DTStats, TArray<struct FS_ItemStat>* Stats);
	void Get_Index_From_CraftingArr(TArray<struct FRepItemInfo>& Arr, class UJigsawItem_DataAsset_C* ID, int32* Array_Index);
	void GetAllContainerByItemUID(const struct FGuid& ItemUID, TArray<struct FS_ReplicatedContainerInfo>& ContainersRef);
	void GetAllContainersOfUID(const struct FGuid& ContainerUID, TArray<struct FGuid>& ListFound);
	void GetAllContainersOfUIDCustom(const struct FGuid& ContainerUID, TArray<struct FGuid>& ListFound, TArray<struct FS_ReplicatedContainerInfo>& Containers);
	void GetAllItemsSellPrice(const struct FContainerPickupsInfo& Item, int32 Amount, double* Price);
	void GetCapacity(int32* Output_Get);
	void GetColumnRowBySlotIndex(int32 NumOfColumns, int32 SlotIndex, int32* Column, int32* Row);
	void GetContainerDimensions(class UJigsawItem_DataAsset_C* Asset, TArray<struct FVector2D>* SpecialContainerDemensions);
	void GetContainerIndex(class UJSI_Slot_C* ItemRef, int32* Index_0);
	void GetContainerItemByInContainerIndex(const struct FGuid& ContainerUID, int32 ContainerIndex, bool* Found_, struct FContainerPickupsInfo* FoundItem);
	void GetContainerItems(bool RemoveExcluded_, TArray<struct FContainerPickupsInfo>* AllItems);
	void GetContainerNameByUID(const struct FGuid& UID, class FName* ContainerName);
	void GetCurrencyFromDT(double Price, class UJigsawItem_DataAsset_C* Asset, bool* Found, int32* MaxStack, struct FContainerPickupsInfo* Currency);
	void GetDurability(const struct FGuid& UID, double* NewDur);
	void GetEmptySlot(struct FS_ReplicatedContainerInfo& RepContainer, const struct FVector2D& ItemVec, bool* Found, int32* Index_0);
	void GetEmptySlotTryRotated(struct FS_ReplicatedContainerInfo& RepContainer, const struct FVector2D& ItemVec, bool* Found, int32* Index_0, bool* Rotated_);
	void GetEquippedItemByContainerUID(const struct FGuid& ContainerUID, bool OnlyItems, bool* Found_, bool* IsEquipTo, struct FContainerPickupsInfo* Info);
	void GetHostingSlots(int32 NumOfColumns, int32 SlotIndex, const struct FVector2D& ItemVec, int32 NumOfRows, TArray<int32>* Indexes);
	void GetInventoryWeightByMainContainerName(class FName Name_0, double* Weight);
	void GetInventoryWidgetReference(class UUserWidget** InventoryWidgetRef_0, bool* IsVisible_);
	void GetItemByUID(struct FGuid& UID, struct FContainerPickupsInfo* Item, bool* Found, bool* InMainContainer_);
	void GetListOfAttachments(const struct FGuid& ItemUID, TArray<struct FS_RepAttachmentInfo>* Attachments);
	void GetLocalComp(class UBP_JigMultiplayer_C** JigComp);
	void GetMainContainerUIDByIndex(int32 Index_0, struct FGuid* UID, int32* ContainerIndex);
	void GetMainContainerUIDByName(class FName ContainerName, struct FGuid* UID, int32* Index_0, bool* Found_, bool* IsEquipTo_);
	void GetMainContainerUIDS(TArray<struct FGuid>* UIDs);
	void GetParentItemByContainerUID(const struct FGuid& ContainerUID, struct FContainerPickupsInfo* Array_Element, bool* Found);
	void GetPickupInfoFromDT(class UJigsawItem_DataAsset_C* ID, int32 Count, struct FContainerPickupsInfo* ContainerPickupsInfo, bool* Found);
	void GetSearchableContainers(TArray<class UJSIContainer_C*>* Result);
	int32 GetSlotIndexByColumnRow(int32 NumOfColumns, int32 Column, int32 Row);
	void GetSubContainers(const struct FGuid& UID, TArray<struct FS_ReplicatedContainerInfo>& RepContainerRef, TArray<struct FGuid>& UIDList, TArray<int32>& IndexList, bool SkipCapacity_);
	void GetSubContainersOnce(const struct FGuid& UID, TArray<struct FS_ReplicatedContainerInfo>& RepContainerRef);
	void GetTotalCountOfItem(class UJigsawItem_DataAsset_C* DA, int32* TotalCount);
	void GetTotalInventoryWeight(double* Output_Get);
	void GetUniqueID(struct FGuid* UID);
	struct FVector2D GetVectorRot(const struct FVector2D& Vect, bool Rotated);
	void Handle_Comp_to_Comp_Move(class UBP_JigMultiplayer_C* From, class UBP_JigMultiplayer_C* To, const struct FGuid& ItemUID, bool FinalRotation, int32 ToIndex, const struct FGuid& ToContainer, int32 VendorAmount, const struct FGuid& VendorMoneyToUID, int32 VendorMoneyToIndex);
	void HandleActorEquipped(class AActor* ActorRef, struct FContainerPickupsInfo& ItemAdded, const TArray<struct FContainerPickupsInfo>& ContainerContent);
	void HandleAddNewItem(struct FContainerPickupsInfo& ItemInfo, const TArray<struct FContainerPickupsInfo>& Content);
	void HandleClientMoveItemToIndex(const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool FinalRotation);
	void HandleCraftingTimers();
	void HandleDropRequest(class UDropItemBackGwidget_C* DropWidget);
	void HandleItemOverItem(class UJSIContainer_C* Container);
	void HandleLocalInternalReload(const struct FGuid& MagContainerUID, const struct FGuid& AmmoToAdd, int32 MaxCap);
	void HandleLocalInternalReload_CustomCount(const struct FGuid& MagContainerUID, const struct FGuid& AmmoToAdd, int32 MaxCap);
	void HandleLocalRequestConsumeItem(const struct FGuid& ItemUID, int32 Amount, class UBP_JigMultiplayer_C* LocalComp, const class FString& CustomData, bool CallbackToPlayer_);
	void HandleLocalRequestReloadWeapon(const struct FGuid& UnloadUID, const struct FGuid& UnloadToContainerUID, int32 ToIndex, bool FinalRot, const struct FGuid& ReloadUID, const struct FGuid& ReloadToContainerUID, class AActor* WeaponRef);
	void HandleMainPlayerRequestedData();
	void HandleMouseButtonDown(class UJSIContainer_C* Container);
	void HandleNewItemAdded(const struct FRepItemInfo& ItemInfo, const struct FGuid& UID, const struct FGuid& ToContainerUID, int32 ToIndex, bool FinalRotation, TArray<struct FS_SubContainerInfo>& SubContainers);
	void HandleSameCompSplitResult(const struct FGuid& SourceUID, int32 SourceNewCount, const struct FRepItemInfo& NewItem, const struct FGuid& NewItemUID, const struct FGuid& ToContainerUID, int32 ToSlot, bool Rotated);
	void HandleSameContainerMoveToIndex(const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool Rotated_, class UBP_JigMultiplayer_C* LocalComp, int32 InContainerIndex);
	void HandleServerDropRequest(const struct FGuid& ItemUID, int32 Count, class UBP_JigMultiplayer_C* LocalComp);
	void HandleServerFuncRequestCraft(class UBP_JigMultiplayer_C* CompRef, int32 CraftIndex, TArray<struct FGuid>& ConsumeUIDs, const struct FGuid& AddToContainer, int32 ToIndex, bool FinalRotation, const struct FGuid& TempUID, const struct FGuid& StackWith);
	void HandleServerFuncRequestCraftDrop(class UBP_JigMultiplayer_C* CompRef, int32 CraftIndex, TArray<struct FGuid>& ConsumeUIDs);
	void HandleTwoContainerSwap(const struct FGuid& ContainerUID, const struct FGuid& SecondContainerUID);
	bool HasValidWidgetClass_();
	void InitializeJigComponent();
	void InitialzieInventoryWeight();
	void InitInventoryData();
	void InitNoStartingItems();
	bool IsCraftingStation();
	bool IsEmpty_();
	void IsInventoryVisible_(bool* Result);
	bool IsLocal();
	bool IsLocalPlayer();
	bool IsLootContainer();
	bool IsMainCharacter();
	bool IsPickupComponent();
	bool IsSCSupportedItem(class UBP_MainSpecialContainer_C* Container, class UJigsawItem_DataAsset_C* Item);
	bool IsSupportedItem(class UJigsawItem_DataAsset_C* Container, class UJigsawItem_DataAsset_C* Item);
	bool IsValidPickup(struct FContainerPickupsInfo* PickupInfo_0);
	bool IsVendor();
	void ItemDropRequest_Event_0(class UJSI_Slot_C* ItemRef, int32 Count, class UJSIContainer_C* Container);
	void Jig_UnhandledEvent(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, int32 ToIndex, class UJSI_Slot_C* DroppedItem, bool Rotated, int32 Amount);
	void JigCom_GetType(struct FGameplayTag* Type);
	void JigCom_IsLootContainer(bool* Result);
	void JigCom_IsMainCharacter(bool* Result);
	void JigCom_IsPickup(bool* Result);
	void JigCom_IsVendor(bool* Result);
	void JigComp_AddNewPendingRequest(class UJSI_Slot_C* NewItem, bool* Result);
	void JigComp_CallRequestChamberUID(const struct FGuid& ChamberContainerUID, bool* Result);
	void JigComp_CallRequestReload(const struct FGuid& UnloadUID, const struct FGuid& UnloadToContainerUID, int32 ToIndex, bool FinalRot, const struct FGuid& ReloadUID, const struct FGuid& ReloadToContainerUID, class AActor* WeaponRef, bool* Result);
	void JigComp_CallRequestReloadInternal(const struct FGuid& MagContainerUID, const struct FGuid& AmmoToAdd, int32 MaxCap, bool* Result);
	void JigComp_CallServerChamberWeapon(const struct FGuid& ChamberContainerUID, const struct FGuid& MagContainerUID, const struct FGuid& BulletToChamberUID, int32 ChamberContainerIndex, bool SendChamberUID_, bool* Result);
	void JigComp_CallServerConsumeRequest(class UActorComponent* TargetComp, const struct FGuid& ItemUID, int32 Amount, const class FString& CustomData, bool* Result);
	void JigComp_ContextTryEquip(class UJSI_Slot_C* Item, class UJSIContainer_C* RootContainer, bool* Result);
	void JigComp_ContextTryUnequip(class UJSI_Slot_C* Item, class UJSIContainer_C* RootContainer, bool* Result);
	void JigComp_ContextTryUnloadAmmo(class UJSI_Slot_C* Item, class UJSIContainer_C* RootContainer, bool* Result);
	void JigComp_GetInventoryWidgetRef(class UUserWidget** UserWidget);
	void JigTryAddGetPendingRef(const struct FRepItemInfo& Info, bool CheckStacking, class UJSI_Slot_C** OutputPin, bool* Stack_);
	void JigTryAddItemSomewhere(class UBP_JigMultiplayer_C* LocalComp, class UJigsawItem_DataAsset_C* ItemId, int32 Count, bool* Added_, struct FGuid* UID);
	void JSI_CheckIfCanAddActorToContainer(class AActor* ActorRef, bool TestOnly_, class UJSIContainer_C* ToSpecificContainer, int32 Index_0, bool Rotated, bool* Result, struct FGuid* AddtoUID, struct FGuid* TempItemUID, int32* ToIndex, bool* FinalRotation, class UJSI_Slot_C** JigItemRef);
	void JSI_CheckIfCanAddItemToContainer(class UJSI_Slot_C* ItemRef, bool* Result, class UJSIContainer_C** AddToContainer, int32* ToIndex, bool* FinalRotation);
	void JSI_CheckIfCanAddStackItemToContainer(class UJSI_Slot_C* ItemRef, bool* Result, class UJSI_Slot_C** WithItem);
	void JSI_CheckIfEnoughSpaceToPickupActor(class AActor* ActorRef, bool* Result);
	void JSI_TryEquipToMain(class AActor* PickupRef, class UJSIContainer_C* TargetContainer, bool OnlyTest_, class UJSIContainer_C** EquipTo);
	void JSIFindEmptySpot(class UJSIContainer_C* Container, class UJSI_Slot_C* Item, bool* Found, int32* Index_0, bool* FinalRotation);
	bool LoadJigComponent(TArray<struct FGuid>* ActionbarUIDs);
	void LogData();
	void MainDeepSearchContainer(const struct FGuid& UID, class UJSIContainer_C** Array_Element);
	void MC_AddNewItem(const struct FContainerPickupsInfo& ItemInfo, const TArray<struct FContainerPickupsInfo>& Content);
	void MC_ItemRemoved(const struct FGuid& ItemUID);
	void MC_MoveItemToIndex(class UBP_JigMultiplayer_C* TargetComp, const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool FinalRotation);
	void MC_NewItemAdded(const struct FRepItemInfo& ItemInfo, const struct FGuid& UID, const struct FGuid& ToContainerUID, int32 ToIndex, bool FinalRotation, const struct FS_UpdateCount& UpdateCount, TArray<struct FS_SubContainerInfo>& SubContainers);
	void MC_OnPendingDone(const TArray<struct FContainerPickupsInfo>& Item);
	void MC_SameCompUpdateSplitRequest(const struct FGuid& SourceUID, int32 SourceNewCount, const struct FRepItemInfo& NewItem, const struct FGuid& NewItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool Rotated);
	void MC_UpdateCount(const struct FGuid& ItemUID, int32 NewCount, const struct FGuid& RemovePending);
	void MC_UpdateCounts(const TArray<struct FS_UpdateCount>& Counts);
	void MC_UpdateDurability(const struct FGuid& ItemUID, const struct FVector2D& NewDurab);
	void MC_UpdateStack(const struct FGuid& DroppedUID, int32 DropNewCount, const struct FGuid& RecUID, int32 RecNewCount);
	void MonitorContainerItems();
	void OnItemAddedUpdateWeight(struct FContainerPickupsInfo& Item, TArray<struct FS_ReplicatedContainerInfo>& Content, const struct FGuid& OverrideInUID, int32 OverrideCount);
	void OnItemRemovedUpdateWeight(struct FContainerPickupsInfo& Item, TArray<struct FS_ReplicatedContainerInfo>& Content, int32 OverrideCount);
	void OnItemSplitRequest_Event(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* ItemSource, int32 ToSlotIndex, int32 TotalAmount, int32 SplitAmount, bool Rotated_);
	void OnItemStackRequest_Event(class UJSI_Slot_C* DroppedItem, class UJSI_Slot_C* ReceiverItem);
	void OnRep_MainContainersIDs();
	void Process_Main_Jig_Containers(class FName Name_0, bool IsEquipTo, int32 NumOfColumns, int32 NumOfRows, TArray<struct FRandomContainerItem>& DefaultContainerItems, struct FGuid* ContUID);
	void Process_Multiple(TArray<struct FVector2D>& ContainerColRow, TArray<struct FGuid>* ContainerUIDs);
	void ProcessRefillContainer();
	void ReceiveBeginPlay();
	void RefFillCapacityContainer(const struct FGuid& UID, class UJigsawItem_DataAsset_C* WithItem);
	void RemoveGetInfo(const struct FGuid& UID, int32 RemoveCount, struct FContainerPickupsInfo* ItemInfo, TArray<struct FS_ReplicatedContainerInfo>* RepContainers, int32* VendorNewCount, bool* CountRemoved_);
	void RemoveRequestByUID(const struct FGuid& UID, bool* Removed);
	bool ReplaceLoadJigComponentByIndex(const class FString& SaveName, const int32 UserIndex, int32 ReplaceContainerIndex, TArray<struct FGuid>* ActionbarUIDs);
	void ResetInitComponent();
	bool Save_One_Jig_ContainerByIndex(const class FString& SaveName, const int32 UserIndex, int32 ContainerIndex);
	bool SaveJigComponent(TArray<struct FGuid>& ActionbarUIDs);
	bool SaveMultipleJigContainersByIndexes(const class FString& SaveName, const int32 UserIndex, TArray<int32>& ContainerIndex);
	void SERVER_FireArmChamberWeapon(const struct FGuid& ChamberContainerUID, const struct FGuid& MagContainerUID, const struct FGuid& BulletToChamberUID, int32 ChamberContainerIndex, bool SendChamberUID_);
	void SERVER_ForwardInteract(class AActor* Actor, const struct FGameplayTag& Option, const struct FS_JigPayload& Payload);
	void SERVER_LoadSaveDataFromClientSide(const TArray<struct FS_ReplicatedContainerInfo>& MainJigContainers_0, const TArray<struct FGuid>& MainContainersIDs_0, const TArray<struct FS_InvWeight>& InventoryWeight_0, const TArray<struct FGuid>& ActionbarUIDs);
	void SERVER_RequestActorAddStackItem(class AActor* ActorRef, const struct FGuid& WithUID);
	void SERVER_RequestAddActorToContainer(class AActor* ActorRef, const struct FGuid& AddtoUID, const struct FGuid& TempUID, int32 ToIndex, bool FinalRotation, const TArray<struct FGuid>& Stacks);
	void SERVER_RequestChamberUID(const struct FGuid& ChamberContainerUID);
	void SERVER_RequestConsumeItem(class UBP_JigMultiplayer_C* TargetComp, const struct FGuid& ItemUID, int32 Amount, const class FString& CustomData);
	void SERVER_RequestCraftItem(class UBP_JigMultiplayer_C* CompRef, int32 CraftIndex, const TArray<struct FGuid>& ConsumeUIDs, const struct FGuid& AddToContainer, int32 ToIndex, bool FinalRotation, const struct FGuid& TempUID, const struct FGuid& StackWith);
	void SERVER_RequestCraftItemDrop(class UBP_JigMultiplayer_C* CompRef, int32 CraftIndex, const TArray<struct FGuid>& ConsumeUIDs);
	void SERVER_RequestData(class UBP_JigMultiplayer_C* JigMPCompRef);
	void SERVER_RequestDataFromSave(class UBP_JigMultiplayer_C* JigMPCompRef);
	void SERVER_RequestDropItem(const struct FGuid& ItemUID, int32 Count, class UBP_JigMultiplayer_C* CompTarget);
	void SERVER_RequestEquipActorToContainer(class AActor* ActorRef, const struct FGuid& ToMainUID);
	void SERVER_RequestExpandContainer(const struct FGuid& ContainerUID, int32 AddColumns, int32 AddRows);
	void SERVER_RequestLoadReplaceOneContainerByIndex(const class FString& SaveName, const int32 UserIndex, int32 ReplaceContainerIndex);
	void SERVER_RequestMoveItemToAnotherComp(class UBP_JigMultiplayer_C* From, class UBP_JigMultiplayer_C* To, const struct FGuid& ItemUID, bool FinalRotation, int32 ToIndex, const struct FGuid& ToContainer, int32 VendorAmount, const struct FGuid& VendorMoneyToUID, int32 VendorMoneyToIndex);
	void SERVER_RequestReload(const struct FGuid& UnloadUID, const struct FGuid& UnloadToContainerUID, int32 ToIndex, bool FinalRot, const struct FGuid& ReloadUID, const struct FGuid& ReloadToContainerUID, class AActor* WeaponRef);
	void SERVER_RequestReloadInternal(const struct FGuid& MagContainerUID, const struct FGuid& AmmoToAdd, int32 MaxCap);
	void SERVER_RequestRemoveItem(class UBP_JigMultiplayer_C* TargetComp, const struct FGuid& ItemUID, int32 Amount, bool CallbackToPlayer_);
	void SERVER_RequestSaveGame(class UBP_JigMultiplayer_C* MpRef, const TArray<struct FGuid>& ActionbarUIDs);
	void SERVER_RequestSaveOneJigContainerByIndex(const class FString& SaveName, const int32 UserIndex, int32 ContainerIndex);
	void SERVER_RequestSplitItem(class UBP_JigMultiplayer_C* FromComp, class UBP_JigMultiplayer_C* ToComp, const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, int32 SplitAmount, bool Rotated_);
	void SERVER_RequestStackItem(class UBP_JigMultiplayer_C* FromCom, class UBP_JigMultiplayer_C* ToComp, const struct FGuid& DroppedUID, const struct FGuid& ReceiverUID, int32 MaxStack);
	void SERVER_RequestSwapContainers(const struct FGuid& ContainerUID, const struct FGuid& SecondContainerUID);
	void SERVER_SameContainer_MoveToIndex(class UBP_JigMultiplayer_C* JigMPCompRef, const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool Rotated_, int32 InContainerIndex);
	void SERVER_UpdateStatByUID(const struct FGuid& UID, const struct FGameplayTag& STAT_NAME, double NewValue);
	void ServerFindThenConsumeByItemID(class UJigsawItem_DataAsset_C* ItemId, int32 Count, bool* Result);
	void ServerFunc_HandleMoveToCapacityContainer(class UBP_JigMultiplayer_C* FromComp, class UBP_JigMultiplayer_C* ToComp, const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, bool* Proceed_, bool* Fail_);
	void ServerFunc_HandleRequestAddActorToContainer(class AActor* ActorRef, const struct FGuid& AddtoUID, const struct FGuid& TempUID, int32 ToIndex, bool FinalRotation, TArray<struct FGuid>& Stacks);
	void ServerFunc_ProcessRequestStackAddActor(class AActor* ActorRef, const struct FGuid& WithUID);
	void ServerFunc_RequestStackItem(class UBP_JigMultiplayer_C* FromCom, class UBP_JigMultiplayer_C* ToComp, const struct FGuid& DroppedUID, const struct FGuid& ReceiverUID, int32 MaxStack, bool* Success);
	void ServerFunc_UpdateCustomDataByUID(const struct FGuid& UID, TArray<class FString>& Keys, TArray<class FString>& Values, bool* Updated);
	void ServerFunc_UpdateDurabilityByUID(const struct FGuid& UID, const struct FVector2D& NewDurability, bool* Updated);
	void ServerFuncExpandContainer(const struct FGuid& ContainerUID, int32 AddColumns, int32 AddRows);
	void ServerFuncHandleEquipActor(class AActor* ActorRef, const struct FGuid& ToMainUID);
	void ServerFuncUpdateDurabilityByUID(const struct FGuid& UID, double MinusDur, bool DestroyItemIfZeroDur_, double* NewDur);
	void ServerHandleSplitRequest(class UBP_JigMultiplayer_C* FromComp, class UBP_JigMultiplayer_C* ToComp, const struct FGuid& ItemUID, const struct FGuid& ToContainerUID, int32 ToIndex, int32 SplitAmount, bool Rotated_);
	void ServerUpdateCountByUID(const struct FGuid& ItemUID, int32 NewCount);
	void SetActorRefByItemUID(const struct FGuid& UID, class AActor* ActorRef);
	void SetContainerSettingsFromWidget();
	void SetPermissions(class UJSIContainer_C* JSITarget);
	void SetPickupContainerData(const struct FContainerPickupsInfo& PickupInfo_0, TArray<struct FS_ReplicatedContainerInfo>& MainReplicatedContainers);
	void SetupInventoryWidget(bool ClearInv_, bool ReInitWidget_, bool ForceInitSP_, class UUserWidget** InventoryWidgetRef_0);
	void SetupNewAddedItem(class UJSIContainer_C* JSIRef, TArray<struct FContainerPickupsInfo>& AllItems);
	void SetupWidgetCleanupTimer();
	void SetVendorPriceOfSoldItem(struct FContainerPickupsInfo& Info, TArray<struct FS_ReplicatedContainerInfo>& Containers);
	void StartRefillTimer(bool ClearContainer_);
	void SwapTwoItems(const struct FGuid& Item1, const struct FGuid& Item2, int32 RemoveCount);
	bool TakeMoney(int32 Price, class UJigsawItem_DataAsset_C* Currency, TArray<struct FS_UpdateCount>* UpdateMoneyCount);
	void ToggleInventory();
	void TryAddNewItem(struct FS_ReplicatedContainerInfo& RepContainer, struct FRandomContainerItem& ItemToAdd, bool CheckWeight_, bool TryStacking_, int32 CustomMaxStack, struct FContainerPickupsInfo* AddedItemInfo, bool* Added_, bool* Stacked_);
	bool UIDNotValid(const struct FGuid& InGuid);
	void UpdateCountByByMotherUID(const struct FGuid& MotherUID, int32 NewCount, bool* Updated_);
	void UpdatePickupInfo(const struct FContainerPickupsInfo& PickupInfo_0);
	void UpdateStatByUID(const struct FGuid& UID, const struct FGameplayTag& STAT_TAG, double NewValue);
	void UpdateWeight(const struct FGuid& ContUID, double Weight);
	void VendorCompareItems(struct FContainerPickupsInfo& Item1, TArray<struct FS_ReplicatedContainerInfo>& Item1SubContainers, struct FContainerPickupsInfo& Item2, bool* Proceed_);
	void VendorTryStackMoney(int32 MaxStack, const struct FRepItemInfo& Currency, bool* Stacked_);
	void WaitFullReplicationOfUIDs(bool Reset_);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_JigMultiplayer_C">();
	}
	static class UBP_JigMultiplayer_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_JigMultiplayer_C>();
	}
};
static_assert(alignof(UBP_JigMultiplayer_C) == 0x000008, "Wrong alignment on UBP_JigMultiplayer_C");
static_assert(sizeof(UBP_JigMultiplayer_C) == 0x000300, "Wrong size on UBP_JigMultiplayer_C");
static_assert(offsetof(UBP_JigMultiplayer_C, UberGraphFrame) == 0x0000A0, "Member 'UBP_JigMultiplayer_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, MainJigContainers) == 0x0000A8, "Member 'UBP_JigMultiplayer_C::MainJigContainers' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, LocalJSIContainers) == 0x0000B8, "Member 'UBP_JigMultiplayer_C::LocalJSIContainers' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, MPComponentType) == 0x0000C8, "Member 'UBP_JigMultiplayer_C::MPComponentType' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, PendingRequests) == 0x0000D0, "Member 'UBP_JigMultiplayer_C::PendingRequests' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, MainContainersIDs) == 0x0000E0, "Member 'UBP_JigMultiplayer_C::MainContainersIDs' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, ContainersSettings) == 0x0000F0, "Member 'UBP_JigMultiplayer_C::ContainersSettings' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, RefillContainerTimerInSeconds) == 0x000100, "Member 'UBP_JigMultiplayer_C::RefillContainerTimerInSeconds' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, InventoryWidgetClass) == 0x000108, "Member 'UBP_JigMultiplayer_C::InventoryWidgetClass' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, InventoryWidgetRef) == 0x000110, "Member 'UBP_JigMultiplayer_C::InventoryWidgetRef' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, PendingActors) == 0x000118, "Member 'UBP_JigMultiplayer_C::PendingActors' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, DoesContainerRefillLoot_) == 0x000128, "Member 'UBP_JigMultiplayer_C::DoesContainerRefillLoot_' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, IfPickup_CanLoot_) == 0x000129, "Member 'UBP_JigMultiplayer_C::IfPickup_CanLoot_' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, AllowDroppingItems) == 0x00012A, "Member 'UBP_JigMultiplayer_C::AllowDroppingItems' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, PickupInfo) == 0x000130, "Member 'UBP_JigMultiplayer_C::PickupInfo' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, VendorAcceptedCurrencyID) == 0x000208, "Member 'UBP_JigMultiplayer_C::VendorAcceptedCurrencyID' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, VendorReSellSoldItems_) == 0x000210, "Member 'UBP_JigMultiplayer_C::VendorReSellSoldItems_' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, AllowSellingItemsToVendor_) == 0x000211, "Member 'UBP_JigMultiplayer_C::AllowSellingItemsToVendor_' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, ItemsToCraft) == 0x000218, "Member 'UBP_JigMultiplayer_C::ItemsToCraft' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, ExcludeMainContainerIndexesFromLoot) == 0x000228, "Member 'UBP_JigMultiplayer_C::ExcludeMainContainerIndexesFromLoot' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, MonitorContainerUID) == 0x000238, "Member 'UBP_JigMultiplayer_C::MonitorContainerUID' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, PendingVendorContainerUID) == 0x000248, "Member 'UBP_JigMultiplayer_C::PendingVendorContainerUID' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, PendingVendorToIndex) == 0x000258, "Member 'UBP_JigMultiplayer_C::PendingVendorToIndex' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, PendingVendorFinalRot) == 0x00025C, "Member 'UBP_JigMultiplayer_C::PendingVendorFinalRot' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, ServerVendorRequestedBuyAmount) == 0x000260, "Member 'UBP_JigMultiplayer_C::ServerVendorRequestedBuyAmount' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, InventoryWeight) == 0x000268, "Member 'UBP_JigMultiplayer_C::InventoryWeight' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, ExcludeMainContainerIndexesFromVendorCurrency) == 0x000278, "Member 'UBP_JigMultiplayer_C::ExcludeMainContainerIndexesFromVendorCurrency' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, DebugContent_) == 0x000288, "Member 'UBP_JigMultiplayer_C::DebugContent_' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, Looted_) == 0x000289, "Member 'UBP_JigMultiplayer_C::Looted_' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, RefillTimerHandle) == 0x000290, "Member 'UBP_JigMultiplayer_C::RefillTimerHandle' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, PendingCraftingItems) == 0x000298, "Member 'UBP_JigMultiplayer_C::PendingCraftingItems' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, PendingCraftingTimers) == 0x0002A8, "Member 'UBP_JigMultiplayer_C::PendingCraftingTimers' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, CraftingTimerHandle) == 0x0002B8, "Member 'UBP_JigMultiplayer_C::CraftingTimerHandle' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, OnWeightUpdated) == 0x0002C0, "Member 'UBP_JigMultiplayer_C::OnWeightUpdated' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, OnInventoryOpenClose) == 0x0002D0, "Member 'UBP_JigMultiplayer_C::OnInventoryOpenClose' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, ClientSaveDataReceived) == 0x0002E0, "Member 'UBP_JigMultiplayer_C::ClientSaveDataReceived' has a wrong offset!");
static_assert(offsetof(UBP_JigMultiplayer_C, OnRefillContainer) == 0x0002F0, "Member 'UBP_JigMultiplayer_C::OnRefillContainer' has a wrong offset!");

}

