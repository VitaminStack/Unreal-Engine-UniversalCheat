#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JSIContainer

#include "Basic.hpp"

#include "JSIContainer_classes.hpp"
#include "JSIContainer_parameters.hpp"


namespace SDK
{

// Function JSIContainer.JSIContainer_C.Add_DefaultItems
// (BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::Add_DefaultItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Add_DefaultItems");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.AddItemFromJigRef
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RotateItem_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TryRotated_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Added                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      AddedItemRef                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::AddItemFromJigRef(class UJSI_Slot_C* ItemRef, int32 ToSlot, bool RotateItem_, bool TryRotated_, bool* Added, class UJSI_Slot_C** AddedItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "AddItemFromJigRef");

	Params::JSIContainer_C_AddItemFromJigRef Parms{};

	Parms.ItemRef = ItemRef;
	Parms.ToSlot = ToSlot;
	Parms.RotateItem_ = RotateItem_;
	Parms.TryRotated_ = TryRotated_;

	UObject::ProcessEvent(Func, &Parms);

	if (Added != nullptr)
		*Added = Parms.Added;

	if (AddedItemRef != nullptr)
		*AddedItemRef = Parms.AddedItemRef;
}


// Function JSIContainer.JSIContainer_C.AddMultipleInventoryItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJigsawItem_DataAsset_C*>  ItemIDs                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class UJigsawItem_DataAsset_C*>  NoTAdded                                               (Parm, OutParm)

void UJSIContainer_C::AddMultipleInventoryItems(TArray<class UJigsawItem_DataAsset_C*>& ItemIDs, TArray<class UJigsawItem_DataAsset_C*>* NoTAdded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "AddMultipleInventoryItems");

	Params::JSIContainer_C_AddMultipleInventoryItems Parms{};

	Parms.ItemIDs = std::move(ItemIDs);

	UObject::ProcessEvent(Func, &Parms);

	ItemIDs = std::move(Parms.ItemIDs);

	if (NoTAdded != nullptr)
		*NoTAdded = std::move(Parms.NoTAdded);
}


// Function JSIContainer.JSIContainer_C.AddNewInventoryItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          ItemDA                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TryRotated_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TryToStack_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TriggerEquippedEvent_                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Added                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SlotIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          ItemInfo                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotItemRef                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Stacked_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::AddNewInventoryItem(class UJigsawItem_DataAsset_C* ItemDA, int32 Count, int32 ToSlot, bool Rotated_, bool TryRotated_, bool TryToStack_, bool TriggerEquippedEvent_, bool* Added, int32* SlotIndex, class UJigsawItem_DataAsset_C** ItemInfo, class UJSI_Slot_C** SlotItemRef, bool* Stacked_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "AddNewInventoryItem");

	Params::JSIContainer_C_AddNewInventoryItem Parms{};

	Parms.ItemDA = ItemDA;
	Parms.Count = Count;
	Parms.ToSlot = ToSlot;
	Parms.Rotated_ = Rotated_;
	Parms.TryRotated_ = TryRotated_;
	Parms.TryToStack_ = TryToStack_;
	Parms.TriggerEquippedEvent_ = TriggerEquippedEvent_;

	UObject::ProcessEvent(Func, &Parms);

	if (Added != nullptr)
		*Added = Parms.Added;

	if (SlotIndex != nullptr)
		*SlotIndex = Parms.SlotIndex;

	if (ItemInfo != nullptr)
		*ItemInfo = Parms.ItemInfo;

	if (SlotItemRef != nullptr)
		*SlotItemRef = Parms.SlotItemRef;

	if (Stacked_ != nullptr)
		*Stacked_ = Parms.Stacked_;
}


// Function JSIContainer.JSIContainer_C.AddNewInventoryItem_CustomVector
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Added                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SlotIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          ItemInfo                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotItemRef                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::AddNewInventoryItem_CustomVector(class UJigsawItem_DataAsset_C* ItemId, int32 Count, int32 ToSlot, bool* Added, int32* SlotIndex, class UJigsawItem_DataAsset_C** ItemInfo, class UJSI_Slot_C** SlotItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "AddNewInventoryItem_CustomVector");

	Params::JSIContainer_C_AddNewInventoryItem_CustomVector Parms{};

	Parms.ItemId = ItemId;
	Parms.Count = Count;
	Parms.ToSlot = ToSlot;

	UObject::ProcessEvent(Func, &Parms);

	if (Added != nullptr)
		*Added = Parms.Added;

	if (SlotIndex != nullptr)
		*SlotIndex = Parms.SlotIndex;

	if (ItemInfo != nullptr)
		*ItemInfo = Parms.ItemInfo;

	if (SlotItemRef != nullptr)
		*SlotItemRef = Parms.SlotItemRef;
}


// Function JSIContainer.JSIContainer_C.AddNewItem
// (Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UTexture*                         Image                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     Rarity                                                 (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          ItemInfo                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    SetVector                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Added                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AddedToSlot                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJigsawItem_DataAsset_C*          Info                                                   (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotItemRef                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::AddNewItem(int32 ToSlot, class UTexture* Image, const struct FVector2D& SlotVector, const struct FGameplayTag& Rarity, class UJigsawItem_DataAsset_C* ItemInfo, bool SetVector, int32 Count, bool* Added, int32* AddedToSlot, class UJigsawItem_DataAsset_C** Info, class UJSI_Slot_C** SlotItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "AddNewItem");

	Params::JSIContainer_C_AddNewItem Parms{};

	Parms.ToSlot = ToSlot;
	Parms.Image = Image;
	Parms.SlotVector = std::move(SlotVector);
	Parms.Rarity = std::move(Rarity);
	Parms.ItemInfo = ItemInfo;
	Parms.SetVector = SetVector;
	Parms.Count = Count;

	UObject::ProcessEvent(Func, &Parms);

	if (Added != nullptr)
		*Added = Parms.Added;

	if (AddedToSlot != nullptr)
		*AddedToSlot = Parms.AddedToSlot;

	if (Info != nullptr)
		*Info = Parms.Info;

	if (SlotItemRef != nullptr)
		*SlotItemRef = Parms.SlotItemRef;
}


// Function JSIContainer.JSIContainer_C.AddSortHighlightedTypes
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            Types                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UJSIContainer_C::AddSortHighlightedTypes(const struct FGameplayTagContainer& Types)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "AddSortHighlightedTypes");

	Params::JSIContainer_C_AddSortHighlightedTypes Parms{};

	Parms.Types = std::move(Types);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.AdjustFromXY
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                        ItemVe                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::AdjustFromXY(const struct FVector2D& ItemVe)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "AdjustFromXY");

	Params::JSIContainer_C_AdjustFromXY Parms{};

	Parms.ItemVe = std::move(ItemVe);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.CalculateSize
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector2D UJSIContainer_C::CalculateSize(const struct FVector2D& SlotVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CalculateSize");

	Params::JSIContainer_C_CalculateSize Parms{};

	Parms.SlotVector = std::move(SlotVector);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.CalculateSizeCustom
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        CSlotSize                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector2D UJSIContainer_C::CalculateSizeCustom(const struct FVector2D& SlotVector, const struct FVector2D& CSlotSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CalculateSizeCustom");

	Params::JSIContainer_C_CalculateSizeCustom Parms{};

	Parms.SlotVector = std::move(SlotVector);
	Parms.CSlotSize = std::move(CSlotSize);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.CalculateWeight
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Weight                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CalculateWeight(double* Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CalculateWeight");

	Params::JSIContainer_C_CalculateWeight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Weight != nullptr)
		*Weight = Parms.Weight;
}


// Function JSIContainer.JSIContainer_C.Call_ContainerOnContainer
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ToSlotRef                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DragRotated_                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TryRotated_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Call_ContainerOnContainer(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotRef, class UJSI_Slot_C* ToSlotRef, int32 ToSlot, bool DragRotated_, bool TryRotated_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Call_ContainerOnContainer");

	Params::JSIContainer_C_Call_ContainerOnContainer Parms{};

	Parms.FromContainer = FromContainer;
	Parms.ToContainer = ToContainer;
	Parms.SlotRef = SlotRef;
	Parms.ToSlotRef = ToSlotRef;
	Parms.ToSlot = ToSlot;
	Parms.DragRotated_ = DragRotated_;
	Parms.TryRotated_ = TryRotated_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.CanAddItemToSlot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        ItemVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TryRotated_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RotatedVector_                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CanAddItemToSlot(int32 ToSlot, const struct FVector2D& ItemVector, bool TryRotated_, bool* Result, bool* RotatedVector_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CanAddItemToSlot");

	Params::JSIContainer_C_CanAddItemToSlot Parms{};

	Parms.ToSlot = ToSlot;
	Parms.ItemVector = std::move(ItemVector);
	Parms.TryRotated_ = TryRotated_;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (RotatedVector_ != nullptr)
		*RotatedVector_ = Parms.RotatedVector_;
}


// Function JSIContainer.JSIContainer_C.CanAddItemToSlot_IgnoreItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        ItemVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TryRotated_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UJSI_Slot_C*>              IgnoreItems                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RotatedVector_                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CanAddItemToSlot_IgnoreItems(int32 ToSlot, const struct FVector2D& ItemVector, bool TryRotated_, TArray<class UJSI_Slot_C*>& IgnoreItems, bool* Result, bool* RotatedVector_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CanAddItemToSlot_IgnoreItems");

	Params::JSIContainer_C_CanAddItemToSlot_IgnoreItems Parms{};

	Parms.ToSlot = ToSlot;
	Parms.ItemVector = std::move(ItemVector);
	Parms.TryRotated_ = TryRotated_;
	Parms.IgnoreItems = std::move(IgnoreItems);

	UObject::ProcessEvent(Func, &Parms);

	IgnoreItems = std::move(Parms.IgnoreItems);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (RotatedVector_ != nullptr)
		*RotatedVector_ = Parms.RotatedVector_;
}


// Function JSIContainer.JSIContainer_C.CancelHighlights
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::CancelHighlights()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CancelHighlights");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.CanResize?
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   AddToX                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AddToY                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UJSI_Slot_C*>              HostingSlotsArray                                      (Parm, OutParm, ContainsInstancedReference)
// TArray<class UJSI_Slot_C*>              FreedHostingSlotsArray                                 (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::CanResize_(class UJSI_Slot_C* SlotRef, int32 AddToX, int32 AddToY, bool* Result, TArray<class UJSI_Slot_C*>* HostingSlotsArray, TArray<class UJSI_Slot_C*>* FreedHostingSlotsArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CanResize?");

	Params::JSIContainer_C_CanResize_ Parms{};

	Parms.SlotRef = SlotRef;
	Parms.AddToX = AddToX;
	Parms.AddToY = AddToY;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;

	if (HostingSlotsArray != nullptr)
		*HostingSlotsArray = std::move(Parms.HostingSlotsArray);

	if (FreedHostingSlotsArray != nullptr)
		*FreedHostingSlotsArray = std::move(Parms.FreedHostingSlotsArray);
}


// Function JSIContainer.JSIContainer_C.CanStack?
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    CanStack                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CanStack_(class UJSIContainer_C* Container, class UJSI_Slot_C* ItemRef, bool* CanStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CanStack?");

	Params::JSIContainer_C_CanStack_ Parms{};

	Parms.Container = Container;
	Parms.ItemRef = ItemRef;

	UObject::ProcessEvent(Func, &Parms);

	if (CanStack != nullptr)
		*CanStack = Parms.CanStack;
}


// Function JSIContainer.JSIContainer_C.CanStackSingleSlot?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJigsawItem_DataAsset_C*          Info                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      WithItem                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Sucess                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemRef                                                (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CanStackSingleSlot_(class UJigsawItem_DataAsset_C* Info, int32 Count, class UJSI_Slot_C* WithItem, bool* Sucess, class UJSI_Slot_C** ItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CanStackSingleSlot?");

	Params::JSIContainer_C_CanStackSingleSlot_ Parms{};

	Parms.Info = Info;
	Parms.Count = Count;
	Parms.WithItem = WithItem;

	UObject::ProcessEvent(Func, &Parms);

	if (Sucess != nullptr)
		*Sucess = Parms.Sucess;

	if (ItemRef != nullptr)
		*ItemRef = Parms.ItemRef;
}


// Function JSIContainer.JSIContainer_C.ChangeItemCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Changed_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ChangeItemCount(class UJSI_Slot_C* ItemRef, int32 NewCount, bool* Changed_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ChangeItemCount");

	Params::JSIContainer_C_ChangeItemCount Parms{};

	Parms.ItemRef = ItemRef;
	Parms.NewCount = NewCount;

	UObject::ProcessEvent(Func, &Parms);

	if (Changed_ != nullptr)
		*Changed_ = Parms.Changed_;
}


// Function JSIContainer.JSIContainer_C.ChangeItemImage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UTexture2D*                       NewTexture                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Changed_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ChangeItemImage(class UJSI_Slot_C* ItemRef, class UTexture2D* NewTexture, bool* Changed_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ChangeItemImage");

	Params::JSIContainer_C_ChangeItemImage Parms{};

	Parms.ItemRef = ItemRef;
	Parms.NewTexture = NewTexture;

	UObject::ProcessEvent(Func, &Parms);

	if (Changed_ != nullptr)
		*Changed_ = Parms.Changed_;
}


// Function JSIContainer.JSIContainer_C.ChangeItemRarity
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     NewRarity                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    Changed_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ChangeItemRarity(class UJSI_Slot_C* ItemRef, const struct FGameplayTag& NewRarity, bool* Changed_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ChangeItemRarity");

	Params::JSIContainer_C_ChangeItemRarity Parms{};

	Parms.ItemRef = ItemRef;
	Parms.NewRarity = std::move(NewRarity);

	UObject::ProcessEvent(Func, &Parms);

	if (Changed_ != nullptr)
		*Changed_ = Parms.Changed_;
}


// Function JSIContainer.JSIContainer_C.ChangeItemsInteract
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Interact_                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ChangeItemsInteract(bool Interact_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ChangeItemsInteract");

	Params::JSIContainer_C_ChangeItemsInteract Parms{};

	Parms.Interact_ = Interact_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.CheckIfCanAddToSpecial
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemSP                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemToAdd                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    CheckBlind_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DigDeeper_                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CanAdd                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckIfCanAddToSpecial(class UJSI_Slot_C* ItemSP, class UJSI_Slot_C* ItemToAdd, bool CheckBlind_, bool DigDeeper_, bool* CanAdd, class UJSIContainer_C** ToContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckIfCanAddToSpecial");

	Params::JSIContainer_C_CheckIfCanAddToSpecial Parms{};

	Parms.ItemSP = ItemSP;
	Parms.ItemToAdd = ItemToAdd;
	Parms.CheckBlind_ = CheckBlind_;
	Parms.DigDeeper_ = DigDeeper_;

	UObject::ProcessEvent(Func, &Parms);

	if (CanAdd != nullptr)
		*CanAdd = Parms.CanAdd;

	if (ToContainer != nullptr)
		*ToContainer = Parms.ToContainer;
}


// Function JSIContainer.JSIContainer_C.CheckIfCanStack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      WithItemRef                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Sucess                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemRef                                                (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckIfCanStack(class UJSI_Slot_C* WithItemRef, bool* Sucess, class UJSI_Slot_C** ItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckIfCanStack");

	Params::JSIContainer_C_CheckIfCanStack Parms{};

	Parms.WithItemRef = WithItemRef;

	UObject::ProcessEvent(Func, &Parms);

	if (Sucess != nullptr)
		*Sucess = Parms.Sucess;

	if (ItemRef != nullptr)
		*ItemRef = Parms.ItemRef;
}


// Function JSIContainer.JSIContainer_C.CheckIfCapacityContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::CheckIfCapacityContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckIfCapacityContainer");

	Params::JSIContainer_C_CheckIfCapacityContainer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.CheckKey
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FKeyEvent                        Input                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// struct FKey                             B                                                      (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// bool                                    Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckKey(const struct FKeyEvent& Input, const struct FKey& B, bool* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckKey");

	Params::JSIContainer_C_CheckKey Parms{};

	Parms.Input = std::move(Input);
	Parms.B = std::move(B);

	UObject::ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function JSIContainer.JSIContainer_C.CheckLimitedEquipToStack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      DroppedSlotRef                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UDragWidget_C*                    DragWidgetRef                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      FixedSlotRef                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Handled_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckLimitedEquipToStack(class UJSI_Slot_C* DroppedSlotRef, class UDragWidget_C* DragWidgetRef, class UJSI_Slot_C* FixedSlotRef, bool* Handled_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckLimitedEquipToStack");

	Params::JSIContainer_C_CheckLimitedEquipToStack Parms{};

	Parms.DroppedSlotRef = DroppedSlotRef;
	Parms.DragWidgetRef = DragWidgetRef;
	Parms.FixedSlotRef = FixedSlotRef;

	UObject::ProcessEvent(Func, &Parms);

	if (Handled_ != nullptr)
		*Handled_ = Parms.Handled_;
}


// Function JSIContainer.JSIContainer_C.CheckRootContainer
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      DraggedItem                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Proceed_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckRootContainer(class UJSI_Slot_C* DraggedItem, bool* Proceed_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckRootContainer");

	Params::JSIContainer_C_CheckRootContainer Parms{};

	Parms.DraggedItem = DraggedItem;

	UObject::ProcessEvent(Func, &Parms);

	if (Proceed_ != nullptr)
		*Proceed_ = Parms.Proceed_;
}


// Function JSIContainer.JSIContainer_C.CheckUnhandledSplit
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      DroppedSlotRef                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UDragWidget_C*                    DragWidgetRef                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      FixedSlotRef                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    DroppedRotated_                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Handled_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckUnhandledSplit(class UJSI_Slot_C* DroppedSlotRef, class UDragWidget_C* DragWidgetRef, class UJSI_Slot_C* FixedSlotRef, bool DroppedRotated_, bool* Handled_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckUnhandledSplit");

	Params::JSIContainer_C_CheckUnhandledSplit Parms{};

	Parms.DroppedSlotRef = DroppedSlotRef;
	Parms.DragWidgetRef = DragWidgetRef;
	Parms.FixedSlotRef = FixedSlotRef;
	Parms.DroppedRotated_ = DroppedRotated_;

	UObject::ProcessEvent(Func, &Parms);

	if (Handled_ != nullptr)
		*Handled_ = Parms.Handled_;
}


// Function JSIContainer.JSIContainer_C.CheckUnhandledStack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      DropedSlotRef                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      FixedSlotRef                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckUnhandledStack(class UJSI_Slot_C* DropedSlotRef, class UJSI_Slot_C* FixedSlotRef, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckUnhandledStack");

	Params::JSIContainer_C_CheckUnhandledStack Parms{};

	Parms.DropedSlotRef = DropedSlotRef;
	Parms.FixedSlotRef = FixedSlotRef;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JSIContainer.JSIContainer_C.CheckWeightLimit
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  ItemWeight                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CheckWeightLimit(double ItemWeight, class UJSIContainer_C* FromContainer, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CheckWeightLimit");

	Params::JSIContainer_C_CheckWeightLimit Parms{};

	Parms.ItemWeight = ItemWeight;
	Parms.FromContainer = FromContainer;

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JSIContainer.JSIContainer_C.ClearContainer
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::ClearContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ClearContainer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.ClearData
// (BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::ClearData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ClearData");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.ClearItemFromArr
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer_                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    TriggerUnequippedEvent_                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Removed                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ClearItemFromArr(class UJSI_Slot_C* SlotRef, class UJSIContainer_C* ToContainer_, bool TriggerUnequippedEvent_, bool* Removed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ClearItemFromArr");

	Params::JSIContainer_C_ClearItemFromArr Parms{};

	Parms.SlotRef = SlotRef;
	Parms.ToContainer_ = ToContainer_;
	Parms.TriggerUnequippedEvent_ = TriggerUnequippedEvent_;

	UObject::ProcessEvent(Func, &Parms);

	if (Removed != nullptr)
		*Removed = Parms.Removed;
}


// Function JSIContainer.JSIContainer_C.CombineItemRequest
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRec                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotDropped                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    TriggerEventDispatcher_                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::CombineItemRequest(class UJSIContainer_C* FromContainer, class UJSI_Slot_C* SlotRec, class UJSI_Slot_C* SlotDropped, bool TriggerEventDispatcher_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CombineItemRequest");

	Params::JSIContainer_C_CombineItemRequest Parms{};

	Parms.FromContainer = FromContainer;
	Parms.SlotRec = SlotRec;
	Parms.SlotDropped = SlotDropped;
	Parms.TriggerEventDispatcher_ = TriggerEventDispatcher_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.CompareItems
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      Item1                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      Item2                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::CompareItems(class UJSI_Slot_C* Item1, class UJSI_Slot_C* Item2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "CompareItems");

	Params::JSIContainer_C_CompareItems Parms{};

	Parms.Item1 = Item1;
	Parms.Item2 = Item2;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.ControllerHighlightItem
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ControllerHighlightItem(int32 Index_0, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ControllerHighlightItem");

	Params::JSIContainer_C_ControllerHighlightItem Parms{};

	Parms.Index_0 = Index_0;
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Deep Search for Item by ID
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    SearchInEquipTo_                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemRef                                                (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Deep_Search_for_Item_by_ID(class UJigsawItem_DataAsset_C* ItemId, bool SearchInEquipTo_, class UJSI_Slot_C** ItemRef, bool* Found_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Deep Search for Item by ID");

	Params::JSIContainer_C_Deep_Search_for_Item_by_ID Parms{};

	Parms.ItemId = ItemId;
	Parms.SearchInEquipTo_ = SearchInEquipTo_;

	UObject::ProcessEvent(Func, &Parms);

	if (ItemRef != nullptr)
		*ItemRef = Parms.ItemRef;

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;
}


// Function JSIContainer.JSIContainer_C.Deep_GettAllItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSI_Slot_C*>              ArrByRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)

void UJSIContainer_C::Deep_GettAllItems(TArray<class UJSI_Slot_C*>& ArrByRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Deep_GettAllItems");

	Params::JSIContainer_C_Deep_GettAllItems Parms{};

	Parms.ArrByRef = std::move(ArrByRef);

	UObject::ProcessEvent(Func, &Parms);

	ArrByRef = std::move(Parms.ArrByRef);
}


// Function JSIContainer.JSIContainer_C.Deep_GettAllItemsByID
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSI_Slot_C*>              ArrByRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class UJigsawItem_DataAsset_C*          DA                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    IncludeEquippedItems_                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Deep_GettAllItemsByID(TArray<class UJSI_Slot_C*>& ArrByRef, class UJigsawItem_DataAsset_C* DA, bool IncludeEquippedItems_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Deep_GettAllItemsByID");

	Params::JSIContainer_C_Deep_GettAllItemsByID Parms{};

	Parms.ArrByRef = std::move(ArrByRef);
	Parms.DA = DA;
	Parms.IncludeEquippedItems_ = IncludeEquippedItems_;

	UObject::ProcessEvent(Func, &Parms);

	ArrByRef = std::move(Parms.ArrByRef);
}


// Function JSIContainer.JSIContainer_C.Destruct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UJSIContainer_C::Destruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Destruct");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.DifficultyCheckBackpack?
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      SlotToCheck                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    CarryOn_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::DifficultyCheckBackpack_(class UJSI_Slot_C* SlotToCheck, bool* CarryOn_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "DifficultyCheckBackpack?");

	Params::JSIContainer_C_DifficultyCheckBackpack_ Parms{};

	Parms.SlotToCheck = SlotToCheck;

	UObject::ProcessEvent(Func, &Parms);

	if (CarryOn_ != nullptr)
		*CarryOn_ = Parms.CarryOn_;
}


// Function JSIContainer.JSIContainer_C.DoesItemExist
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::DoesItemExist(class UJSI_Slot_C* ItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "DoesItemExist");

	Params::JSIContainer_C_DoesItemExist Parms{};

	Parms.ItemRef = ItemRef;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.DragSelectContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSIContainer_C*                  MotherC                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotReceiver                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  MotherRef                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::DragSelectContainer(class UJSIContainer_C* MotherC, class UJSI_Slot_C* SlotReceiver, class UJSIContainer_C** MotherRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "DragSelectContainer");

	Params::JSIContainer_C_DragSelectContainer Parms{};

	Parms.MotherC = MotherC;
	Parms.SlotReceiver = SlotReceiver;

	UObject::ProcessEvent(Func, &Parms);

	if (MotherRef != nullptr)
		*MotherRef = Parms.MotherRef;
}


// Function JSIContainer.JSIContainer_C.DummyFunction
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::DummyFunction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "DummyFunction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.EquipItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  SlotContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    TriggerEquippedEvent_                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Equipped                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotItemRef                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::EquipItem(class UJigsawItem_DataAsset_C* ItemId, int32 Count, class UJSIContainer_C* SlotContainer, bool TriggerEquippedEvent_, bool* Equipped, class UJSI_Slot_C** SlotItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "EquipItem");

	Params::JSIContainer_C_EquipItem Parms{};

	Parms.ItemId = ItemId;
	Parms.Count = Count;
	Parms.SlotContainer = SlotContainer;
	Parms.TriggerEquippedEvent_ = TriggerEquippedEvent_;

	UObject::ProcessEvent(Func, &Parms);

	if (Equipped != nullptr)
		*Equipped = Parms.Equipped;

	if (SlotItemRef != nullptr)
		*SlotItemRef = Parms.SlotItemRef;
}


// Function JSIContainer.JSIContainer_C.EquipItemFromJigRef
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    CallEquipEvent_                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Added                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      EquippedItemRef                                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::EquipItemFromJigRef(class UJSI_Slot_C* ItemRef, bool CallEquipEvent_, bool* Added, class UJSI_Slot_C** EquippedItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "EquipItemFromJigRef");

	Params::JSIContainer_C_EquipItemFromJigRef Parms{};

	Parms.ItemRef = ItemRef;
	Parms.CallEquipEvent_ = CallEquipEvent_;

	UObject::ProcessEvent(Func, &Parms);

	if (Added != nullptr)
		*Added = Parms.Added;

	if (EquippedItemRef != nullptr)
		*EquippedItemRef = Parms.EquippedItemRef;
}


// Function JSIContainer.JSIContainer_C.ExecuteUbergraph_JSIContainer
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ExecuteUbergraph_JSIContainer(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ExecuteUbergraph_JSIContainer");

	Params::JSIContainer_C_ExecuteUbergraph_JSIContainer Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.ExpandContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   AddColumns                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AddRows                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ExpandContainer(int32 AddColumns, int32 AddRows, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ExpandContainer");

	Params::JSIContainer_C_ExpandContainer Parms{};

	Parms.AddColumns = AddColumns;
	Parms.AddRows = AddRows;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function JSIContainer.JSIContainer_C.FindBestStackingItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   DroppedItemCount                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      BestStackingItem                                       (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   FreeSpace                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CanStackAll                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::FindBestStackingItem(class FName ItemId, int32 DroppedItemCount, class UJSI_Slot_C** BestStackingItem, int32* FreeSpace, bool* CanStackAll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "FindBestStackingItem");

	Params::JSIContainer_C_FindBestStackingItem Parms{};

	Parms.ItemId = ItemId;
	Parms.DroppedItemCount = DroppedItemCount;

	UObject::ProcessEvent(Func, &Parms);

	if (BestStackingItem != nullptr)
		*BestStackingItem = Parms.BestStackingItem;

	if (FreeSpace != nullptr)
		*FreeSpace = Parms.FreeSpace;

	if (CanStackAll != nullptr)
		*CanStackAll = Parms.CanStackAll;
}


// Function JSIContainer.JSIContainer_C.FindNearestToColumnRow
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Reverse                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CheckCol                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  UP_                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Right_                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Flip_                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      Output_Get                                             (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RetReverse                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    RetCheckCol                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RetUP_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RetRight_                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::FindNearestToColumnRow(bool Reverse, bool CheckCol, double UP_, double Right_, bool Flip_, class UJSI_Slot_C** Output_Get, int32* Index_0, bool* RetReverse, bool* RetCheckCol, double* RetUP_, double* RetRight_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "FindNearestToColumnRow");

	Params::JSIContainer_C_FindNearestToColumnRow Parms{};

	Parms.Reverse = Reverse;
	Parms.CheckCol = CheckCol;
	Parms.UP_ = UP_;
	Parms.Right_ = Right_;
	Parms.Flip_ = Flip_;

	UObject::ProcessEvent(Func, &Parms);

	if (Output_Get != nullptr)
		*Output_Get = Parms.Output_Get;

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;

	if (RetReverse != nullptr)
		*RetReverse = Parms.RetReverse;

	if (RetCheckCol != nullptr)
		*RetCheckCol = Parms.RetCheckCol;

	if (RetUP_ != nullptr)
		*RetUP_ = Parms.RetUP_;

	if (RetRight_ != nullptr)
		*RetRight_ = Parms.RetRight_;
}


// Function JSIContainer.JSIContainer_C.FindSlotByIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::FindSlotByIndex(int32 Index_0, class UJSI_Slot_C** SlotRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "FindSlotByIndex");

	Params::JSIContainer_C_FindSlotByIndex Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	if (SlotRef != nullptr)
		*SlotRef = Parms.SlotRef;
}


// Function JSIContainer.JSIContainer_C.FlipSlotDim
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        Flipped                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::FlipSlotDim(const struct FVector2D& SlotVector, struct FVector2D* Flipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "FlipSlotDim");

	Params::JSIContainer_C_FlipSlotDim Parms{};

	Parms.SlotVector = std::move(SlotVector);

	UObject::ProcessEvent(Func, &Parms);

	if (Flipped != nullptr)
		*Flipped = std::move(Parms.Flipped);
}


// Function JSIContainer.JSIContainer_C.ForceInitSpecialcontainer
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::ForceInitSpecialcontainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ForceInitSpecialcontainer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.Get Slot Index by Column Row
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Column                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Row                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UJSIContainer_C::Get_Slot_Index_by_Column_Row(int32 Column, int32 Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Get Slot Index by Column Row");

	Params::JSIContainer_C_Get_Slot_Index_by_Column_Row Parms{};

	Parms.Column = Column;
	Parms.Row = Row;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.GetAllAttachments
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     Attachments                                            (Parm, OutParm)

void UJSIContainer_C::GetAllAttachments(TArray<class FName>* Attachments)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetAllAttachments");

	Params::JSIContainer_C_GetAllAttachments Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Attachments != nullptr)
		*Attachments = std::move(Parms.Attachments);
}


// Function JSIContainer.JSIContainer_C.GetCapacity
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Cap                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetCapacity(int32* Cap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetCapacity");

	Params::JSIContainer_C_GetCapacity Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Cap != nullptr)
		*Cap = Parms.Cap;
}


// Function JSIContainer.JSIContainer_C.GetColumnRowBySlotIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Column                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Row                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetColumnRowBySlotIndex(int32 SlotIndex, int32* Column, int32* Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetColumnRowBySlotIndex");

	Params::JSIContainer_C_GetColumnRowBySlotIndex Parms{};

	Parms.SlotIndex = SlotIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Column != nullptr)
		*Column = Parms.Column;

	if (Row != nullptr)
		*Row = Parms.Row;
}


// Function JSIContainer.JSIContainer_C.GetColumnRowBySlotIndex_NonPure
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Column                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Row                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetColumnRowBySlotIndex_NonPure(int32 SlotIndex, int32* Column, int32* Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetColumnRowBySlotIndex_NonPure");

	Params::JSIContainer_C_GetColumnRowBySlotIndex_NonPure Parms{};

	Parms.SlotIndex = SlotIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Column != nullptr)
		*Column = Parms.Column;

	if (Row != nullptr)
		*Row = Parms.Row;
}


// Function JSIContainer.JSIContainer_C.GetContainerByAttachmentType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  JigContainer                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ContainerIndex                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetContainerByAttachmentType(const struct FGameplayTag& Type, class UJSIContainer_C** JigContainer, int32* ContainerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetContainerByAttachmentType");

	Params::JSIContainer_C_GetContainerByAttachmentType Parms{};

	Parms.Type = std::move(Type);

	UObject::ProcessEvent(Func, &Parms);

	if (JigContainer != nullptr)
		*JigContainer = Parms.JigContainer;

	if (ContainerIndex != nullptr)
		*ContainerIndex = Parms.ContainerIndex;
}


// Function JSIContainer.JSIContainer_C.GetContainerHierarchy
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSIContainer_C*>          Containers                                             (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetContainerHierarchy(TArray<class UJSIContainer_C*>* Containers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetContainerHierarchy");

	Params::JSIContainer_C_GetContainerHierarchy Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Containers != nullptr)
		*Containers = std::move(Parms.Containers);
}


// Function JSIContainer.JSIContainer_C.GetContainerIndex
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetContainerIndex(int32* Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetContainerIndex");

	Params::JSIContainer_C_GetContainerIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Index_0 != nullptr)
		*Index_0 = Parms.Index_0;
}


// Function JSIContainer.JSIContainer_C.GetContainerName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             ContainerName_0                                        (Parm, OutParm)

void UJSIContainer_C::GetContainerName(class FText* ContainerName_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetContainerName");

	Params::JSIContainer_C_GetContainerName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ContainerName_0 != nullptr)
		*ContainerName_0 = std::move(Parms.ContainerName_0);
}


// Function JSIContainer.JSIContainer_C.GetContainersFromEquipped
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSIContainer_C*>          Container                                              (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetContainersFromEquipped(TArray<class UJSIContainer_C*>* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetContainersFromEquipped");

	Params::JSIContainer_C_GetContainersFromEquipped Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Container != nullptr)
		*Container = std::move(Parms.Container);
}


// Function JSIContainer.JSIContainer_C.GetDropWidget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UDropItemBackGwidget_C*           DropWRef                                               (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetDropWidget(class UDropItemBackGwidget_C** DropWRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetDropWidget");

	Params::JSIContainer_C_GetDropWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (DropWRef != nullptr)
		*DropWRef = Parms.DropWRef;
}


// Function JSIContainer.JSIContainer_C.GetEmptySlot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   SlotIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetEmptySlot(const struct FVector2D& SlotVector, int32* SlotIndex, bool* Found_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetEmptySlot");

	Params::JSIContainer_C_GetEmptySlot Parms{};

	Parms.SlotVector = std::move(SlotVector);

	UObject::ProcessEvent(Func, &Parms);

	if (SlotIndex != nullptr)
		*SlotIndex = Parms.SlotIndex;

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;
}


// Function JSIContainer.JSIContainer_C.GetEmptySlotTryRotated
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetEmptySlotTryRotated(const struct FVector2D& SlotVector, bool* Found_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetEmptySlotTryRotated");

	Params::JSIContainer_C_GetEmptySlotTryRotated Parms{};

	Parms.SlotVector = std::move(SlotVector);

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;
}


// Function JSIContainer.JSIContainer_C.GetEmptySlotTryRotated_NonPure
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlotIndex                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetEmptySlotTryRotated_NonPure(const struct FVector2D& SlotVector, bool* Found_, int32* ToSlotIndex, bool* Rotated_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetEmptySlotTryRotated_NonPure");

	Params::JSIContainer_C_GetEmptySlotTryRotated_NonPure Parms{};

	Parms.SlotVector = std::move(SlotVector);

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (ToSlotIndex != nullptr)
		*ToSlotIndex = Parms.ToSlotIndex;

	if (Rotated_ != nullptr)
		*Rotated_ = Parms.Rotated_;
}


// Function JSIContainer.JSIContainer_C.GetEquippedItemRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemRef                                                (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    IsPending                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetEquippedItemRef(bool* Found_, class UJSI_Slot_C** ItemRef, bool* IsPending)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetEquippedItemRef");

	Params::JSIContainer_C_GetEquippedItemRef Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (ItemRef != nullptr)
		*ItemRef = Parms.ItemRef;

	if (IsPending != nullptr)
		*IsPending = Parms.IsPending;
}


// Function JSIContainer.JSIContainer_C.GetFreeSpaceIfCapacityContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UJSIContainer_C::GetFreeSpaceIfCapacityContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetFreeSpaceIfCapacityContainer");

	Params::JSIContainer_C_GetFreeSpaceIfCapacityContainer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.GetHighestCapacityContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSI_Slot_C*>              Items                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// class UJSI_Slot_C*                      Output_Get                                             (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetHighestCapacityContainer(TArray<class UJSI_Slot_C*>& Items, class UJSI_Slot_C** Output_Get)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetHighestCapacityContainer");

	Params::JSIContainer_C_GetHighestCapacityContainer Parms{};

	Parms.Items = std::move(Items);

	UObject::ProcessEvent(Func, &Parms);

	Items = std::move(Parms.Items);

	if (Output_Get != nullptr)
		*Output_Get = Parms.Output_Get;
}


// Function JSIContainer.JSIContainer_C.GetHostingSlots
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        ItemVec                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<int32>                           Indexes                                                (Parm, OutParm)

void UJSIContainer_C::GetHostingSlots(int32 SlotIndex, const struct FVector2D& ItemVec, TArray<int32>* Indexes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetHostingSlots");

	Params::JSIContainer_C_GetHostingSlots Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.ItemVec = std::move(ItemVec);

	UObject::ProcessEvent(Func, &Parms);

	if (Indexes != nullptr)
		*Indexes = std::move(Parms.Indexes);
}


// Function JSIContainer.JSIContainer_C.GetImageFromInfo
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJigsawItem_DataAsset_C*          Info                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UTexture*                         Image                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetImageFromInfo(class UJigsawItem_DataAsset_C* Info, class UTexture** Image)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetImageFromInfo");

	Params::JSIContainer_C_GetImageFromInfo Parms{};

	Parms.Info = Info;

	UObject::ProcessEvent(Func, &Parms);

	if (Image != nullptr)
		*Image = Parms.Image;
}


// Function JSIContainer.JSIContainer_C.GetInventoryItemsByID
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJigsawItem_DataAsset_C*          ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UJSI_Slot_C*>              ItemsFound                                             (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetInventoryItemsByID(class UJigsawItem_DataAsset_C* ItemId, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetInventoryItemsByID");

	Params::JSIContainer_C_GetInventoryItemsByID Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (ItemsFound != nullptr)
		*ItemsFound = std::move(Parms.ItemsFound);
}


// Function JSIContainer.JSIContainer_C.GetInventoryItemsByIDList
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJigsawItem_DataAsset_C*>  ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UJSI_Slot_C*>              ItemsFound                                             (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetInventoryItemsByIDList(TArray<class UJigsawItem_DataAsset_C*>& ItemId, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetInventoryItemsByIDList");

	Params::JSIContainer_C_GetInventoryItemsByIDList Parms{};

	Parms.ItemId = std::move(ItemId);

	UObject::ProcessEvent(Func, &Parms);

	ItemId = std::move(Parms.ItemId);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (ItemsFound != nullptr)
		*ItemsFound = std::move(Parms.ItemsFound);
}


// Function JSIContainer.JSIContainer_C.GetInventoryItemsByType
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Type                                                   (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UJSI_Slot_C*>              ItemsFound                                             (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetInventoryItemsByType(const struct FGameplayTag& Type, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetInventoryItemsByType");

	Params::JSIContainer_C_GetInventoryItemsByType Parms{};

	Parms.Type = std::move(Type);

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (ItemsFound != nullptr)
		*ItemsFound = std::move(Parms.ItemsFound);
}


// Function JSIContainer.JSIContainer_C.GetItemBySlotIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      Item                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetItemBySlotIndex(int32 SlotIndex, bool* Found, class UJSI_Slot_C** Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetItemBySlotIndex");

	Params::JSIContainer_C_GetItemBySlotIndex Parms{};

	Parms.SlotIndex = SlotIndex;

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (Item != nullptr)
		*Item = Parms.Item;
}


// Function JSIContainer.JSIContainer_C.GetItemByUniqueID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            UniqueID                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      Item                                                   (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetItemByUniqueID(const struct FGuid& UniqueID, bool* Found, class UJSI_Slot_C** Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetItemByUniqueID");

	Params::JSIContainer_C_GetItemByUniqueID Parms{};

	Parms.UniqueID = std::move(UniqueID);

	UObject::ProcessEvent(Func, &Parms);

	if (Found != nullptr)
		*Found = Parms.Found;

	if (Item != nullptr)
		*Item = Parms.Item;
}


// Function JSIContainer.JSIContainer_C.GetItemsByRarity
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Rarity                                                 (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    Found_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UJSI_Slot_C*>              ItemsFound                                             (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetItemsByRarity(const struct FGameplayTag& Rarity, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetItemsByRarity");

	Params::JSIContainer_C_GetItemsByRarity Parms{};

	Parms.Rarity = std::move(Rarity);

	UObject::ProcessEvent(Func, &Parms);

	if (Found_ != nullptr)
		*Found_ = Parms.Found_;

	if (ItemsFound != nullptr)
		*ItemsFound = std::move(Parms.ItemsFound);
}


// Function JSIContainer.JSIContainer_C.GetItemsByStackAbility
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Sucess                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class UJSI_Slot_C*>              Items                                                  (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetItemsByStackAbility(class FName ItemId, bool* Sucess, TArray<class UJSI_Slot_C*>* Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetItemsByStackAbility");

	Params::JSIContainer_C_GetItemsByStackAbility Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);

	if (Sucess != nullptr)
		*Sucess = Parms.Sucess;

	if (Items != nullptr)
		*Items = std::move(Parms.Items);
}


// Function JSIContainer.JSIContainer_C.GetItemsCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UJSIContainer_C::GetItemsCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetItemsCount");

	Params::JSIContainer_C_GetItemsCount Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.GetJSIContainerByPlayerSlots
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Slot_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  Container                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      EquippedItem                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    IsPending_                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetJSIContainerByPlayerSlots(const struct FGameplayTag& Slot_0, class UJSIContainer_C** Container, class UJSI_Slot_C** EquippedItem, bool* IsPending_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetJSIContainerByPlayerSlots");

	Params::JSIContainer_C_GetJSIContainerByPlayerSlots Parms{};

	Parms.Slot_0 = std::move(Slot_0);

	UObject::ProcessEvent(Func, &Parms);

	if (Container != nullptr)
		*Container = Parms.Container;

	if (EquippedItem != nullptr)
		*EquippedItem = Parms.EquippedItem;

	if (IsPending_ != nullptr)
		*IsPending_ = Parms.IsPending_;
}


// Function JSIContainer.JSIContainer_C.GetLastItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetLastItem(class UJSI_Slot_C** ItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetLastItem");

	Params::JSIContainer_C_GetLastItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ItemRef != nullptr)
		*ItemRef = Parms.ItemRef;
}


// Function JSIContainer.JSIContainer_C.GetLength
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UJSIContainer_C::GetLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetLength");

	Params::JSIContainer_C_GetLength Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.GetListOfNonAddContainers
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSIContainer_C*>          Containers                                             (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetListOfNonAddContainers(TArray<class UJSIContainer_C*>* Containers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetListOfNonAddContainers");

	Params::JSIContainer_C_GetListOfNonAddContainers Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Containers != nullptr)
		*Containers = std::move(Parms.Containers);
}


// Function JSIContainer.JSIContainer_C.GetLootContent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetLootContent(class UUserWidget** Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetLootContent");

	Params::JSIContainer_C_GetLootContent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Widget != nullptr)
		*Widget = Parms.Widget;
}


// Function JSIContainer.JSIContainer_C.GetLowestIndexItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      HostingItem                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetLowestIndexItem(class UJSI_Slot_C** HostingItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetLowestIndexItem");

	Params::JSIContainer_C_GetLowestIndexItem Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (HostingItem != nullptr)
		*HostingItem = Parms.HostingItem;
}


// Function JSIContainer.JSIContainer_C.GetMaxCapacity
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   ItemMaxStack                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   MaxCap                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetMaxCapacity(int32 ItemMaxStack, int32* MaxCap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetMaxCapacity");

	Params::JSIContainer_C_GetMaxCapacity Parms{};

	Parms.ItemMaxStack = ItemMaxStack;

	UObject::ProcessEvent(Func, &Parms);

	if (MaxCap != nullptr)
		*MaxCap = Parms.MaxCap;
}


// Function JSIContainer.JSIContainer_C.GetPaddingBySlotIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FMargin                          Padding_0                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32                                   Conumn                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Row                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetPaddingBySlotIndex(int32 SlotIndex, const struct FVector2D& SlotVector, struct FMargin* Padding_0, int32* Conumn, int32* Row)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetPaddingBySlotIndex");

	Params::JSIContainer_C_GetPaddingBySlotIndex Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.SlotVector = std::move(SlotVector);

	UObject::ProcessEvent(Func, &Parms);

	if (Padding_0 != nullptr)
		*Padding_0 = std::move(Parms.Padding_0);

	if (Conumn != nullptr)
		*Conumn = Parms.Conumn;

	if (Row != nullptr)
		*Row = Parms.Row;
}


// Function JSIContainer.JSIContainer_C.GetRootContainerRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ExcludeEquipTo                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ContainerRef                                           (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetRootContainerRef(bool ExcludeEquipTo, class UJSIContainer_C** ContainerRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetRootContainerRef");

	Params::JSIContainer_C_GetRootContainerRef Parms{};

	Parms.ExcludeEquipTo = ExcludeEquipTo;

	UObject::ProcessEvent(Func, &Parms);

	if (ContainerRef != nullptr)
		*ContainerRef = Parms.ContainerRef;
}


// Function JSIContainer.JSIContainer_C.GetSlotIndex
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetSlotIndex(int32* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetSlotIndex");

	Params::JSIContainer_C_GetSlotIndex Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JSIContainer.JSIContainer_C.GetSlotMotherUID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnContainerID_IfInvalid_                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    GetContainerIDIfSpecialC_                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGuid                            UDID                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetSlotMotherUID(bool ReturnContainerID_IfInvalid_, bool GetContainerIDIfSpecialC_, struct FGuid* UDID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetSlotMotherUID");

	Params::JSIContainer_C_GetSlotMotherUID Parms{};

	Parms.ReturnContainerID_IfInvalid_ = ReturnContainerID_IfInvalid_;
	Parms.GetContainerIDIfSpecialC_ = GetContainerIDIfSpecialC_;

	UObject::ProcessEvent(Func, &Parms);

	if (UDID != nullptr)
		*UDID = std::move(Parms.UDID);
}


// Function JSIContainer.JSIContainer_C.GetTotalCountOfItemID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   TotalItemCount                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetTotalCountOfItemID(class FName ItemId, int32* TotalItemCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetTotalCountOfItemID");

	Params::JSIContainer_C_GetTotalCountOfItemID Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);

	if (TotalItemCount != nullptr)
		*TotalItemCount = Parms.TotalItemCount;
}


// Function JSIContainer.JSIContainer_C.GetTotalCountOfItemType
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGameplayTag                     ItemType                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   TotalItemCount                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetTotalCountOfItemType(const struct FGameplayTag& ItemType, int32* TotalItemCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetTotalCountOfItemType");

	Params::JSIContainer_C_GetTotalCountOfItemType Parms{};

	Parms.ItemType = std::move(ItemType);

	UObject::ProcessEvent(Func, &Parms);

	if (TotalItemCount != nullptr)
		*TotalItemCount = Parms.TotalItemCount;
}


// Function JSIContainer.JSIContainer_C.GetTotalWeight
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  WeightRef                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::GetTotalWeight(double& WeightRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetTotalWeight");

	Params::JSIContainer_C_GetTotalWeight Parms{};

	Parms.WeightRef = WeightRef;

	UObject::ProcessEvent(Func, &Parms);

	WeightRef = Parms.WeightRef;
}


// Function JSIContainer.JSIContainer_C.GetValidReloadContainers
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UJSIContainer_C*>          Containers                                             (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetValidReloadContainers(TArray<class UJSIContainer_C*>* Containers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetValidReloadContainers");

	Params::JSIContainer_C_GetValidReloadContainers Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Containers != nullptr)
		*Containers = std::move(Parms.Containers);
}


// Function JSIContainer.JSIContainer_C.HandleContainerOnContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  FromContainer                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSIContainer_C*                  ToContainer                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ToSlotRef                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ToSlot                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DraggedRotated_                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TryRotated_                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Handled_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::HandleContainerOnContainer(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotRef, class UJSI_Slot_C* ToSlotRef, int32 ToSlot, bool DraggedRotated_, bool TryRotated_, bool* Handled_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "HandleContainerOnContainer");

	Params::JSIContainer_C_HandleContainerOnContainer Parms{};

	Parms.FromContainer = FromContainer;
	Parms.ToContainer = ToContainer;
	Parms.SlotRef = SlotRef;
	Parms.ToSlotRef = ToSlotRef;
	Parms.ToSlot = ToSlot;
	Parms.DraggedRotated_ = DraggedRotated_;
	Parms.TryRotated_ = TryRotated_;

	UObject::ProcessEvent(Func, &Parms);

	if (Handled_ != nullptr)
		*Handled_ = Parms.Handled_;
}


// Function JSIContainer.JSIContainer_C.HandleDragEnter
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      DraggedItem                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::HandleDragEnter(class UJSI_Slot_C* DraggedItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "HandleDragEnter");

	Params::JSIContainer_C_HandleDragEnter Parms{};

	Parms.DraggedItem = DraggedItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.HasItems
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::HasItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "HasItems");

	Params::JSIContainer_C_HasItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.HighlightItemsByType
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            Types                                                  (BlueprintVisible, BlueprintReadOnly, Parm)

void UJSIContainer_C::HighlightItemsByType(const struct FGameplayTagContainer& Types)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "HighlightItemsByType");

	Params::JSIContainer_C_HighlightItemsByType Parms{};

	Parms.Types = std::move(Types);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.HighlightNext
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      Current                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      CurrentHighlighted                                     (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::HighlightNext(class UJSI_Slot_C* Current, class UJSI_Slot_C** CurrentHighlighted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "HighlightNext");

	Params::JSIContainer_C_HighlightNext Parms{};

	Parms.Current = Current;

	UObject::ProcessEvent(Func, &Parms);

	if (CurrentHighlighted != nullptr)
		*CurrentHighlighted = Parms.CurrentHighlighted;
}


// Function JSIContainer.JSIContainer_C.HighlightSlots
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        MouseLoc                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRecRef                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Supported_                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DroppedWithinSelf_                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::HighlightSlots(int32 SlotIndex, const struct FVector2D& SlotVector, const struct FVector2D& MouseLoc, class UJSI_Slot_C* SlotRef, class UJSI_Slot_C* SlotRecRef, bool Rotated_, bool Supported_, bool DroppedWithinSelf_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "HighlightSlots");

	Params::JSIContainer_C_HighlightSlots Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.SlotVector = std::move(SlotVector);
	Parms.MouseLoc = std::move(MouseLoc);
	Parms.SlotRef = SlotRef;
	Parms.SlotRecRef = SlotRecRef;
	Parms.Rotated_ = Rotated_;
	Parms.Supported_ = Supported_;
	Parms.DroppedWithinSelf_ = DroppedWithinSelf_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Hightlight_DragMove
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      DragSlotRef                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRec                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DroppedWithinSelf_                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Hightlight_DragMove(int32 SlotIndex, class UJSI_Slot_C* DragSlotRef, class UJSI_Slot_C* SlotRec, bool Rotated_, bool DroppedWithinSelf_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Hightlight_DragMove");

	Params::JSIContainer_C_Hightlight_DragMove Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.DragSlotRef = DragSlotRef;
	Parms.SlotRec = SlotRec;
	Parms.Rotated_ = Rotated_;
	Parms.DroppedWithinSelf_ = DroppedWithinSelf_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Initialize
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Design_                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Initialize(bool Design_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Initialize");

	Params::JSIContainer_C_Initialize Parms{};

	Parms.Design_ = Design_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.IsContainerWithinHierarchy
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSIContainer_C*                  Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::IsContainerWithinHierarchy(class UJSIContainer_C* Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "IsContainerWithinHierarchy");

	Params::JSIContainer_C_IsContainerWithinHierarchy Parms{};

	Parms.Container = Container;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.IsEquipped?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::IsEquipped_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "IsEquipped?");

	Params::JSIContainer_C_IsEquipped_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.IsEquipTo?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::IsEquipTo_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "IsEquipTo?");

	Params::JSIContainer_C_IsEquipTo_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.IsInventory?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::IsInventory_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "IsInventory?");

	Params::JSIContainer_C_IsInventory_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.IsSlotContainer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::IsSlotContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "IsSlotContainer");

	Params::JSIContainer_C_IsSlotContainer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.IsSupportedByThis
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJigsawItem_DataAsset_C*          ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     Type                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool                                    Supported_                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::IsSupportedByThis(class UJigsawItem_DataAsset_C* ItemId, const struct FGameplayTag& Type, bool* Supported_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "IsSupportedByThis");

	Params::JSIContainer_C_IsSupportedByThis Parms{};

	Parms.ItemId = ItemId;
	Parms.Type = std::move(Type);

	UObject::ProcessEvent(Func, &Parms);

	if (Supported_ != nullptr)
		*Supported_ = Parms.Supported_;
}


// Function JSIContainer.JSIContainer_C.IsSupportedID?
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJigsawItem_DataAsset_C*          ID                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Supported                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::IsSupportedID_(class UJigsawItem_DataAsset_C* ID, bool* Supported)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "IsSupportedID?");

	Params::JSIContainer_C_IsSupportedID_ Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);

	if (Supported != nullptr)
		*Supported = Parms.Supported;
}


// Function JSIContainer.JSIContainer_C.IsSupportedType?
// (Private, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            SupportedItemTypes_0                                   (BlueprintVisible, BlueprintReadOnly, Parm)
// struct FGameplayTagContainer            NotSupportedItemTypes_0                                (BlueprintVisible, BlueprintReadOnly, Parm)
// class UJigsawItem_DataAsset_C*          ItemId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     Type                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// bool                                    Supported_                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::IsSupportedType_(const struct FGameplayTagContainer& SupportedItemTypes_0, const struct FGameplayTagContainer& NotSupportedItemTypes_0, class UJigsawItem_DataAsset_C* ItemId, const struct FGameplayTag& Type, bool* Supported_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "IsSupportedType?");

	Params::JSIContainer_C_IsSupportedType_ Parms{};

	Parms.SupportedItemTypes_0 = std::move(SupportedItemTypes_0);
	Parms.NotSupportedItemTypes_0 = std::move(NotSupportedItemTypes_0);
	Parms.ItemId = ItemId;
	Parms.Type = std::move(Type);

	UObject::ProcessEvent(Func, &Parms);

	if (Supported_ != nullptr)
		*Supported_ = Parms.Supported_;
}


// Function JSIContainer.JSIContainer_C.IsWidgetReady?
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::IsWidgetReady_()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "IsWidgetReady?");

	Params::JSIContainer_C_IsWidgetReady_ Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.JigSetLootContent
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UUserWidget*                      Widget                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class FText                             Name_0                                                 (BlueprintVisible, BlueprintReadOnly, Parm)

void UJSIContainer_C::JigSetLootContent(class UUserWidget* Widget, const class FText& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "JigSetLootContent");

	Params::JSIContainer_C_JigSetLootContent Parms{};

	Parms.Widget = Widget;
	Parms.Name_0 = std::move(Name_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.JSICheckStatus
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::JSICheckStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "JSICheckStatus");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.JSIOnWeightUpdated
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  NewWeight                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::JSIOnWeightUpdated(double NewWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "JSIOnWeightUpdated");

	Params::JSIContainer_C_JSIOnWeightUpdated Parms{};

	Parms.NewWeight = NewWeight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.ManageContainerName
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::ManageContainerName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ManageContainerName");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.MoveItemToIndexByItemRef
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotate_                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Moved_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::MoveItemToIndexByItemRef(class UJSI_Slot_C* ItemRef, int32 ToIndex, bool Rotate_, bool* Moved_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "MoveItemToIndexByItemRef");

	Params::JSIContainer_C_MoveItemToIndexByItemRef Parms{};

	Parms.ItemRef = ItemRef;
	Parms.ToIndex = ToIndex;
	Parms.Rotate_ = Rotate_;

	UObject::ProcessEvent(Func, &Parms);

	if (Moved_ != nullptr)
		*Moved_ = Parms.Moved_;
}


// Function JSIContainer.JSIContainer_C.MoveItemToIndexBySlotIndex
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ItemSlotIndex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   ToIndex                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotate_                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Moved_                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::MoveItemToIndexBySlotIndex(int32 ItemSlotIndex, int32 ToIndex, bool Rotate_, bool* Moved_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "MoveItemToIndexBySlotIndex");

	Params::JSIContainer_C_MoveItemToIndexBySlotIndex Parms{};

	Parms.ItemSlotIndex = ItemSlotIndex;
	Parms.ToIndex = ToIndex;
	Parms.Rotate_ = Rotate_;

	UObject::ProcessEvent(Func, &Parms);

	if (Moved_ != nullptr)
		*Moved_ = Parms.Moved_;
}


// Function JSIContainer.JSIContainer_C.On Controller Enter Leave
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::On_Controller_Enter_Leave(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "On Controller Enter Leave");

	Params::JSIContainer_C_On_Controller_Enter_Leave Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.OnCreatedFromUtility
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::OnCreatedFromUtility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnCreatedFromUtility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.OnDragEnter
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FPointerEvent                    PointerEvent                                           (BlueprintVisible, BlueprintReadOnly, Parm)
// class UDragDropOperation*               Operation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::OnDragEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnDragEnter");

	Params::JSIContainer_C_OnDragEnter Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.OnDragLeave
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FPointerEvent                    PointerEvent                                           (BlueprintVisible, BlueprintReadOnly, Parm)
// class UDragDropOperation*               Operation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::OnDragLeave(const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnDragLeave");

	Params::JSIContainer_C_OnDragLeave Parms{};

	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.OnDrop
// (BlueprintCosmetic, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FPointerEvent                    PointerEvent                                           (BlueprintVisible, BlueprintReadOnly, Parm)
// class UDragDropOperation*               Operation                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::OnDrop(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnDrop");

	Params::JSIContainer_C_OnDrop Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.PointerEvent = std::move(PointerEvent);
	Parms.Operation = Operation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.OnDropCheckStackability
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      FixedSlot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      ItemDropped                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      StackWith                                              (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::OnDropCheckStackability(class UJSI_Slot_C* FixedSlot, class UJSI_Slot_C* ItemDropped, class UJSI_Slot_C** StackWith)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnDropCheckStackability");

	Params::JSIContainer_C_OnDropCheckStackability Parms{};

	Parms.FixedSlot = FixedSlot;
	Parms.ItemDropped = ItemDropped;

	UObject::ProcessEvent(Func, &Parms);

	if (StackWith != nullptr)
		*StackWith = Parms.StackWith;
}


// Function JSIContainer.JSIContainer_C.OnInitialized
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UJSIContainer_C::OnInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnInitialized");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.OnKeyDown
// (BlueprintCosmetic, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FKeyEvent                        InKeyEvent                                             (BlueprintVisible, BlueprintReadOnly, Parm)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm)

struct FEventReply UJSIContainer_C::OnKeyDown(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnKeyDown");

	Params::JSIContainer_C_OnKeyDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InKeyEvent = std::move(InKeyEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.OnKeyUp
// (BlueprintCosmetic, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGeometry                        MyGeometry                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// struct FKeyEvent                        InKeyEvent                                             (BlueprintVisible, BlueprintReadOnly, Parm)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm)

struct FEventReply UJSIContainer_C::OnKeyUp(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "OnKeyUp");

	Params::JSIContainer_C_OnKeyUp Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.InKeyEvent = std::move(InKeyEvent);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.PerfromDrop
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   SlotIndex                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D                        SlotVector                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated_                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Moved                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::PerfromDrop(int32 SlotIndex, const struct FVector2D& SlotVector, class UJSI_Slot_C* SlotRef, bool Rotated_, bool* Moved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "PerfromDrop");

	Params::JSIContainer_C_PerfromDrop Parms{};

	Parms.SlotIndex = SlotIndex;
	Parms.SlotVector = std::move(SlotVector);
	Parms.SlotRef = SlotRef;
	Parms.Rotated_ = Rotated_;

	UObject::ProcessEvent(Func, &Parms);

	if (Moved != nullptr)
		*Moved = Parms.Moved;
}


// Function JSIContainer.JSIContainer_C.PreConstruct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsDesignTime                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::PreConstruct(bool IsDesignTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "PreConstruct");

	Params::JSIContainer_C_PreConstruct Parms{};

	Parms.IsDesignTime = IsDesignTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.ProcessControllerStick
// (BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::ProcessControllerStick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ProcessControllerStick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.Re-Init
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Columns                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Rows                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Re_Init(int32 Columns, int32 Rows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Re-Init");

	Params::JSIContainer_C_Re_Init Parms{};

	Parms.Columns = Columns;
	Parms.Rows = Rows;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Re-SortHighlightItems
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::Re_SortHighlightItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Re-SortHighlightItems");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.RemoveInventoryItemByRef
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    TriggerUnequippedEvent_                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Removed                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::RemoveInventoryItemByRef(class UJSI_Slot_C* SlotRef, bool TriggerUnequippedEvent_, bool* Removed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "RemoveInventoryItemByRef");

	Params::JSIContainer_C_RemoveInventoryItemByRef Parms{};

	Parms.SlotRef = SlotRef;
	Parms.TriggerUnequippedEvent_ = TriggerUnequippedEvent_;

	UObject::ProcessEvent(Func, &Parms);

	if (Removed != nullptr)
		*Removed = Parms.Removed;
}


// Function JSIContainer.JSIContainer_C.RemoveItemByUniqueID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ID                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Sucess                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::RemoveItemByUniqueID(const struct FGuid& ID, bool* Sucess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "RemoveItemByUniqueID");

	Params::JSIContainer_C_RemoveItemByUniqueID Parms{};

	Parms.ID = std::move(ID);

	UObject::ProcessEvent(Func, &Parms);

	if (Sucess != nullptr)
		*Sucess = Parms.Sucess;
}


// Function JSIContainer.JSIContainer_C.RemoveSortHighlightedTypes
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            Types                                                  (BlueprintVisible, BlueprintReadOnly, Parm)

void UJSIContainer_C::RemoveSortHighlightedTypes(const struct FGameplayTagContainer& Types)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "RemoveSortHighlightedTypes");

	Params::JSIContainer_C_RemoveSortHighlightedTypes Parms{};

	Parms.Types = std::move(Types);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.ResizeItem
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      SlotRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   AddToX                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   AddToY                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Resized_                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::ResizeItem(class UJSI_Slot_C* SlotRef, int32 AddToX, int32 AddToY, bool* Resized_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "ResizeItem");

	Params::JSIContainer_C_ResizeItem Parms{};

	Parms.SlotRef = SlotRef;
	Parms.AddToX = AddToX;
	Parms.AddToY = AddToY;

	UObject::ProcessEvent(Func, &Parms);

	if (Resized_ != nullptr)
		*Resized_ = Parms.Resized_;
}


// Function JSIContainer.JSIContainer_C.SelectRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    DroppedRotated_                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Rotated                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::SelectRotation(class UJSI_Slot_C* ItemRef, bool DroppedRotated_, bool* Rotated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SelectRotation");

	Params::JSIContainer_C_SelectRotation Parms{};

	Parms.ItemRef = ItemRef;
	Parms.DroppedRotated_ = DroppedRotated_;

	UObject::ProcessEvent(Func, &Parms);

	if (Rotated != nullptr)
		*Rotated = Parms.Rotated;
}


// Function JSIContainer.JSIContainer_C.SetActionbarFollower
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      JigRef                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::SetActionbarFollower(class UJSI_Slot_C* JigRef, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SetActionbarFollower");

	Params::JSIContainer_C_SetActionbarFollower Parms{};

	Parms.JigRef = JigRef;

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function JSIContainer.JSIContainer_C.SetActorOwner
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ActorRef                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::SetActorOwner(class AActor* ActorRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SetActorOwner");

	Params::JSIContainer_C_SetActorOwner Parms{};

	Parms.ActorRef = ActorRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.SetEquippedHighlight
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Valid                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::SetEquippedHighlight(bool Valid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SetEquippedHighlight");

	Params::JSIContainer_C_SetEquippedHighlight Parms{};

	Parms.Valid = Valid;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.SetInspectorRef
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_InspectorWindowWidget_C*      Inspector                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::SetInspectorRef(class UBP_InspectorWindowWidget_C* Inspector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SetInspectorRef");

	Params::JSIContainer_C_SetInspectorRef Parms{};

	Parms.Inspector = Inspector;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.SetItemReference
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::SetItemReference(class UJSI_Slot_C* ItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SetItemReference");

	Params::JSIContainer_C_SetItemReference Parms{};

	Parms.ItemRef = ItemRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.SetLock Column Row
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ColumnToLock                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   RowToLock                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Lock_                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::SetLock_Column_Row(int32 ColumnToLock, int32 RowToLock, bool Lock_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SetLock Column Row");

	Params::JSIContainer_C_SetLock_Column_Row Parms{};

	Parms.ColumnToLock = ColumnToLock;
	Parms.RowToLock = RowToLock;
	Parms.Lock_ = Lock_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.SetSlotDragVisualHighlight
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Valid_                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::SetSlotDragVisualHighlight(bool Valid_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SetSlotDragVisualHighlight");

	Params::JSIContainer_C_SetSlotDragVisualHighlight Parms{};

	Parms.Valid_ = Valid_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.SetSlotHighlight
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Valid_                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::SetSlotHighlight(bool Valid_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SetSlotHighlight");

	Params::JSIContainer_C_SetSlotHighlight Parms{};

	Parms.Valid_ = Valid_;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.SomeFunctionBool
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UJSIContainer_C::SomeFunctionBool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "SomeFunctionBool");

	Params::JSIContainer_C_SomeFunctionBool Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JSIContainer.JSIContainer_C.TrySwapItems
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      Item1                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      Item2                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::TrySwapItems(class UJSI_Slot_C* Item1, class UJSI_Slot_C* Item2, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "TrySwapItems");

	Params::JSIContainer_C_TrySwapItems Parms{};

	Parms.Item1 = Item1;
	Parms.Item2 = Item2;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function JSIContainer.JSIContainer_C.UnequipItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    TriggerUnequippedEvent_                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Unequipped                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UJSI_Slot_C*                      SlotRef                                                (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::UnequipItem(bool TriggerUnequippedEvent_, bool* Unequipped, class UJSI_Slot_C** SlotRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "UnequipItem");

	Params::JSIContainer_C_UnequipItem Parms{};

	Parms.TriggerUnequippedEvent_ = TriggerUnequippedEvent_;

	UObject::ProcessEvent(Func, &Parms);

	if (Unequipped != nullptr)
		*Unequipped = Parms.Unequipped;

	if (SlotRef != nullptr)
		*SlotRef = Parms.SlotRef;
}


// Function JSIContainer.JSIContainer_C.Update_OnCountChanged
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OldCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Update_OnCountChanged(class UJSI_Slot_C* ItemRef, int32 OldCount, int32 NewCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Update_OnCountChanged");

	Params::JSIContainer_C_Update_OnCountChanged Parms{};

	Parms.ItemRef = ItemRef;
	Parms.OldCount = OldCount;
	Parms.NewCount = NewCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Update_OnItemAdded
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Update_OnItemAdded(class UJSI_Slot_C* ItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Update_OnItemAdded");

	Params::JSIContainer_C_Update_OnItemAdded Parms{};

	Parms.ItemRef = ItemRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.Update_OnItemRemoved
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UJSI_Slot_C*                      ItemRef                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::Update_OnItemRemoved(class UJSI_Slot_C* ItemRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "Update_OnItemRemoved");

	Params::JSIContainer_C_Update_OnItemRemoved Parms{};

	Parms.ItemRef = ItemRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JSIContainer.JSIContainer_C.UpdateCapacityContainer
// (Public, BlueprintCallable, BlueprintEvent)

void UJSIContainer_C::UpdateCapacityContainer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "UpdateCapacityContainer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JSIContainer.JSIContainer_C.UpdateCountByUniqueID
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGuid                            ID                                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   NewCount                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Sucess                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UJSIContainer_C::UpdateCountByUniqueID(const struct FGuid& ID, int32 NewCount, bool* Sucess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "UpdateCountByUniqueID");

	Params::JSIContainer_C_UpdateCountByUniqueID Parms{};

	Parms.ID = std::move(ID);
	Parms.NewCount = NewCount;

	UObject::ProcessEvent(Func, &Parms);

	if (Sucess != nullptr)
		*Sucess = Parms.Sucess;
}


// Function JSIContainer.JSIContainer_C.GetListOfContainers
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// TArray<class UJSIContainer_C*>          Containers                                             (Parm, OutParm, ContainsInstancedReference)

void UJSIContainer_C::GetListOfContainers(TArray<class UJSIContainer_C*>* Containers) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JSIContainer_C", "GetListOfContainers");

	Params::JSIContainer_C_GetListOfContainers Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Containers != nullptr)
		*Containers = std::move(Parms.Containers);
}

}

