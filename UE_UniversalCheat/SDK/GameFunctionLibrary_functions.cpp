#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GameFunctionLibrary

#include "Basic.hpp"

#include "GameFunctionLibrary_classes.hpp"
#include "GameFunctionLibrary_parameters.hpp"


namespace SDK
{

// Function GameFunctionLibrary.GameFunctionLibrary_C.AddUniqueLoot
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class FName>                     UnqiueItemsSet                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UBP_JigMultiplayer_C*             JigComp                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::AddUniqueLoot(TArray<class FName>& UnqiueItemsSet, class UBP_JigMultiplayer_C* JigComp, int32 Container, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "AddUniqueLoot");

	Params::GameFunctionLibrary_C_AddUniqueLoot Parms{};

	Parms.UnqiueItemsSet = std::move(UnqiueItemsSet);
	Parms.JigComp = JigComp;
	Parms.Container = Container;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	UnqiueItemsSet = std::move(Parms.UnqiueItemsSet);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.ApplyMedicalEffect
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class FName>                     Medical_Effects                                        (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// double                                  ChanceForBleed                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ChanceForHeavyBleed                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ChanceForBrokenBone                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::ApplyMedicalEffect(class AActor* Actor, TArray<class FName>& Medical_Effects, double ChanceForBleed, double ChanceForHeavyBleed, double ChanceForBrokenBone, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "ApplyMedicalEffect");

	Params::GameFunctionLibrary_C_ApplyMedicalEffect Parms{};

	Parms.Actor = Actor;
	Parms.Medical_Effects = std::move(Medical_Effects);
	Parms.ChanceForBleed = ChanceForBleed;
	Parms.ChanceForHeavyBleed = ChanceForHeavyBleed;
	Parms.ChanceForBrokenBone = ChanceForBrokenBone;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Medical_Effects = std::move(Parms.Medical_Effects);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.ApplyRadiationDamage
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  ChanceForRadDamage                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  RadDamage                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CanMaskProtect_                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::ApplyRadiationDamage(class AActor* Actor, double ChanceForRadDamage, double RadDamage, bool CanMaskProtect_, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "ApplyRadiationDamage");

	Params::GameFunctionLibrary_C_ApplyRadiationDamage Parms{};

	Parms.Actor = Actor;
	Parms.ChanceForRadDamage = ChanceForRadDamage;
	Parms.RadDamage = RadDamage;
	Parms.CanMaskProtect_ = CanMaskProtect_;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.CastToCharacter
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_PlayerCharacter_C*            Character                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::CastToCharacter(class UObject* __WorldContext, class ABP_PlayerCharacter_C** Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "CastToCharacter");

	Params::GameFunctionLibrary_C_CastToCharacter Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Character != nullptr)
		*Character = Parms.Character;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.CastToController
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_PlayerController_C*           Controller                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::CastToController(class UObject* __WorldContext, class ABP_PlayerController_C** Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "CastToController");

	Params::GameFunctionLibrary_C_CastToController Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Controller != nullptr)
		*Controller = Parms.Controller;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.Centre Cursor
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::Centre_Cursor(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "Centre Cursor");

	Params::GameFunctionLibrary_C_Centre_Cursor Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.ChangeDifficulty
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_Difficulty                         Difficulty                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::ChangeDifficulty(Enum_Difficulty Difficulty, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "ChangeDifficulty");

	Params::GameFunctionLibrary_C_ChangeDifficulty Parms{};

	Parms.Difficulty = Difficulty;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.CreateNotificationUI
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Message                                                (BlueprintVisible, BlueprintReadOnly, Parm)
// class UTexture2D*                       Icon                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor                     Icon_Colour                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Force_Notification_                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::CreateNotificationUI(const class FText& Message, class UTexture2D* Icon, const struct FLinearColor& Icon_Colour, double Delay, bool Force_Notification_, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "CreateNotificationUI");

	Params::GameFunctionLibrary_C_CreateNotificationUI Parms{};

	Parms.Message = std::move(Message);
	Parms.Icon = Icon;
	Parms.Icon_Colour = std::move(Icon_Colour);
	Parms.Delay = Delay;
	Parms.Force_Notification_ = Force_Notification_;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.CreateZoneAreaUI
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Entering_Area_                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             Area_Name                                              (BlueprintVisible, BlueprintReadOnly, Parm)
// class UTexture*                         Texture                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor                     Color                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::CreateZoneAreaUI(bool Entering_Area_, const class FText& Area_Name, class UTexture* Texture, const struct FLinearColor& Color, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "CreateZoneAreaUI");

	Params::GameFunctionLibrary_C_CreateZoneAreaUI Parms{};

	Parms.Entering_Area_ = Entering_Area_;
	Parms.Area_Name = std::move(Area_Name);
	Parms.Texture = Texture;
	Parms.Color = std::move(Color);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.DestroyAllActors
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::DestroyAllActors(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "DestroyAllActors");

	Params::GameFunctionLibrary_C_DestroyAllActors Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.DestroyMainMenuActors
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::DestroyMainMenuActors(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "DestroyMainMenuActors");

	Params::GameFunctionLibrary_C_DestroyMainMenuActors Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetBehindObject?
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Interactor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    BehindObject_                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetBehindObject_(class AActor* Actor, class AActor* Interactor, const struct FVector& Location, class UObject* __WorldContext, bool* BehindObject_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetBehindObject?");

	Params::GameFunctionLibrary_C_GetBehindObject_ Parms{};

	Parms.Actor = Actor;
	Parms.Interactor = Interactor;
	Parms.Location = std::move(Location);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (BehindObject_ != nullptr)
		*BehindObject_ = Parms.BehindObject_;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetCharacterFromController
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AController*                      Object                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_PlayerCharacter_C*            Character                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetCharacterFromController(class AController* Object, class UObject* __WorldContext, class ABP_PlayerCharacter_C** Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetCharacterFromController");

	Params::GameFunctionLibrary_C_GetCharacterFromController Parms{};

	Parms.Object = Object;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Character != nullptr)
		*Character = Parms.Character;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetGameDirectory
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FString                           Path                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetGameDirectory(class UObject* __WorldContext, class FString* Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetGameDirectory");

	Params::GameFunctionLibrary_C_GetGameDirectory Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Path != nullptr)
		*Path = std::move(Parms.Path);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetGameHUD
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AHUD_Game_C*                      HUD                                                    (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetGameHUD(class UObject* __WorldContext, class AHUD_Game_C** HUD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetGameHUD");

	Params::GameFunctionLibrary_C_GetGameHUD Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (HUD != nullptr)
		*HUD = Parms.HUD;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetGameInstance
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class USD_GameInstance_C*               Instance                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetGameInstance(class UObject* __WorldContext, class USD_GameInstance_C** Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetGameInstance");

	Params::GameFunctionLibrary_C_GetGameInstance Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Instance != nullptr)
		*Instance = Parms.Instance;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetGameMode
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_SurroundeadGameMode_C*        GameMode                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetGameMode(class UObject* __WorldContext, class ABP_SurroundeadGameMode_C** GameMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetGameMode");

	Params::GameFunctionLibrary_C_GetGameMode Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (GameMode != nullptr)
		*GameMode = Parms.GameMode;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetHUD
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AHUD_Game_C*                      HUD                                                    (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetHUD(class UObject* __WorldContext, class AHUD_Game_C** HUD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetHUD");

	Params::GameFunctionLibrary_C_GetHUD Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (HUD != nullptr)
		*HUD = Parms.HUD;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetKey
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UInputAction*                     Action                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FKey                             Key                                                    (Parm, OutParm, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetKey(const class UInputAction* Action, class UObject* __WorldContext, struct FKey* Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetKey");

	Params::GameFunctionLibrary_C_GetKey Parms{};

	Parms.Action = Action;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Key != nullptr)
		*Key = std::move(Parms.Key);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetLevellingComponent
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ULevellingComponent_C*            LevellingComponent                                     (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetLevellingComponent(class UObject* __WorldContext, class ULevellingComponent_C** LevellingComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetLevellingComponent");

	Params::GameFunctionLibrary_C_GetLevellingComponent Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (LevellingComponent != nullptr)
		*LevellingComponent = Parms.LevellingComponent;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetLockPickingComponent
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ULockPickingComponent_C*          LevellingComponent                                     (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetLockPickingComponent(class UObject* __WorldContext, class ULockPickingComponent_C** LevellingComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetLockPickingComponent");

	Params::GameFunctionLibrary_C_GetLockPickingComponent Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (LevellingComponent != nullptr)
		*LevellingComponent = Parms.LevellingComponent;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetLootTableName
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// Enum_ContainerLootTables                Selection                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FText                             Text                                                   (Parm, OutParm)

void UGameFunctionLibrary_C::GetLootTableName(Enum_ContainerLootTables Selection, class UObject* __WorldContext, class FText* Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetLootTableName");

	Params::GameFunctionLibrary_C_GetLootTableName Parms{};

	Parms.Selection = Selection;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Text != nullptr)
		*Text = std::move(Parms.Text);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetPassiveSkillsComponent
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPassiveSkillsComponent_C*        SkillsComponent                                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetPassiveSkillsComponent(class UObject* __WorldContext, class UPassiveSkillsComponent_C** SkillsComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetPassiveSkillsComponent");

	Params::GameFunctionLibrary_C_GetPassiveSkillsComponent Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (SkillsComponent != nullptr)
		*SkillsComponent = Parms.SkillsComponent;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetRadiationLevel
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// Enum_RadiationLevel                     Level                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetRadiationLevel(Enum_RadiationLevel Level, class UObject* __WorldContext, double* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetRadiationLevel");

	Params::GameFunctionLibrary_C_GetRadiationLevel Parms{};

	Parms.Level = Level;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetRandomActorOfClass
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Actor                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetRandomActorOfClass(TSubclassOf<class AActor> ActorClass, class UObject* __WorldContext, class AActor** Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetRandomActorOfClass");

	Params::GameFunctionLibrary_C_GetRandomActorOfClass Parms{};

	Parms.ActorClass = ActorClass;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Actor != nullptr)
		*Actor = Parms.Actor;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetSkillTreeManager
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UTechTreeComponent_C*             TechTree                                               (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetSkillTreeManager(class UObject* __WorldContext, class UTechTreeComponent_C** TechTree)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetSkillTreeManager");

	Params::GameFunctionLibrary_C_GetSkillTreeManager Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (TechTree != nullptr)
		*TechTree = Parms.TechTree;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetUDS
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AUltra_Dynamic_Sky_C*             UDS                                                    (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetUDS(class UObject* __WorldContext, class AUltra_Dynamic_Sky_C** UDS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetUDS");

	Params::GameFunctionLibrary_C_GetUDS Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (UDS != nullptr)
		*UDS = Parms.UDS;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.GetUDW
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class AUltra_Dynamic_Weather_C*         UDW                                                    (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::GetUDW(class UObject* __WorldContext, class AUltra_Dynamic_Weather_C** UDW)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "GetUDW");

	Params::GameFunctionLibrary_C_GetUDW Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (UDW != nullptr)
		*UDW = Parms.UDW;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.isKeyDown
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UInputAction*                     Action                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Down                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::isKeyDown(const class UInputAction* Action, class UObject* __WorldContext, bool* Down)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "isKeyDown");

	Params::GameFunctionLibrary_C_isKeyDown Parms{};

	Parms.Action = Action;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Down != nullptr)
		*Down = Parms.Down;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.IsOutsideOfPlayerView?
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          Loc                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    NotInPlayerView_                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::IsOutsideOfPlayerView_(const struct FVector& Loc, class AActor* Actor, class UObject* __WorldContext, bool* NotInPlayerView_)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "IsOutsideOfPlayerView?");

	Params::GameFunctionLibrary_C_IsOutsideOfPlayerView_ Parms{};

	Parms.Loc = std::move(Loc);
	Parms.Actor = Actor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NotInPlayerView_ != nullptr)
		*NotInPlayerView_ = Parms.NotInPlayerView_;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.LookForMapping
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FKeyEvent                        Key                                                    (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FText                             Mapping                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm)
// class UInputAction*                     Action                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::LookForMapping(struct FKeyEvent& Key, const class FText& Mapping, const class UInputAction* Action, class UObject* __WorldContext, bool* Found)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "LookForMapping");

	Params::GameFunctionLibrary_C_LookForMapping Parms{};

	Parms.Key = std::move(Key);
	Parms.Mapping = std::move(Mapping);
	Parms.Action = Action;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Key = std::move(Parms.Key);

	if (Found != nullptr)
		*Found = Parms.Found;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.LootDegredationMultiplier
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Chance                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  NewChance                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::LootDegredationMultiplier(double Chance, class UObject* __WorldContext, double* NewChance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "LootDegredationMultiplier");

	Params::GameFunctionLibrary_C_LootDegredationMultiplier Parms{};

	Parms.Chance = Chance;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NewChance != nullptr)
		*NewChance = Parms.NewChance;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.LootDifficultySetting
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             CVar                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// Enum_LootDifficulties                   Selection1                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::LootDifficultySetting(class FName CVar, Enum_LootDifficulties Selection1, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "LootDifficultySetting");

	Params::GameFunctionLibrary_C_LootDifficultySetting Parms{};

	Parms.CVar = CVar;
	Parms.Selection1 = Selection1;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.LootTypeMultiplier
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// Enum_LootType                           Selection                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Chance                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  Multiplier                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::LootTypeMultiplier(Enum_LootType Selection, double Chance, class UObject* __WorldContext, double* Multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "LootTypeMultiplier");

	Params::GameFunctionLibrary_C_LootTypeMultiplier Parms{};

	Parms.Selection = Selection;
	Parms.Chance = Chance;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Multiplier != nullptr)
		*Multiplier = Parms.Multiplier;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.ResetPlayerStats
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::ResetPlayerStats(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "ResetPlayerStats");

	Params::GameFunctionLibrary_C_ResetPlayerStats Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.ScalingDamageMultiplier
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Dmg                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  NewDmg                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::ScalingDamageMultiplier(double Dmg, class UObject* __WorldContext, double* NewDmg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "ScalingDamageMultiplier");

	Params::GameFunctionLibrary_C_ScalingDamageMultiplier Parms{};

	Parms.Dmg = Dmg;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NewDmg != nullptr)
		*NewDmg = Parms.NewDmg;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.ScalingHealthMultiplier
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  MaxHealth                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  NewMaxHealth                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::ScalingHealthMultiplier(double MaxHealth, class UObject* __WorldContext, double* NewMaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "ScalingHealthMultiplier");

	Params::GameFunctionLibrary_C_ScalingHealthMultiplier Parms{};

	Parms.MaxHealth = MaxHealth;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NewMaxHealth != nullptr)
		*NewMaxHealth = Parms.NewMaxHealth;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.SetItemsToCraft
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_CraftingTableTypes                 Table                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             JigComp                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::SetItemsToCraft(Enum_CraftingTableTypes Table, class UBP_JigMultiplayer_C* JigComp, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "SetItemsToCraft");

	Params::GameFunctionLibrary_C_SetItemsToCraft Parms{};

	Parms.Table = Table;
	Parms.JigComp = JigComp;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.SetItemsToSell
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_VendorTypes                        Table                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             JigComp                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::SetItemsToSell(Enum_VendorTypes Table, class UBP_JigMultiplayer_C* JigComp, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "SetItemsToSell");

	Params::GameFunctionLibrary_C_SetItemsToSell Parms{};

	Parms.Table = Table;
	Parms.JigComp = JigComp;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.SetLootTable_AI_DA
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_AILootTables                       Table                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             JigComp                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::SetLootTable_AI_DA(Enum_AILootTables Table, class UBP_JigMultiplayer_C* JigComp, int32 Container, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "SetLootTable_AI_DA");

	Params::GameFunctionLibrary_C_SetLootTable_AI_DA Parms{};

	Parms.Table = Table;
	Parms.JigComp = JigComp;
	Parms.Container = Container;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.SetLootTable_Container_DA
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// Enum_ContainerLootTables                Table                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_JigMultiplayer_C*             JigComp                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   Container                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::SetLootTable_Container_DA(Enum_ContainerLootTables Table, class UBP_JigMultiplayer_C* JigComp, int32 Container, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "SetLootTable_Container_DA");

	Params::GameFunctionLibrary_C_SetLootTable_Container_DA Parms{};

	Parms.Table = Table;
	Parms.JigComp = JigComp;
	Parms.Container = Container;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.XpMultiplierCalc
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Min                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Max                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double UGameFunctionLibrary_C::XpMultiplierCalc(double Min, double Max, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameFunctionLibrary_C", "XpMultiplierCalc");

	Params::GameFunctionLibrary_C_XpMultiplierCalc Parms{};

	Parms.Min = Min;
	Parms.Max = Max;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GameFunctionLibrary.GameFunctionLibrary_C.SetDifficulty
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FStruct_Difficulty               Settings                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGameFunctionLibrary_C::SetDifficulty(const struct FStruct_Difficulty& Settings, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFunctionLibrary_C", "SetDifficulty");

	Params::GameFunctionLibrary_C_SetDifficulty Parms{};

	Parms.Settings = std::move(Settings);
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);
}

}

