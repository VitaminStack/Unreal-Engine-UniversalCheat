#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JSIContainer

#include "Basic.hpp"

#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "DefaultItemInfo_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "InputCore_structs.hpp"
#include "RarityColors_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// WidgetBlueprintGeneratedClass JSIContainer.JSIContainer_C
// 0x04C8 (0x0788 - 0x02C0)
class UJSIContainer_C final : public UUserWidget
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x02C0(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UBorder*                                ContainerBorder;                                   // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UTextBlock*                             ContainerNameTxt;                                  // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UJSIActivable_C*                        JSIActivable;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UOverlay*                               MainOverlay;                                       // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class USizeBox*                               NameSBox;                                          // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	class UUniformGridPanel*                      Ungrid;                                            // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, RepSkip, NoDestructor, PersistentInstance, HasGetValueTypeHash)
	bool                                          Initialized;                                       // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2F9[0x3];                                      // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  ContainerID;                                       // 0x02FC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	struct FGameplayTag                           ContainerType;                                     // 0x030C(0x0008)(Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	struct FGameplayTag                           ContainerTag;                                      // 0x0314(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash)
	int32                                         NumberOfColumns;                                   // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	int32                                         NumberOfRows;                                      // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJSI_Slot_C*>                    WSlots;                                            // 0x0328(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	double                                        OpacityValue;                                      // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	int32                                         MaxEquippedStack;                                  // 0x0340(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              SlotSize;                                          // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	struct FVector2D                              EquippedItemSlotSize;                              // 0x0358(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          EquippedImageMatchesContainerSize_;                // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_369[0x3];                                      // 0x0369(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMargin                                SlotPadding;                                       // 0x036C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	struct FSlateColor                            SlotOnHoverColor;                                  // 0x037C(0x0014)(Edit, BlueprintVisible, ExposeOnSpawn)
	struct FSlateColor                            DragHighlightColor;                                // 0x0390(0x0014)(Edit, BlueprintVisible, ExposeOnSpawn)
	struct FSlateColor                            InvalidDragHighlightColor;                         // 0x03A4(0x0014)(Edit, BlueprintVisible, ExposeOnSpawn)
	TArray<struct FRarityColors>                  RarityColors;                                      // 0x03B8(0x0010)(Edit, BlueprintVisible, ExposeOnSpawn)
	class UTexture2D*                             SlotImage;                                         // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	int32                                         CurrentSlotIndex;                                  // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3D4[0x4];                                      // 0x03D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJSI_Slot_C*>                    HighlightedSlots;                                  // 0x03D8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	bool                                          CanDrop_;                                          // 0x03E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FromXLoc;                                          // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         FromYLoc;                                          // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UJSI_Slot_C*                            SlotRecH;                                          // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	struct FVector2D                              MouseLocH;                                         // 0x0400(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class UJSI_Slot_C*>                    ArrayOfItems;                                      // 0x0410(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	bool                                          HideSlotImageWhenEquipped_;                        // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          RotateEquippedImage;                               // 0x0421(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_422[0x6];                                      // 0x0422(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SupportedItemTypes;                                // 0x0428(0x0020)(Edit, BlueprintVisible, ExposeOnSpawn)
	TMulticastInlineDelegate<void(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotReceiver, class UJSI_Slot_C* SlotDropped, bool SlotDroppedRemoved_)> ItemsCombined;                                     // 0x0448(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void(class UJSIContainer_C* From, class UJSIContainer_C* To, class UJSI_Slot_C* ItemMovedRef, bool ToEmptySlot_, bool MovedAll_)> DropInfo_ContainerToContainer;                     // 0x0458(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotRef, bool Equipped_)> DropInfo_OnItemEquippedChange;                     // 0x0468(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	struct FGameplayTagContainer                  NotSupportedItemTypes;                             // 0x0478(0x0020)(Edit, BlueprintVisible, ExposeOnSpawn)
	TArray<class UJigsawItem_DataAsset_C*>        OnlySupportTheseItems;                             // 0x0498(0x0010)(Edit, BlueprintVisible, ExposeOnSpawn)
	TArray<class UJigsawItem_DataAsset_C*>        AlsoSupportTheseItems;                             // 0x04A8(0x0010)(Edit, BlueprintVisible, ExposeOnSpawn)
	TArray<class UJigsawItem_DataAsset_C*>        DoNotSupportTheseItems;                            // 0x04B8(0x0010)(Edit, BlueprintVisible, ExposeOnSpawn)
	struct FKey                                   RotateKey;                                         // 0x04C8(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, HasGetValueTypeHash)
	int32                                         DropToSlot;                                        // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FKey                                   SplitKey;                                          // 0x04E8(0x0018)(Edit, BlueprintVisible, ExposeOnSpawn, HasGetValueTypeHash)
	TMulticastInlineDelegate<void(class UJSI_Slot_C* SourceSlotRef, class UJSI_Slot_C* NewSplitSlotRef, class UJSIContainer_C* ContainerSource, class UJSIContainer_C* ContainerReceiver, int32 SplitAmount, int32 AmountRemaining)> DropInfo_SplitPerformed;                           // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void(class UJSI_Slot_C* ItemReceiver, class UJSI_Slot_C* ItemDropped, class UJSIContainer_C* ItemReceiverContainer, class UJSIContainer_C* ItemDroppedContainer)> Drop_ItemOverItem;                                 // 0x0510(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	EDragPivot                                    DragBehaviour;                                     // 0x0520(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_521[0x7];                                      // 0x0521(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MaxWeight;                                         // 0x0528(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          HideItemOnDrag_;                                   // 0x0530(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_531[0x7];                                      // 0x0531(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ContainerName;                                     // 0x0538(0x0018)(Edit, BlueprintVisible)
	struct FSlateFontInfo                         ContainerNameFont;                                 // 0x0550(0x0058)(Edit, BlueprintVisible, HasGetValueTypeHash)
	struct FMargin                                ContainerNamePadding;                              // 0x05A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	TArray<struct FDefaultItemInfo>               AddDefaultItems;                                   // 0x05B8(0x0010)(Edit, BlueprintVisible, ExposeOnSpawn)
	bool                                          AllowDrag;                                         // 0x05C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          AllowDragFromOtherContainers;                      // 0x05C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          AllowMovingItemsOnDrop;                            // 0x05CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          AllowOpeningContainers;                            // 0x05CB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          HandleContainerToContainerDrop;                    // 0x05CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_5CD[0x3];                                      // 0x05CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* DroppedSlotRef, class UJSI_Slot_C* SlotReceiverRef, int32 ToSlotIndex, bool Rotated_)> Drop_ContainerOnContainerUnhandled;                // 0x05D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          ReceiveAllUnhandledEvent;                          // 0x05E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          AllowVisualHighlight;                              // 0x05E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          ShowPrices;                                        // 0x05E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_5E3[0x5];                                      // 0x05E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UJSIContainer_C* Container, class UJSI_Slot_C* SlotRef, const struct FKey& Button)> OnSlotMouseButtonDown;                             // 0x05E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TMulticastInlineDelegate<void(class UJSIContainer_C* Container, class UJSI_Slot_C* SlotRef, const struct FKey& Button)> OnSlotDoubleClick;                                 // 0x05F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          AllowDropToGround;                                 // 0x0608(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_609[0x7];                                      // 0x0609(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UJSIContainer_C* Container, class UJSI_Slot_C* SlotRef, int32 NewIndex, bool Rotated)> OnItemSlotOrRotationChanged;                       // 0x0610(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class UJSI_Slot_C*                            SlotMother;                                        // 0x0620(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	TMulticastInlineDelegate<void(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* ItemSource, int32 ToSlotIndex, int32 TotalAmount, int32 SplitAmount, bool Rotated_)> OnItemSplitRequest;                                // 0x0628(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          AutoPerformSplit;                                  // 0x0638(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_639[0x7];                                      // 0x0639(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UJSI_Slot_C* DroppedItem, class UJSI_Slot_C* ReceiverItem)> OnItemStackRequest;                                // 0x0640(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          AutoPerformStack;                                  // 0x0650(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_651[0x7];                                      // 0x0651(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UJSI_Slot_C* ItemRef, int32 NewCount)> OnStackCountChanged;                               // 0x0658(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	int32                                         ParentID;                                          // 0x0668(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_66C[0x4];                                      // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SortHighlightedTypes;                              // 0x0670(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          AllowBlindAddItemToContainer_;                     // 0x0690(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          IsPartSpecialContainer;                            // 0x0691(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          DropOnContainerSlot;                               // 0x0692(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_693[0x5];                                      // 0x0693(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UJSIContainer_C* Container, class UJSI_Slot_C* ItemRef, const struct FKey& Button)> OnSlotMouseButtonUp;                               // 0x0698(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class UJSIContainer_C*                        SpecialSContainer;                                 // 0x06A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          TriggerItemOverItemIfCannotAddToContainer;         // 0x06B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          IsSpecialLootContainer;                            // 0x06B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_6B2[0x6];                                      // 0x06B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 EquippedActorRef;                                  // 0x06B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash)
	bool                                          Debug_;                                            // 0x06C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          AllowContextMenu;                                  // 0x06C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_6C2[0x6];                                      // 0x06C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        JigMultiplayerComp;                                // 0x06C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	struct FGameplayTagContainer                  DoNotAllowContextMenuOptions;                      // 0x06D0(0x0020)(Edit, BlueprintVisible, ExposeOnSpawn)
	TMulticastInlineDelegate<void(class UJSI_Slot_C* ItemRef, class UJSIContainer_C* FromContainer)> OnItemRemoved;                                     // 0x06F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          IsActionbar;                                       // 0x0700(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          AllowStackingEquippedItem;                         // 0x0701(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_702[0x6];                                      // 0x0702(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ContainerWeight;                                   // 0x0708(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMulticastInlineDelegate<void(double NewWeight)> OnWeightUpdated;                                   // 0x0710(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          ShowDurability;                                    // 0x0720(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          OnImageCaptureTryAdjustScaleWhenEquipped;          // 0x0721(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          AllowCapturingItemImage;                           // 0x0722(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_723[0x5];                                      // 0x0723(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 Current, int32 Max, class UJSIContainer_C* Container, class UJSI_Slot_C* SlotMother)> OnCapacityUpdated;                                 // 0x0728(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	class UJSIContainer_C*                        CanSwapWithJSIContainer;                           // 0x0738(0x0008)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	TMulticastInlineDelegate<void(class UJSI_Slot_C* ItemRef)> OnUniqueIDSet;                                     // 0x0740(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          VisualHighlighted_;                                // 0x0750(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_751[0x3];                                      // 0x0751(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            DragVisualHighlightColor;                          // 0x0754(0x0014)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          CallStackRequestOnContainerEmitter;                // 0x0768(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	bool                                          OnOpenContainerInspectInstead;                     // 0x0769(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	uint8                                         Pad_76A[0x2];                                      // 0x076A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentControllerIndex;                            // 0x076C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<struct FKey>                           GampadDirectionalKeys;                             // 0x0770(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          IsMainContainer_;                                  // 0x0780(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ControllerSupport;                                 // 0x0781(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ForceNoBlindAdd;                                   // 0x0782(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)

public:
	void Add_DefaultItems();
	void AddItemFromJigRef(class UJSI_Slot_C* ItemRef, int32 ToSlot, bool RotateItem_, bool TryRotated_, bool* Added, class UJSI_Slot_C** AddedItemRef);
	void AddMultipleInventoryItems(TArray<class UJigsawItem_DataAsset_C*>& ItemIDs, TArray<class UJigsawItem_DataAsset_C*>* NoTAdded);
	void AddNewInventoryItem(class UJigsawItem_DataAsset_C* ItemDA, int32 Count, int32 ToSlot, bool Rotated_, bool TryRotated_, bool TryToStack_, bool TriggerEquippedEvent_, bool* Added, int32* SlotIndex, class UJigsawItem_DataAsset_C** ItemInfo, class UJSI_Slot_C** SlotItemRef, bool* Stacked_);
	void AddNewInventoryItem_CustomVector(class UJigsawItem_DataAsset_C* ItemId, int32 Count, int32 ToSlot, bool* Added, int32* SlotIndex, class UJigsawItem_DataAsset_C** ItemInfo, class UJSI_Slot_C** SlotItemRef);
	void AddNewItem(int32 ToSlot, class UTexture* Image, const struct FVector2D& SlotVector, const struct FGameplayTag& Rarity, class UJigsawItem_DataAsset_C* ItemInfo, bool SetVector, int32 Count, bool* Added, int32* AddedToSlot, class UJigsawItem_DataAsset_C** Info, class UJSI_Slot_C** SlotItemRef);
	void AddSortHighlightedTypes(const struct FGameplayTagContainer& Types);
	void AdjustFromXY(const struct FVector2D& ItemVe);
	struct FVector2D CalculateSize(const struct FVector2D& SlotVector);
	struct FVector2D CalculateSizeCustom(const struct FVector2D& SlotVector, const struct FVector2D& CSlotSize);
	void CalculateWeight(double* Weight);
	void Call_ContainerOnContainer(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotRef, class UJSI_Slot_C* ToSlotRef, int32 ToSlot, bool DragRotated_, bool TryRotated_);
	void CanAddItemToSlot(int32 ToSlot, const struct FVector2D& ItemVector, bool TryRotated_, bool* Result, bool* RotatedVector_);
	void CanAddItemToSlot_IgnoreItems(int32 ToSlot, const struct FVector2D& ItemVector, bool TryRotated_, TArray<class UJSI_Slot_C*>& IgnoreItems, bool* Result, bool* RotatedVector_);
	void CancelHighlights();
	void CanResize_(class UJSI_Slot_C* SlotRef, int32 AddToX, int32 AddToY, bool* Result, TArray<class UJSI_Slot_C*>* HostingSlotsArray, TArray<class UJSI_Slot_C*>* FreedHostingSlotsArray);
	void CanStack_(class UJSIContainer_C* Container, class UJSI_Slot_C* ItemRef, bool* CanStack);
	void CanStackSingleSlot_(class UJigsawItem_DataAsset_C* Info, int32 Count, class UJSI_Slot_C* WithItem, bool* Sucess, class UJSI_Slot_C** ItemRef);
	void ChangeItemCount(class UJSI_Slot_C* ItemRef, int32 NewCount, bool* Changed_);
	void ChangeItemImage(class UJSI_Slot_C* ItemRef, class UTexture2D* NewTexture, bool* Changed_);
	void ChangeItemRarity(class UJSI_Slot_C* ItemRef, const struct FGameplayTag& NewRarity, bool* Changed_);
	void ChangeItemsInteract(bool Interact_);
	void CheckIfCanAddToSpecial(class UJSI_Slot_C* ItemSP, class UJSI_Slot_C* ItemToAdd, bool CheckBlind_, bool DigDeeper_, bool* CanAdd, class UJSIContainer_C** ToContainer);
	void CheckIfCanStack(class UJSI_Slot_C* WithItemRef, bool* Sucess, class UJSI_Slot_C** ItemRef);
	bool CheckIfCapacityContainer();
	void CheckKey(const struct FKeyEvent& Input, const struct FKey& B, bool* Value);
	void CheckLimitedEquipToStack(class UJSI_Slot_C* DroppedSlotRef, class UDragWidget_C* DragWidgetRef, class UJSI_Slot_C* FixedSlotRef, bool* Handled_);
	void CheckRootContainer(class UJSI_Slot_C* DraggedItem, bool* Proceed_);
	void CheckUnhandledSplit(class UJSI_Slot_C* DroppedSlotRef, class UDragWidget_C* DragWidgetRef, class UJSI_Slot_C* FixedSlotRef, bool DroppedRotated_, bool* Handled_);
	void CheckUnhandledStack(class UJSI_Slot_C* DropedSlotRef, class UJSI_Slot_C* FixedSlotRef, bool* Result);
	void CheckWeightLimit(double ItemWeight, class UJSIContainer_C* FromContainer, bool* Result);
	void ClearContainer();
	void ClearData();
	void ClearItemFromArr(class UJSI_Slot_C* SlotRef, class UJSIContainer_C* ToContainer_, bool TriggerUnequippedEvent_, bool* Removed);
	void CombineItemRequest(class UJSIContainer_C* FromContainer, class UJSI_Slot_C* SlotRec, class UJSI_Slot_C* SlotDropped, bool TriggerEventDispatcher_);
	bool CompareItems(class UJSI_Slot_C* Item1, class UJSI_Slot_C* Item2);
	void ControllerHighlightItem(int32 Index_0, bool Value);
	void Deep_Search_for_Item_by_ID(class UJigsawItem_DataAsset_C* ItemId, bool SearchInEquipTo_, class UJSI_Slot_C** ItemRef, bool* Found_);
	void Deep_GettAllItems(TArray<class UJSI_Slot_C*>& ArrByRef);
	void Deep_GettAllItemsByID(TArray<class UJSI_Slot_C*>& ArrByRef, class UJigsawItem_DataAsset_C* DA, bool IncludeEquippedItems_);
	void Destruct();
	void DifficultyCheckBackpack_(class UJSI_Slot_C* SlotToCheck, bool* CarryOn_);
	bool DoesItemExist(class UJSI_Slot_C* ItemRef);
	void DragSelectContainer(class UJSIContainer_C* MotherC, class UJSI_Slot_C* SlotReceiver, class UJSIContainer_C** MotherRef);
	void DummyFunction();
	void EquipItem(class UJigsawItem_DataAsset_C* ItemId, int32 Count, class UJSIContainer_C* SlotContainer, bool TriggerEquippedEvent_, bool* Equipped, class UJSI_Slot_C** SlotItemRef);
	void EquipItemFromJigRef(class UJSI_Slot_C* ItemRef, bool CallEquipEvent_, bool* Added, class UJSI_Slot_C** EquippedItemRef);
	void ExecuteUbergraph_JSIContainer(int32 EntryPoint);
	void ExpandContainer(int32 AddColumns, int32 AddRows, bool* Success);
	void FindBestStackingItem(class FName ItemId, int32 DroppedItemCount, class UJSI_Slot_C** BestStackingItem, int32* FreeSpace, bool* CanStackAll);
	void FindNearestToColumnRow(bool Reverse, bool CheckCol, double UP_, double Right_, bool Flip_, class UJSI_Slot_C** Output_Get, int32* Index_0, bool* RetReverse, bool* RetCheckCol, double* RetUP_, double* RetRight_);
	void FindSlotByIndex(int32 Index_0, class UJSI_Slot_C** SlotRef);
	void FlipSlotDim(const struct FVector2D& SlotVector, struct FVector2D* Flipped);
	void ForceInitSpecialcontainer();
	int32 Get_Slot_Index_by_Column_Row(int32 Column, int32 Row);
	void GetAllAttachments(TArray<class FName>* Attachments);
	void GetCapacity(int32* Cap);
	void GetColumnRowBySlotIndex(int32 SlotIndex, int32* Column, int32* Row);
	void GetColumnRowBySlotIndex_NonPure(int32 SlotIndex, int32* Column, int32* Row);
	void GetContainerByAttachmentType(const struct FGameplayTag& Type, class UJSIContainer_C** JigContainer, int32* ContainerIndex);
	void GetContainerHierarchy(TArray<class UJSIContainer_C*>* Containers);
	void GetContainerIndex(int32* Index_0);
	void GetContainerName(class FText* ContainerName_0);
	void GetContainersFromEquipped(TArray<class UJSIContainer_C*>* Container);
	void GetDropWidget(class UDropItemBackGwidget_C** DropWRef);
	void GetEmptySlot(const struct FVector2D& SlotVector, int32* SlotIndex, bool* Found_);
	void GetEmptySlotTryRotated(const struct FVector2D& SlotVector, bool* Found_);
	void GetEmptySlotTryRotated_NonPure(const struct FVector2D& SlotVector, bool* Found_, int32* ToSlotIndex, bool* Rotated_);
	void GetEquippedItemRef(bool* Found_, class UJSI_Slot_C** ItemRef, bool* IsPending);
	int32 GetFreeSpaceIfCapacityContainer();
	void GetHighestCapacityContainer(TArray<class UJSI_Slot_C*>& Items, class UJSI_Slot_C** Output_Get);
	void GetHostingSlots(int32 SlotIndex, const struct FVector2D& ItemVec, TArray<int32>* Indexes);
	void GetImageFromInfo(class UJigsawItem_DataAsset_C* Info, class UTexture** Image);
	void GetInventoryItemsByID(class UJigsawItem_DataAsset_C* ItemId, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound);
	void GetInventoryItemsByIDList(TArray<class UJigsawItem_DataAsset_C*>& ItemId, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound);
	void GetInventoryItemsByType(const struct FGameplayTag& Type, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound);
	void GetItemBySlotIndex(int32 SlotIndex, bool* Found, class UJSI_Slot_C** Item);
	void GetItemByUniqueID(const struct FGuid& UniqueID, bool* Found, class UJSI_Slot_C** Item);
	void GetItemsByRarity(const struct FGameplayTag& Rarity, bool* Found_, TArray<class UJSI_Slot_C*>* ItemsFound);
	void GetItemsByStackAbility(class FName ItemId, bool* Sucess, TArray<class UJSI_Slot_C*>* Items);
	int32 GetItemsCount();
	void GetJSIContainerByPlayerSlots(const struct FGameplayTag& Slot_0, class UJSIContainer_C** Container, class UJSI_Slot_C** EquippedItem, bool* IsPending_);
	void GetLastItem(class UJSI_Slot_C** ItemRef);
	int32 GetLength();
	void GetListOfNonAddContainers(TArray<class UJSIContainer_C*>* Containers);
	void GetLootContent(class UUserWidget** Widget);
	void GetLowestIndexItem(class UJSI_Slot_C** HostingItem);
	void GetMaxCapacity(int32 ItemMaxStack, int32* MaxCap);
	void GetPaddingBySlotIndex(int32 SlotIndex, const struct FVector2D& SlotVector, struct FMargin* Padding_0, int32* Conumn, int32* Row);
	void GetRootContainerRef(bool ExcludeEquipTo, class UJSIContainer_C** ContainerRef);
	void GetSlotIndex(int32* Result);
	void GetSlotMotherUID(bool ReturnContainerID_IfInvalid_, bool GetContainerIDIfSpecialC_, struct FGuid* UDID);
	void GetTotalCountOfItemID(class FName ItemId, int32* TotalItemCount);
	void GetTotalCountOfItemType(const struct FGameplayTag& ItemType, int32* TotalItemCount);
	void GetTotalWeight(double& WeightRef);
	void GetValidReloadContainers(TArray<class UJSIContainer_C*>* Containers);
	void HandleContainerOnContainer(class UJSIContainer_C* FromContainer, class UJSIContainer_C* ToContainer, class UJSI_Slot_C* SlotRef, class UJSI_Slot_C* ToSlotRef, int32 ToSlot, bool DraggedRotated_, bool TryRotated_, bool* Handled_);
	void HandleDragEnter(class UJSI_Slot_C* DraggedItem);
	bool HasItems();
	void HighlightItemsByType(const struct FGameplayTagContainer& Types);
	void HighlightNext(class UJSI_Slot_C* Current, class UJSI_Slot_C** CurrentHighlighted);
	void HighlightSlots(int32 SlotIndex, const struct FVector2D& SlotVector, const struct FVector2D& MouseLoc, class UJSI_Slot_C* SlotRef, class UJSI_Slot_C* SlotRecRef, bool Rotated_, bool Supported_, bool DroppedWithinSelf_);
	void Hightlight_DragMove(int32 SlotIndex, class UJSI_Slot_C* DragSlotRef, class UJSI_Slot_C* SlotRec, bool Rotated_, bool DroppedWithinSelf_);
	void Initialize(bool Design_);
	bool IsContainerWithinHierarchy(class UJSIContainer_C* Container);
	bool IsEquipped_();
	bool IsEquipTo_();
	bool IsInventory_();
	bool IsSlotContainer();
	void IsSupportedByThis(class UJigsawItem_DataAsset_C* ItemId, const struct FGameplayTag& Type, bool* Supported_);
	void IsSupportedID_(class UJigsawItem_DataAsset_C* ID, bool* Supported);
	void IsSupportedType_(const struct FGameplayTagContainer& SupportedItemTypes_0, const struct FGameplayTagContainer& NotSupportedItemTypes_0, class UJigsawItem_DataAsset_C* ItemId, const struct FGameplayTag& Type, bool* Supported_);
	bool IsWidgetReady_();
	void JigSetLootContent(class UUserWidget* Widget, const class FText& Name_0);
	void JSICheckStatus();
	void JSIOnWeightUpdated(double NewWeight);
	void ManageContainerName();
	void MoveItemToIndexByItemRef(class UJSI_Slot_C* ItemRef, int32 ToIndex, bool Rotate_, bool* Moved_);
	void MoveItemToIndexBySlotIndex(int32 ItemSlotIndex, int32 ToIndex, bool Rotate_, bool* Moved_);
	void On_Controller_Enter_Leave(bool Value);
	void OnCreatedFromUtility();
	void OnDragEnter(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation);
	void OnDragLeave(const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation);
	bool OnDrop(const struct FGeometry& MyGeometry, const struct FPointerEvent& PointerEvent, class UDragDropOperation* Operation);
	void OnDropCheckStackability(class UJSI_Slot_C* FixedSlot, class UJSI_Slot_C* ItemDropped, class UJSI_Slot_C** StackWith);
	void OnInitialized();
	struct FEventReply OnKeyDown(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent);
	struct FEventReply OnKeyUp(const struct FGeometry& MyGeometry, const struct FKeyEvent& InKeyEvent);
	void PerfromDrop(int32 SlotIndex, const struct FVector2D& SlotVector, class UJSI_Slot_C* SlotRef, bool Rotated_, bool* Moved);
	void PreConstruct(bool IsDesignTime);
	void ProcessControllerStick();
	void Re_Init(int32 Columns, int32 Rows);
	void Re_SortHighlightItems();
	void RemoveInventoryItemByRef(class UJSI_Slot_C* SlotRef, bool TriggerUnequippedEvent_, bool* Removed);
	void RemoveItemByUniqueID(const struct FGuid& ID, bool* Sucess);
	void RemoveSortHighlightedTypes(const struct FGameplayTagContainer& Types);
	void ResizeItem(class UJSI_Slot_C* SlotRef, int32 AddToX, int32 AddToY, bool* Resized_);
	void SelectRotation(class UJSI_Slot_C* ItemRef, bool DroppedRotated_, bool* Rotated);
	void SetActionbarFollower(class UJSI_Slot_C* JigRef, bool* Return);
	void SetActorOwner(class AActor* ActorRef);
	void SetEquippedHighlight(bool Valid);
	void SetInspectorRef(class UBP_InspectorWindowWidget_C* Inspector);
	void SetItemReference(class UJSI_Slot_C* ItemRef);
	void SetLock_Column_Row(int32 ColumnToLock, int32 RowToLock, bool Lock_);
	void SetSlotDragVisualHighlight(bool Valid_);
	void SetSlotHighlight(bool Valid_);
	bool SomeFunctionBool();
	void TrySwapItems(class UJSI_Slot_C* Item1, class UJSI_Slot_C* Item2, bool* Success);
	void UnequipItem(bool TriggerUnequippedEvent_, bool* Unequipped, class UJSI_Slot_C** SlotRef);
	void Update_OnCountChanged(class UJSI_Slot_C* ItemRef, int32 OldCount, int32 NewCount);
	void Update_OnItemAdded(class UJSI_Slot_C* ItemRef);
	void Update_OnItemRemoved(class UJSI_Slot_C* ItemRef);
	void UpdateCapacityContainer();
	void UpdateCountByUniqueID(const struct FGuid& ID, int32 NewCount, bool* Sucess);

	void GetListOfContainers(TArray<class UJSIContainer_C*>* Containers) const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"JSIContainer_C">();
	}
	static class UJSIContainer_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJSIContainer_C>();
	}
};
static_assert(alignof(UJSIContainer_C) == 0x000008, "Wrong alignment on UJSIContainer_C");
static_assert(sizeof(UJSIContainer_C) == 0x000788, "Wrong size on UJSIContainer_C");
static_assert(offsetof(UJSIContainer_C, UberGraphFrame) == 0x0002C0, "Member 'UJSIContainer_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerBorder) == 0x0002C8, "Member 'UJSIContainer_C::ContainerBorder' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerNameTxt) == 0x0002D0, "Member 'UJSIContainer_C::ContainerNameTxt' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, JSIActivable) == 0x0002D8, "Member 'UJSIContainer_C::JSIActivable' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, MainOverlay) == 0x0002E0, "Member 'UJSIContainer_C::MainOverlay' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, NameSBox) == 0x0002E8, "Member 'UJSIContainer_C::NameSBox' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Ungrid) == 0x0002F0, "Member 'UJSIContainer_C::Ungrid' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Initialized) == 0x0002F8, "Member 'UJSIContainer_C::Initialized' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerID) == 0x0002FC, "Member 'UJSIContainer_C::ContainerID' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerType) == 0x00030C, "Member 'UJSIContainer_C::ContainerType' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerTag) == 0x000314, "Member 'UJSIContainer_C::ContainerTag' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, NumberOfColumns) == 0x00031C, "Member 'UJSIContainer_C::NumberOfColumns' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, NumberOfRows) == 0x000320, "Member 'UJSIContainer_C::NumberOfRows' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, WSlots) == 0x000328, "Member 'UJSIContainer_C::WSlots' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OpacityValue) == 0x000338, "Member 'UJSIContainer_C::OpacityValue' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, MaxEquippedStack) == 0x000340, "Member 'UJSIContainer_C::MaxEquippedStack' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SlotSize) == 0x000348, "Member 'UJSIContainer_C::SlotSize' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, EquippedItemSlotSize) == 0x000358, "Member 'UJSIContainer_C::EquippedItemSlotSize' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, EquippedImageMatchesContainerSize_) == 0x000368, "Member 'UJSIContainer_C::EquippedImageMatchesContainerSize_' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SlotPadding) == 0x00036C, "Member 'UJSIContainer_C::SlotPadding' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SlotOnHoverColor) == 0x00037C, "Member 'UJSIContainer_C::SlotOnHoverColor' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DragHighlightColor) == 0x000390, "Member 'UJSIContainer_C::DragHighlightColor' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, InvalidDragHighlightColor) == 0x0003A4, "Member 'UJSIContainer_C::InvalidDragHighlightColor' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, RarityColors) == 0x0003B8, "Member 'UJSIContainer_C::RarityColors' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SlotImage) == 0x0003C8, "Member 'UJSIContainer_C::SlotImage' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, CurrentSlotIndex) == 0x0003D0, "Member 'UJSIContainer_C::CurrentSlotIndex' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, HighlightedSlots) == 0x0003D8, "Member 'UJSIContainer_C::HighlightedSlots' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, CanDrop_) == 0x0003E8, "Member 'UJSIContainer_C::CanDrop_' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, FromXLoc) == 0x0003EC, "Member 'UJSIContainer_C::FromXLoc' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, FromYLoc) == 0x0003F0, "Member 'UJSIContainer_C::FromYLoc' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SlotRecH) == 0x0003F8, "Member 'UJSIContainer_C::SlotRecH' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, MouseLocH) == 0x000400, "Member 'UJSIContainer_C::MouseLocH' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ArrayOfItems) == 0x000410, "Member 'UJSIContainer_C::ArrayOfItems' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, HideSlotImageWhenEquipped_) == 0x000420, "Member 'UJSIContainer_C::HideSlotImageWhenEquipped_' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, RotateEquippedImage) == 0x000421, "Member 'UJSIContainer_C::RotateEquippedImage' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SupportedItemTypes) == 0x000428, "Member 'UJSIContainer_C::SupportedItemTypes' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ItemsCombined) == 0x000448, "Member 'UJSIContainer_C::ItemsCombined' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DropInfo_ContainerToContainer) == 0x000458, "Member 'UJSIContainer_C::DropInfo_ContainerToContainer' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DropInfo_OnItemEquippedChange) == 0x000468, "Member 'UJSIContainer_C::DropInfo_OnItemEquippedChange' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, NotSupportedItemTypes) == 0x000478, "Member 'UJSIContainer_C::NotSupportedItemTypes' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnlySupportTheseItems) == 0x000498, "Member 'UJSIContainer_C::OnlySupportTheseItems' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AlsoSupportTheseItems) == 0x0004A8, "Member 'UJSIContainer_C::AlsoSupportTheseItems' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DoNotSupportTheseItems) == 0x0004B8, "Member 'UJSIContainer_C::DoNotSupportTheseItems' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, RotateKey) == 0x0004C8, "Member 'UJSIContainer_C::RotateKey' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DropToSlot) == 0x0004E0, "Member 'UJSIContainer_C::DropToSlot' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SplitKey) == 0x0004E8, "Member 'UJSIContainer_C::SplitKey' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DropInfo_SplitPerformed) == 0x000500, "Member 'UJSIContainer_C::DropInfo_SplitPerformed' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Drop_ItemOverItem) == 0x000510, "Member 'UJSIContainer_C::Drop_ItemOverItem' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DragBehaviour) == 0x000520, "Member 'UJSIContainer_C::DragBehaviour' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, MaxWeight) == 0x000528, "Member 'UJSIContainer_C::MaxWeight' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, HideItemOnDrag_) == 0x000530, "Member 'UJSIContainer_C::HideItemOnDrag_' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerName) == 0x000538, "Member 'UJSIContainer_C::ContainerName' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerNameFont) == 0x000550, "Member 'UJSIContainer_C::ContainerNameFont' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerNamePadding) == 0x0005A8, "Member 'UJSIContainer_C::ContainerNamePadding' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AddDefaultItems) == 0x0005B8, "Member 'UJSIContainer_C::AddDefaultItems' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowDrag) == 0x0005C8, "Member 'UJSIContainer_C::AllowDrag' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowDragFromOtherContainers) == 0x0005C9, "Member 'UJSIContainer_C::AllowDragFromOtherContainers' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowMovingItemsOnDrop) == 0x0005CA, "Member 'UJSIContainer_C::AllowMovingItemsOnDrop' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowOpeningContainers) == 0x0005CB, "Member 'UJSIContainer_C::AllowOpeningContainers' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, HandleContainerToContainerDrop) == 0x0005CC, "Member 'UJSIContainer_C::HandleContainerToContainerDrop' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Drop_ContainerOnContainerUnhandled) == 0x0005D0, "Member 'UJSIContainer_C::Drop_ContainerOnContainerUnhandled' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ReceiveAllUnhandledEvent) == 0x0005E0, "Member 'UJSIContainer_C::ReceiveAllUnhandledEvent' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowVisualHighlight) == 0x0005E1, "Member 'UJSIContainer_C::AllowVisualHighlight' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ShowPrices) == 0x0005E2, "Member 'UJSIContainer_C::ShowPrices' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnSlotMouseButtonDown) == 0x0005E8, "Member 'UJSIContainer_C::OnSlotMouseButtonDown' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnSlotDoubleClick) == 0x0005F8, "Member 'UJSIContainer_C::OnSlotDoubleClick' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowDropToGround) == 0x000608, "Member 'UJSIContainer_C::AllowDropToGround' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnItemSlotOrRotationChanged) == 0x000610, "Member 'UJSIContainer_C::OnItemSlotOrRotationChanged' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SlotMother) == 0x000620, "Member 'UJSIContainer_C::SlotMother' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnItemSplitRequest) == 0x000628, "Member 'UJSIContainer_C::OnItemSplitRequest' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AutoPerformSplit) == 0x000638, "Member 'UJSIContainer_C::AutoPerformSplit' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnItemStackRequest) == 0x000640, "Member 'UJSIContainer_C::OnItemStackRequest' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AutoPerformStack) == 0x000650, "Member 'UJSIContainer_C::AutoPerformStack' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnStackCountChanged) == 0x000658, "Member 'UJSIContainer_C::OnStackCountChanged' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ParentID) == 0x000668, "Member 'UJSIContainer_C::ParentID' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SortHighlightedTypes) == 0x000670, "Member 'UJSIContainer_C::SortHighlightedTypes' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowBlindAddItemToContainer_) == 0x000690, "Member 'UJSIContainer_C::AllowBlindAddItemToContainer_' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, IsPartSpecialContainer) == 0x000691, "Member 'UJSIContainer_C::IsPartSpecialContainer' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DropOnContainerSlot) == 0x000692, "Member 'UJSIContainer_C::DropOnContainerSlot' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnSlotMouseButtonUp) == 0x000698, "Member 'UJSIContainer_C::OnSlotMouseButtonUp' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, SpecialSContainer) == 0x0006A8, "Member 'UJSIContainer_C::SpecialSContainer' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, TriggerItemOverItemIfCannotAddToContainer) == 0x0006B0, "Member 'UJSIContainer_C::TriggerItemOverItemIfCannotAddToContainer' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, IsSpecialLootContainer) == 0x0006B1, "Member 'UJSIContainer_C::IsSpecialLootContainer' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, EquippedActorRef) == 0x0006B8, "Member 'UJSIContainer_C::EquippedActorRef' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, Debug_) == 0x0006C0, "Member 'UJSIContainer_C::Debug_' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowContextMenu) == 0x0006C1, "Member 'UJSIContainer_C::AllowContextMenu' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, JigMultiplayerComp) == 0x0006C8, "Member 'UJSIContainer_C::JigMultiplayerComp' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DoNotAllowContextMenuOptions) == 0x0006D0, "Member 'UJSIContainer_C::DoNotAllowContextMenuOptions' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnItemRemoved) == 0x0006F0, "Member 'UJSIContainer_C::OnItemRemoved' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, IsActionbar) == 0x000700, "Member 'UJSIContainer_C::IsActionbar' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowStackingEquippedItem) == 0x000701, "Member 'UJSIContainer_C::AllowStackingEquippedItem' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ContainerWeight) == 0x000708, "Member 'UJSIContainer_C::ContainerWeight' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnWeightUpdated) == 0x000710, "Member 'UJSIContainer_C::OnWeightUpdated' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ShowDurability) == 0x000720, "Member 'UJSIContainer_C::ShowDurability' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnImageCaptureTryAdjustScaleWhenEquipped) == 0x000721, "Member 'UJSIContainer_C::OnImageCaptureTryAdjustScaleWhenEquipped' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, AllowCapturingItemImage) == 0x000722, "Member 'UJSIContainer_C::AllowCapturingItemImage' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnCapacityUpdated) == 0x000728, "Member 'UJSIContainer_C::OnCapacityUpdated' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, CanSwapWithJSIContainer) == 0x000738, "Member 'UJSIContainer_C::CanSwapWithJSIContainer' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnUniqueIDSet) == 0x000740, "Member 'UJSIContainer_C::OnUniqueIDSet' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, VisualHighlighted_) == 0x000750, "Member 'UJSIContainer_C::VisualHighlighted_' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, DragVisualHighlightColor) == 0x000754, "Member 'UJSIContainer_C::DragVisualHighlightColor' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, CallStackRequestOnContainerEmitter) == 0x000768, "Member 'UJSIContainer_C::CallStackRequestOnContainerEmitter' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, OnOpenContainerInspectInstead) == 0x000769, "Member 'UJSIContainer_C::OnOpenContainerInspectInstead' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, CurrentControllerIndex) == 0x00076C, "Member 'UJSIContainer_C::CurrentControllerIndex' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, GampadDirectionalKeys) == 0x000770, "Member 'UJSIContainer_C::GampadDirectionalKeys' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, IsMainContainer_) == 0x000780, "Member 'UJSIContainer_C::IsMainContainer_' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ControllerSupport) == 0x000781, "Member 'UJSIContainer_C::ControllerSupport' has a wrong offset!");
static_assert(offsetof(UJSIContainer_C, ForceNoBlindAdd) == 0x000782, "Member 'UJSIContainer_C::ForceNoBlindAdd' has a wrong offset!");

}

