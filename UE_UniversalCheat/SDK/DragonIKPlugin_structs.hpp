#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DragonIKPlugin

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum DragonIKPlugin.EIK_Type_Plugin
// NumValues: 0x0003
enum class EIK_Type_Plugin : uint8
{
	ENUM_Two_Bone_Ik                         = 0,
	ENUM_Single_Bone_Ik                      = 1,
	ENUM_MAX                                 = 2,
};

// Enum DragonIKPlugin.ERefPosePluginEnum
// NumValues: 0x0003
enum class ERefPosePluginEnum : uint8
{
	VE_Animated                              = 0,
	VE_Rest                                  = 1,
	VE_MAX                                   = 2,
};

// Enum DragonIKPlugin.ESolverComplexityPluginEnum
// NumValues: 0x0003
enum class ESolverComplexityPluginEnum : uint8
{
	VE_Simple                                = 0,
	VE_Complex                               = 1,
	VE_MAX                                   = 2,
};

// Enum DragonIKPlugin.EDragonIKTraceMType
// NumValues: 0x0003
enum class EDragonIKTraceMType : uint8
{
	LineTrace                                = 0,
	SphereTrace                              = 1,
	EDragonIKTraceMType_MAX                  = 2,
};

// Enum DragonIKPlugin.ETwist_Type_DragonIK
// NumValues: 0x0003
enum class ETwist_Type_DragonIK : uint8
{
	ENUM_PoseAxisTwist                       = 0,
	ENUM_UpAxisTwist                         = 1,
	ENUM_MAX                                 = 2,
};

// Enum DragonIKPlugin.EPole_System_DragonIK
// NumValues: 0x0004
enum class EPole_System_DragonIK : uint8
{
	ENUM_SinglePoleSystem                    = 0,
	ENUM_NSEWPoleSystem                      = 1,
	ENUM_PoseBendSystem                      = 2,
	ENUM_MAX                                 = 3,
};

// Enum DragonIKPlugin.EInputTransformSpace_DragonIK
// NumValues: 0x0003
enum class EInputTransformSpace_DragonIK : uint8
{
	ENUM_WorldSpaceSystem                    = 0,
	ENUM_ComponentSpaceSystem                = 1,
	ENUM_MAX                                 = 2,
};

// Enum DragonIKPlugin.EInput_FatBoneFAxis
// NumValues: 0x0005
enum class EInput_FatBoneFAxis : uint8
{
	ENUM_XAxis                               = 0,
	ENUM_YAxis                               = 1,
	ENUM_ZAxis                               = 2,
	ENUM_XYZAxis                             = 3,
	ENUM_MAX                                 = 4,
};

// Enum DragonIKPlugin.ERotation_Type_DragonIK
// NumValues: 0x0003
enum class ERotation_Type_DragonIK : uint8
{
	ENUM_AdditiveRotation                    = 0,
	ENUM_ReplaceRotation                     = 1,
	ENUM_MAX                                 = 2,
};

// Enum DragonIKPlugin.EIKTrace_Type_Plugin
// NumValues: 0x0003
enum class EIKTrace_Type_Plugin : uint8
{
	ENUM_LineTrace_Type                      = 0,
	ENUM_SphereTrace_Type                    = 1,
	ENUM_MAX                                 = 2,
};

// Enum DragonIKPlugin.EInterpoLocation_Type_Plugin
// NumValues: 0x0003
enum class EInterpoLocation_Type_Plugin : uint8
{
	ENUM_DivisiveLoc_Interp                  = 0,
	ENUM_LegacyLoc_Interp                    = 1,
	ENUM_MAX                                 = 2,
};

// Enum DragonIKPlugin.EInterpoRotation_Type_Plugin
// NumValues: 0x0003
enum class EInterpoRotation_Type_Plugin : uint8
{
	ENUM_DivisiveRot_Interp                  = 0,
	ENUM_LegacyRot_Interp                    = 1,
	ENUM_MAX                                 = 2,
};

// ScriptStruct DragonIKPlugin.DragonData_ElbowOffset_Struct
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_ElbowOffset_Struct final
{
public:
	TArray<struct FVector>                        elbow_offset_array;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_ElbowOffset_Struct) == 0x000008, "Wrong alignment on FDragonData_ElbowOffset_Struct");
static_assert(sizeof(FDragonData_ElbowOffset_Struct) == 0x000010, "Wrong size on FDragonData_ElbowOffset_Struct");
static_assert(offsetof(FDragonData_ElbowOffset_Struct, elbow_offset_array) == 0x000000, "Member 'FDragonData_ElbowOffset_Struct::elbow_offset_array' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_AimSolver_SkeletonInput
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_AimSolver_SkeletonInput final
{
public:
	TArray<class FName>                           Bone_Input;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_AimSolver_SkeletonInput) == 0x000008, "Wrong alignment on FDragonData_AimSolver_SkeletonInput");
static_assert(sizeof(FDragonData_AimSolver_SkeletonInput) == 0x000010, "Wrong size on FDragonData_AimSolver_SkeletonInput");
static_assert(offsetof(FDragonData_AimSolver_SkeletonInput, Bone_Input) == 0x000000, "Member 'FDragonData_AimSolver_SkeletonInput::Bone_Input' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_ArmsData
// 0x0200 (0x0200 - 0x0000)
struct FDragonData_ArmsData final
{
public:
	struct FBoneReference                         Clavicle_Bone;                                     // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Shoulder_Bone_Name;                                // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Elbow_Bone_Name;                                   // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Hand_Bone_Name;                                    // 0x0030(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          is_this_right_hand;                                // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          invert_lower_twist;                                // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          invert_upper_twist;                                // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x1];                                       // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         Twist_Forearm_Bone;                                // 0x0044(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Twist_Shoulder_Bone;                               // 0x0054(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Local_Direction_Axis;                              // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Arm_Aiming_Offset;                                 // 0x0080(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          accurate_hand_rotation;                            // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          relative_axis;                                     // 0x0099(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Maximum_Extension;                                 // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum_Extension;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_Stretch_Ratio;                                 // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stretch_lower_arm_Priorty;                         // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Elbow_Pole_Offset;                                 // 0x00B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                North_Pole_Offset;                                 // 0x00C8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                South_Pole_Offset;                                 // 0x00E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                West_Pole_Offset;                                  // 0x00F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                East_Pole_Offset;                                  // 0x0110(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          override_limits;                                   // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              Max_Arm_H_Angle;                                   // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Max_Arm_V_Angle;                                   // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Inner_Clavicle_Side_Limit;                         // 0x0150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Inner_Clavicle_Vertical_Limit;                     // 0x0160(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Outer_Clavicle_Side_Limit;                         // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Outer_Clavicle_Vertical_Limit;                     // 0x0180(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Shoulder_Inner_Clamp;                              // 0x0190(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Shoulder_Outer_Clamp;                              // 0x01A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ForeArm_Angle_Limit;                               // 0x01B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Twist_Offset_Reverse;                              // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          should_shoulder_twist_if_inward;                   // 0x01C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          clavicle_part_of_extension;                        // 0x01C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C6[0x3A];                                     // 0x01C6(0x003A)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDragonData_ArmsData) == 0x000008, "Wrong alignment on FDragonData_ArmsData");
static_assert(sizeof(FDragonData_ArmsData) == 0x000200, "Wrong size on FDragonData_ArmsData");
static_assert(offsetof(FDragonData_ArmsData, Clavicle_Bone) == 0x000000, "Member 'FDragonData_ArmsData::Clavicle_Bone' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Shoulder_Bone_Name) == 0x000010, "Member 'FDragonData_ArmsData::Shoulder_Bone_Name' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Elbow_Bone_Name) == 0x000020, "Member 'FDragonData_ArmsData::Elbow_Bone_Name' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Hand_Bone_Name) == 0x000030, "Member 'FDragonData_ArmsData::Hand_Bone_Name' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, is_this_right_hand) == 0x000040, "Member 'FDragonData_ArmsData::is_this_right_hand' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, invert_lower_twist) == 0x000041, "Member 'FDragonData_ArmsData::invert_lower_twist' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, invert_upper_twist) == 0x000042, "Member 'FDragonData_ArmsData::invert_upper_twist' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Twist_Forearm_Bone) == 0x000044, "Member 'FDragonData_ArmsData::Twist_Forearm_Bone' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Twist_Shoulder_Bone) == 0x000054, "Member 'FDragonData_ArmsData::Twist_Shoulder_Bone' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Local_Direction_Axis) == 0x000068, "Member 'FDragonData_ArmsData::Local_Direction_Axis' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Arm_Aiming_Offset) == 0x000080, "Member 'FDragonData_ArmsData::Arm_Aiming_Offset' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, accurate_hand_rotation) == 0x000098, "Member 'FDragonData_ArmsData::accurate_hand_rotation' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, relative_axis) == 0x000099, "Member 'FDragonData_ArmsData::relative_axis' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Maximum_Extension) == 0x00009C, "Member 'FDragonData_ArmsData::Maximum_Extension' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Minimum_Extension) == 0x0000A0, "Member 'FDragonData_ArmsData::Minimum_Extension' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Max_Stretch_Ratio) == 0x0000A4, "Member 'FDragonData_ArmsData::Max_Stretch_Ratio' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Stretch_lower_arm_Priorty) == 0x0000A8, "Member 'FDragonData_ArmsData::Stretch_lower_arm_Priorty' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Elbow_Pole_Offset) == 0x0000B0, "Member 'FDragonData_ArmsData::Elbow_Pole_Offset' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, North_Pole_Offset) == 0x0000C8, "Member 'FDragonData_ArmsData::North_Pole_Offset' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, South_Pole_Offset) == 0x0000E0, "Member 'FDragonData_ArmsData::South_Pole_Offset' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, West_Pole_Offset) == 0x0000F8, "Member 'FDragonData_ArmsData::West_Pole_Offset' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, East_Pole_Offset) == 0x000110, "Member 'FDragonData_ArmsData::East_Pole_Offset' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, override_limits) == 0x000128, "Member 'FDragonData_ArmsData::override_limits' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Max_Arm_H_Angle) == 0x000130, "Member 'FDragonData_ArmsData::Max_Arm_H_Angle' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Max_Arm_V_Angle) == 0x000140, "Member 'FDragonData_ArmsData::Max_Arm_V_Angle' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Inner_Clavicle_Side_Limit) == 0x000150, "Member 'FDragonData_ArmsData::Inner_Clavicle_Side_Limit' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Inner_Clavicle_Vertical_Limit) == 0x000160, "Member 'FDragonData_ArmsData::Inner_Clavicle_Vertical_Limit' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Outer_Clavicle_Side_Limit) == 0x000170, "Member 'FDragonData_ArmsData::Outer_Clavicle_Side_Limit' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Outer_Clavicle_Vertical_Limit) == 0x000180, "Member 'FDragonData_ArmsData::Outer_Clavicle_Vertical_Limit' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Shoulder_Inner_Clamp) == 0x000190, "Member 'FDragonData_ArmsData::Shoulder_Inner_Clamp' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Shoulder_Outer_Clamp) == 0x0001A0, "Member 'FDragonData_ArmsData::Shoulder_Outer_Clamp' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, ForeArm_Angle_Limit) == 0x0001B0, "Member 'FDragonData_ArmsData::ForeArm_Angle_Limit' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, Twist_Offset_Reverse) == 0x0001C0, "Member 'FDragonData_ArmsData::Twist_Offset_Reverse' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, should_shoulder_twist_if_inward) == 0x0001C4, "Member 'FDragonData_ArmsData::should_shoulder_twist_if_inward' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmsData, clavicle_part_of_extension) == 0x0001C5, "Member 'FDragonData_ArmsData::clavicle_part_of_extension' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_FingerData
// 0x0030 (0x0030 - 0x0000)
struct FDragonData_FingerData final
{
public:
	class FName                                   Finger_Bone_Name;                                  // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Trace_Scale;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Trace_Offset;                                      // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Finger_Backward;                                // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDragonData_FingerData) == 0x000008, "Wrong alignment on FDragonData_FingerData");
static_assert(sizeof(FDragonData_FingerData) == 0x000030, "Wrong size on FDragonData_FingerData");
static_assert(offsetof(FDragonData_FingerData, Finger_Bone_Name) == 0x000000, "Member 'FDragonData_FingerData::Finger_Bone_Name' has a wrong offset!");
static_assert(offsetof(FDragonData_FingerData, Trace_Scale) == 0x000008, "Member 'FDragonData_FingerData::Trace_Scale' has a wrong offset!");
static_assert(offsetof(FDragonData_FingerData, Trace_Offset) == 0x000010, "Member 'FDragonData_FingerData::Trace_Offset' has a wrong offset!");
static_assert(offsetof(FDragonData_FingerData, Is_Finger_Backward) == 0x000028, "Member 'FDragonData_FingerData::Is_Finger_Backward' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_FootData
// 0x00D0 (0x00D0 - 0x0000)
struct FDragonData_FootData final
{
public:
	class FName                                   Feet_Bone_Name;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Knee_Bone_Name;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Second_Knee_Bone_Name;                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Thigh_Bone_Name;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x8];                                       // 0x0020(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Feet_Rotation_Offset;                              // 0x0028(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Fixed_Pole;                                        // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Knee_Direction_Offset;                             // 0x0048(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Feet_Trace_Offset;                                 // 0x0060(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Front_Trace_Point_Spacing;                         // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Side_Traces_Spacing;                               // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Feet_Rotation_Limit;                               // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Fixed_Foot_Height;                                 // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Feet_Heights;                                      // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Feet_Alpha;                                        // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min_Feet_Extension;                                // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_Feet_Extension;                                // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Feet_Upslope_Offset_Multiplier;                    // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Feet_Downslope_Offset_Multiplier;                  // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Feet_Slope_Offset_Clamp_Radius;                    // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_Feet_Lift;                                     // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Overrided_Trace_Radius;                            // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           FeetFollowBones;                                   // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDragonData_FingerData>         Finger_Array;                                      // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_FootData) == 0x000008, "Wrong alignment on FDragonData_FootData");
static_assert(sizeof(FDragonData_FootData) == 0x0000D0, "Wrong size on FDragonData_FootData");
static_assert(offsetof(FDragonData_FootData, Feet_Bone_Name) == 0x000000, "Member 'FDragonData_FootData::Feet_Bone_Name' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Knee_Bone_Name) == 0x000008, "Member 'FDragonData_FootData::Knee_Bone_Name' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Second_Knee_Bone_Name) == 0x000010, "Member 'FDragonData_FootData::Second_Knee_Bone_Name' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Thigh_Bone_Name) == 0x000018, "Member 'FDragonData_FootData::Thigh_Bone_Name' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Feet_Rotation_Offset) == 0x000028, "Member 'FDragonData_FootData::Feet_Rotation_Offset' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Fixed_Pole) == 0x000040, "Member 'FDragonData_FootData::Fixed_Pole' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Knee_Direction_Offset) == 0x000048, "Member 'FDragonData_FootData::Knee_Direction_Offset' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Feet_Trace_Offset) == 0x000060, "Member 'FDragonData_FootData::Feet_Trace_Offset' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Front_Trace_Point_Spacing) == 0x000078, "Member 'FDragonData_FootData::Front_Trace_Point_Spacing' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Side_Traces_Spacing) == 0x00007C, "Member 'FDragonData_FootData::Side_Traces_Spacing' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Feet_Rotation_Limit) == 0x000080, "Member 'FDragonData_FootData::Feet_Rotation_Limit' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Fixed_Foot_Height) == 0x000084, "Member 'FDragonData_FootData::Fixed_Foot_Height' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Feet_Heights) == 0x000088, "Member 'FDragonData_FootData::Feet_Heights' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Feet_Alpha) == 0x00008C, "Member 'FDragonData_FootData::Feet_Alpha' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Min_Feet_Extension) == 0x000090, "Member 'FDragonData_FootData::Min_Feet_Extension' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Max_Feet_Extension) == 0x000094, "Member 'FDragonData_FootData::Max_Feet_Extension' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Feet_Upslope_Offset_Multiplier) == 0x000098, "Member 'FDragonData_FootData::Feet_Upslope_Offset_Multiplier' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Feet_Downslope_Offset_Multiplier) == 0x00009C, "Member 'FDragonData_FootData::Feet_Downslope_Offset_Multiplier' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Feet_Slope_Offset_Clamp_Radius) == 0x0000A0, "Member 'FDragonData_FootData::Feet_Slope_Offset_Clamp_Radius' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Max_Feet_Lift) == 0x0000A4, "Member 'FDragonData_FootData::Max_Feet_Lift' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Overrided_Trace_Radius) == 0x0000A8, "Member 'FDragonData_FootData::Overrided_Trace_Radius' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, FeetFollowBones) == 0x0000B0, "Member 'FDragonData_FootData::FeetFollowBones' has a wrong offset!");
static_assert(offsetof(FDragonData_FootData, Finger_Array) == 0x0000C0, "Member 'FDragonData_FootData::Finger_Array' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_MultiInput
// 0x0020 (0x0020 - 0x0000)
struct FDragonData_MultiInput final
{
public:
	class FName                                   Start_Spine;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Pelvis;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDragonData_FootData>           FeetBones;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_MultiInput) == 0x000008, "Wrong alignment on FDragonData_MultiInput");
static_assert(sizeof(FDragonData_MultiInput) == 0x000020, "Wrong size on FDragonData_MultiInput");
static_assert(offsetof(FDragonData_MultiInput, Start_Spine) == 0x000000, "Member 'FDragonData_MultiInput::Start_Spine' has a wrong offset!");
static_assert(offsetof(FDragonData_MultiInput, Pelvis) == 0x000008, "Member 'FDragonData_MultiInput::Pelvis' has a wrong offset!");
static_assert(offsetof(FDragonData_MultiInput, FeetBones) == 0x000010, "Member 'FDragonData_MultiInput::FeetBones' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_SingleArmElement
// 0x0080 (0x0080 - 0x0000)
struct FDragonData_SingleArmElement final
{
public:
	struct FTransform                             Overrided_Arm_Transform;                           // 0x0000(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Arm_Alpha;                                         // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               rotation_offset;                                   // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_SingleArmElement) == 0x000010, "Wrong alignment on FDragonData_SingleArmElement");
static_assert(sizeof(FDragonData_SingleArmElement) == 0x000080, "Wrong size on FDragonData_SingleArmElement");
static_assert(offsetof(FDragonData_SingleArmElement, Overrided_Arm_Transform) == 0x000000, "Member 'FDragonData_SingleArmElement::Overrided_Arm_Transform' has a wrong offset!");
static_assert(offsetof(FDragonData_SingleArmElement, Arm_Alpha) == 0x000060, "Member 'FDragonData_SingleArmElement::Arm_Alpha' has a wrong offset!");
static_assert(offsetof(FDragonData_SingleArmElement, rotation_offset) == 0x000068, "Member 'FDragonData_SingleArmElement::rotation_offset' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_Overrided_Location_Data
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_Overrided_Location_Data final
{
public:
	TArray<struct FDragonData_SingleArmElement>   Arm_TargetLocation_Overrides;                      // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_Overrided_Location_Data) == 0x000008, "Wrong alignment on FDragonData_Overrided_Location_Data");
static_assert(sizeof(FDragonData_Overrided_Location_Data) == 0x000010, "Wrong size on FDragonData_Overrided_Location_Data");
static_assert(offsetof(FDragonData_Overrided_Location_Data, Arm_TargetLocation_Overrides) == 0x000000, "Member 'FDragonData_Overrided_Location_Data::Arm_TargetLocation_Overrides' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_ArmSizeStruct
// 0x000C (0x000C - 0x0000)
struct FDragonData_ArmSizeStruct final
{
public:
	bool                                          Use_Custom_Arm_Sizes;                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         custom_upperArm_length;                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         custom_lowerArm_length;                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_ArmSizeStruct) == 0x000004, "Wrong alignment on FDragonData_ArmSizeStruct");
static_assert(sizeof(FDragonData_ArmSizeStruct) == 0x00000C, "Wrong size on FDragonData_ArmSizeStruct");
static_assert(offsetof(FDragonData_ArmSizeStruct, Use_Custom_Arm_Sizes) == 0x000000, "Member 'FDragonData_ArmSizeStruct::Use_Custom_Arm_Sizes' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmSizeStruct, custom_upperArm_length) == 0x000004, "Member 'FDragonData_ArmSizeStruct::custom_upperArm_length' has a wrong offset!");
static_assert(offsetof(FDragonData_ArmSizeStruct, custom_lowerArm_length) == 0x000008, "Member 'FDragonData_ArmSizeStruct::custom_lowerArm_length' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_CustomArmLengths
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_CustomArmLengths final
{
public:
	TArray<struct FDragonData_ArmSizeStruct>      CustomArmSizeArray;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_CustomArmLengths) == 0x000008, "Wrong alignment on FDragonData_CustomArmLengths");
static_assert(sizeof(FDragonData_CustomArmLengths) == 0x000010, "Wrong size on FDragonData_CustomArmLengths");
static_assert(offsetof(FDragonData_CustomArmLengths, CustomArmSizeArray) == 0x000000, "Member 'FDragonData_CustomArmLengths::CustomArmSizeArray' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_CustomLimbClamp
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_CustomLimbClamp final
{
public:
	TArray<float>                                 Custom_Limb_Clamp_Array;                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_CustomLimbClamp) == 0x000008, "Wrong alignment on FDragonData_CustomLimbClamp");
static_assert(sizeof(FDragonData_CustomLimbClamp) == 0x000010, "Wrong size on FDragonData_CustomLimbClamp");
static_assert(offsetof(FDragonData_CustomLimbClamp, Custom_Limb_Clamp_Array) == 0x000000, "Member 'FDragonData_CustomLimbClamp::Custom_Limb_Clamp_Array' has a wrong offset!");

// ScriptStruct DragonIKPlugin.AnimNode_DragonControlBase
// 0x00C0 (0x00D0 - 0x0010)
struct FAnimNode_DragonControlBase : public FAnimNode_Base
{
public:
	struct FComponentSpacePoseLink                ComponentPose;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         LODThreshold;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActualAlpha;                                       // 0x0024(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x4];                                       // 0x0028(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EAnimAlphaInputType                           AlphaInputType;                                    // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlphaBoolEnabled;                                 // 0x002D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E[0x2];                                       // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Alpha;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputScaleBias                        AlphaScaleBias;                                    // 0x0034(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputAlphaBoolBlend                   AlphaBoolBlend;                                    // 0x0040(0x0048)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   AlphaCurveName;                                    // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputScaleBiasClamp                   AlphaScaleBiasClamp;                               // 0x0090(0x0030)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DragonControlBase) == 0x000008, "Wrong alignment on FAnimNode_DragonControlBase");
static_assert(sizeof(FAnimNode_DragonControlBase) == 0x0000D0, "Wrong size on FAnimNode_DragonControlBase");
static_assert(offsetof(FAnimNode_DragonControlBase, ComponentPose) == 0x000010, "Member 'FAnimNode_DragonControlBase::ComponentPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonControlBase, LODThreshold) == 0x000020, "Member 'FAnimNode_DragonControlBase::LODThreshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonControlBase, ActualAlpha) == 0x000024, "Member 'FAnimNode_DragonControlBase::ActualAlpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonControlBase, AlphaInputType) == 0x00002C, "Member 'FAnimNode_DragonControlBase::AlphaInputType' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonControlBase, bAlphaBoolEnabled) == 0x00002D, "Member 'FAnimNode_DragonControlBase::bAlphaBoolEnabled' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonControlBase, Alpha) == 0x000030, "Member 'FAnimNode_DragonControlBase::Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonControlBase, AlphaScaleBias) == 0x000034, "Member 'FAnimNode_DragonControlBase::AlphaScaleBias' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonControlBase, AlphaBoolBlend) == 0x000040, "Member 'FAnimNode_DragonControlBase::AlphaBoolBlend' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonControlBase, AlphaCurveName) == 0x000088, "Member 'FAnimNode_DragonControlBase::AlphaCurveName' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonControlBase, AlphaScaleBiasClamp) == 0x000090, "Member 'FAnimNode_DragonControlBase::AlphaScaleBiasClamp' has a wrong offset!");

// ScriptStruct DragonIKPlugin.AnimNode_DragonAimSolver
// 0x0CB0 (0x0D80 - 0x00D0)
struct FAnimNode_DragonAimSolver final : public FAnimNode_DragonControlBase
{
public:
	bool                                          Use_FName_Bone_Input;                              // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         EndSplineBone;                                     // 0x00D4(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         StartSplineBone;                                   // 0x00E4(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   Name_EndSpline_Bone;                               // 0x00F4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_StartSpline_Bone;                             // 0x00FC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0xC];                                      // 0x0104(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LookAtLocation;                                    // 0x0110(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Advanced_Input_Mode;                           // 0x0170(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_AimSolver_SkeletonInput    Bone_Structure_Precise;                            // 0x0178(0x0010)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x10];                                     // 0x0188(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_MultiInput                 dragon_input_data;                                 // 0x0198(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0xA8];                                     // 0x01B8(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDragonData_ArmsData>           Aiming_Hand_Limbs;                                 // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_Overrided_Location_Data    Arm_TargetLocation_Overrides;                      // 0x0280(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          Use_Separate_Targets;                              // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Override_Hand_Rotation;                            // 0x0291(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          enable_head_aim;                                   // 0x0292(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowHandStretching;                              // 0x0293(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_ElbowOffset_Struct         Extra_Struct_Elbow_Pole_Array;                     // 0x0298(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          reach_instead;                                     // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Aggregate_Hand_Body;                               // 0x02A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Let_Arm_Twist_With_Hand;                           // 0x02AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPole_System_DragonIK                         pole_system_input;                                 // 0x02AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETwist_Type_DragonIK                          arm_twist_axis;                                    // 0x02AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotation_Type_DragonIK                       hand_rotation_method;                              // 0x02AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Override_Head_Rotation;                            // 0x02AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable_Hand_Interpolation;                         // 0x02AF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hand_Interpolation_Speed;                          // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_CustomArmLengths           custom_arm_lengths;                                // 0x02B8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EInputTransformSpace_DragonIK                 arm_transform_space;                               // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Main_Arm_Index;                                    // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x120];                                    // 0x02D0(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lookat_Radius;                                     // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Inner_Body_Clamp;                                  // 0x03F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Lookat_Clamp;                                      // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Limbs_Clamp;                                       // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDragonData_CustomLimbClamp            Per_Limbs_Clamp_Array;                             // 0x0418(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRotator                               Extra_Aiming_Rotation_Offset;                      // 0x0428(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Downward_Dip_Multiplier;                           // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Inverted_Dip_Multiplier;                           // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Vertical_Dip_Treshold;                             // 0x0448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Side_Move_Multiplier;                              // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Side_Down_Multiplier;                              // 0x0450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Up_Rot_Clamp;                                      // 0x0454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Verticle_Range_Angles;                             // 0x0458(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Horizontal_Range_Angles;                           // 0x0468(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aim_Frontal_Offset;                                // 0x0478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47C[0x4];                                      // 0x047C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Look_Bending_Curve;                                // 0x0480(0x0088)(Edit, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     Look_Multiplier_Curve;                             // 0x0508(0x0088)(Edit, NativeAccessSpecifierPublic)
	EInputTransformSpace_DragonIK                 look_transform_space;                              // 0x0590(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Lock_Legs;                                         // 0x0591(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ignore_elbow_modification;                         // 0x0592(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ignore_separate_hand_solving;                      // 0x0593(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Natural_Method;                                // 0x0594(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Head_Use_Separate_Clamp;                           // 0x0595(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_Head_Accurate;                                  // 0x0596(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          automatic_leg_make;                                // 0x0597(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_598[0x1];                                      // 0x0598(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          enable_solver;                                     // 0x0599(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Work_Outside_PIE;                                  // 0x059A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Physics_Adaptation;                            // 0x059B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   physics_root_reference;                            // 0x059C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Adaptive_Terrain_Tail;                             // 0x05A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               Trace_Channel;                                     // 0x05A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A6[0x2];                                      // 0x05A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Trace_Up_Height;                                   // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Trace_Down_Height;                                 // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B0[0xEC];                                     // 0x05B0(0x00EC)(Fixing Size After Last Property [ Dumper-7 ])
	EInterpoLocation_Type_Plugin                  loc_interp_type;                                   // 0x069C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69D[0x8];                                      // 0x069D(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Enable_Interpolation;                              // 0x06A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A6[0x2];                                      // 0x06A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Interpolation_Speed;                               // 0x06A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Toggle_Interpolation_Speed;                        // 0x06AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B0[0x60];                                     // 0x06B0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAt_Axis;                                       // 0x0710(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Upward_Axis;                                       // 0x0728(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffset;                                      // 0x0740(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Reference_Forward_Axis;                        // 0x0758(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_759[0x7];                                      // 0x0759(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Reference_Constant_Forward_Axis;                   // 0x0760(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_778[0x11D];                                    // 0x0778(0x011D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DisplayLineTrace;                                  // 0x0895(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_896[0xA];                                      // 0x0896(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Debug_LookAtLocation;                              // 0x08A0(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     Debug_Hand_Locations;                              // 0x0900(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_910[0x3B0];                                    // 0x0910(0x03B0)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 owning_skel;                                       // 0x0CC0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC8[0xB8];                                     // 0x0CC8(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DragonAimSolver) == 0x000010, "Wrong alignment on FAnimNode_DragonAimSolver");
static_assert(sizeof(FAnimNode_DragonAimSolver) == 0x000D80, "Wrong size on FAnimNode_DragonAimSolver");
static_assert(offsetof(FAnimNode_DragonAimSolver, Use_FName_Bone_Input) == 0x0000D0, "Member 'FAnimNode_DragonAimSolver::Use_FName_Bone_Input' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, EndSplineBone) == 0x0000D4, "Member 'FAnimNode_DragonAimSolver::EndSplineBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, StartSplineBone) == 0x0000E4, "Member 'FAnimNode_DragonAimSolver::StartSplineBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Name_EndSpline_Bone) == 0x0000F4, "Member 'FAnimNode_DragonAimSolver::Name_EndSpline_Bone' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Name_StartSpline_Bone) == 0x0000FC, "Member 'FAnimNode_DragonAimSolver::Name_StartSpline_Bone' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, LookAtLocation) == 0x000110, "Member 'FAnimNode_DragonAimSolver::LookAtLocation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Use_Advanced_Input_Mode) == 0x000170, "Member 'FAnimNode_DragonAimSolver::Use_Advanced_Input_Mode' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Bone_Structure_Precise) == 0x000178, "Member 'FAnimNode_DragonAimSolver::Bone_Structure_Precise' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, dragon_input_data) == 0x000198, "Member 'FAnimNode_DragonAimSolver::dragon_input_data' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Aiming_Hand_Limbs) == 0x000260, "Member 'FAnimNode_DragonAimSolver::Aiming_Hand_Limbs' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Arm_TargetLocation_Overrides) == 0x000280, "Member 'FAnimNode_DragonAimSolver::Arm_TargetLocation_Overrides' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Use_Separate_Targets) == 0x000290, "Member 'FAnimNode_DragonAimSolver::Use_Separate_Targets' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Override_Hand_Rotation) == 0x000291, "Member 'FAnimNode_DragonAimSolver::Override_Hand_Rotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, enable_head_aim) == 0x000292, "Member 'FAnimNode_DragonAimSolver::enable_head_aim' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, bAllowHandStretching) == 0x000293, "Member 'FAnimNode_DragonAimSolver::bAllowHandStretching' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Extra_Struct_Elbow_Pole_Array) == 0x000298, "Member 'FAnimNode_DragonAimSolver::Extra_Struct_Elbow_Pole_Array' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, reach_instead) == 0x0002A8, "Member 'FAnimNode_DragonAimSolver::reach_instead' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Aggregate_Hand_Body) == 0x0002A9, "Member 'FAnimNode_DragonAimSolver::Aggregate_Hand_Body' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Let_Arm_Twist_With_Hand) == 0x0002AA, "Member 'FAnimNode_DragonAimSolver::Let_Arm_Twist_With_Hand' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, pole_system_input) == 0x0002AB, "Member 'FAnimNode_DragonAimSolver::pole_system_input' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, arm_twist_axis) == 0x0002AC, "Member 'FAnimNode_DragonAimSolver::arm_twist_axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, hand_rotation_method) == 0x0002AD, "Member 'FAnimNode_DragonAimSolver::hand_rotation_method' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Override_Head_Rotation) == 0x0002AE, "Member 'FAnimNode_DragonAimSolver::Override_Head_Rotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Enable_Hand_Interpolation) == 0x0002AF, "Member 'FAnimNode_DragonAimSolver::Enable_Hand_Interpolation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Hand_Interpolation_Speed) == 0x0002B0, "Member 'FAnimNode_DragonAimSolver::Hand_Interpolation_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, custom_arm_lengths) == 0x0002B8, "Member 'FAnimNode_DragonAimSolver::custom_arm_lengths' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, arm_transform_space) == 0x0002C8, "Member 'FAnimNode_DragonAimSolver::arm_transform_space' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Main_Arm_Index) == 0x0002CC, "Member 'FAnimNode_DragonAimSolver::Main_Arm_Index' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Lookat_Radius) == 0x0003F0, "Member 'FAnimNode_DragonAimSolver::Lookat_Radius' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Inner_Body_Clamp) == 0x0003F8, "Member 'FAnimNode_DragonAimSolver::Inner_Body_Clamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Lookat_Clamp) == 0x000410, "Member 'FAnimNode_DragonAimSolver::Lookat_Clamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Limbs_Clamp) == 0x000414, "Member 'FAnimNode_DragonAimSolver::Limbs_Clamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Per_Limbs_Clamp_Array) == 0x000418, "Member 'FAnimNode_DragonAimSolver::Per_Limbs_Clamp_Array' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Extra_Aiming_Rotation_Offset) == 0x000428, "Member 'FAnimNode_DragonAimSolver::Extra_Aiming_Rotation_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Downward_Dip_Multiplier) == 0x000440, "Member 'FAnimNode_DragonAimSolver::Downward_Dip_Multiplier' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Inverted_Dip_Multiplier) == 0x000444, "Member 'FAnimNode_DragonAimSolver::Inverted_Dip_Multiplier' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Vertical_Dip_Treshold) == 0x000448, "Member 'FAnimNode_DragonAimSolver::Vertical_Dip_Treshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Side_Move_Multiplier) == 0x00044C, "Member 'FAnimNode_DragonAimSolver::Side_Move_Multiplier' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Side_Down_Multiplier) == 0x000450, "Member 'FAnimNode_DragonAimSolver::Side_Down_Multiplier' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Up_Rot_Clamp) == 0x000454, "Member 'FAnimNode_DragonAimSolver::Up_Rot_Clamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Verticle_Range_Angles) == 0x000458, "Member 'FAnimNode_DragonAimSolver::Verticle_Range_Angles' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Horizontal_Range_Angles) == 0x000468, "Member 'FAnimNode_DragonAimSolver::Horizontal_Range_Angles' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Aim_Frontal_Offset) == 0x000478, "Member 'FAnimNode_DragonAimSolver::Aim_Frontal_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Look_Bending_Curve) == 0x000480, "Member 'FAnimNode_DragonAimSolver::Look_Bending_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Look_Multiplier_Curve) == 0x000508, "Member 'FAnimNode_DragonAimSolver::Look_Multiplier_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, look_transform_space) == 0x000590, "Member 'FAnimNode_DragonAimSolver::look_transform_space' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Lock_Legs) == 0x000591, "Member 'FAnimNode_DragonAimSolver::Lock_Legs' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, ignore_elbow_modification) == 0x000592, "Member 'FAnimNode_DragonAimSolver::ignore_elbow_modification' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, ignore_separate_hand_solving) == 0x000593, "Member 'FAnimNode_DragonAimSolver::ignore_separate_hand_solving' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Use_Natural_Method) == 0x000594, "Member 'FAnimNode_DragonAimSolver::Use_Natural_Method' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Head_Use_Separate_Clamp) == 0x000595, "Member 'FAnimNode_DragonAimSolver::Head_Use_Separate_Clamp' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Is_Head_Accurate) == 0x000596, "Member 'FAnimNode_DragonAimSolver::Is_Head_Accurate' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, automatic_leg_make) == 0x000597, "Member 'FAnimNode_DragonAimSolver::automatic_leg_make' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, enable_solver) == 0x000599, "Member 'FAnimNode_DragonAimSolver::enable_solver' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Work_Outside_PIE) == 0x00059A, "Member 'FAnimNode_DragonAimSolver::Work_Outside_PIE' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Use_Physics_Adaptation) == 0x00059B, "Member 'FAnimNode_DragonAimSolver::Use_Physics_Adaptation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, physics_root_reference) == 0x00059C, "Member 'FAnimNode_DragonAimSolver::physics_root_reference' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Adaptive_Terrain_Tail) == 0x0005A4, "Member 'FAnimNode_DragonAimSolver::Adaptive_Terrain_Tail' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Trace_Channel) == 0x0005A5, "Member 'FAnimNode_DragonAimSolver::Trace_Channel' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Trace_Up_Height) == 0x0005A8, "Member 'FAnimNode_DragonAimSolver::Trace_Up_Height' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Trace_Down_Height) == 0x0005AC, "Member 'FAnimNode_DragonAimSolver::Trace_Down_Height' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, loc_interp_type) == 0x00069C, "Member 'FAnimNode_DragonAimSolver::loc_interp_type' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Enable_Interpolation) == 0x0006A5, "Member 'FAnimNode_DragonAimSolver::Enable_Interpolation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Interpolation_Speed) == 0x0006A8, "Member 'FAnimNode_DragonAimSolver::Interpolation_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Toggle_Interpolation_Speed) == 0x0006AC, "Member 'FAnimNode_DragonAimSolver::Toggle_Interpolation_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, LookAt_Axis) == 0x000710, "Member 'FAnimNode_DragonAimSolver::LookAt_Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Upward_Axis) == 0x000728, "Member 'FAnimNode_DragonAimSolver::Upward_Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, TargetOffset) == 0x000740, "Member 'FAnimNode_DragonAimSolver::TargetOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Use_Reference_Forward_Axis) == 0x000758, "Member 'FAnimNode_DragonAimSolver::Use_Reference_Forward_Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Reference_Constant_Forward_Axis) == 0x000760, "Member 'FAnimNode_DragonAimSolver::Reference_Constant_Forward_Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, DisplayLineTrace) == 0x000895, "Member 'FAnimNode_DragonAimSolver::DisplayLineTrace' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Debug_LookAtLocation) == 0x0008A0, "Member 'FAnimNode_DragonAimSolver::Debug_LookAtLocation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, Debug_Hand_Locations) == 0x000900, "Member 'FAnimNode_DragonAimSolver::Debug_Hand_Locations' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonAimSolver, owning_skel) == 0x000CC0, "Member 'FAnimNode_DragonAimSolver::owning_skel' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonIKTraceKeyValuePair
// 0x00F8 (0x00F8 - 0x0000)
struct FDragonIKTraceKeyValuePair final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             hit_result;                                        // 0x0010(0x00E8)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonIKTraceKeyValuePair) == 0x000008, "Wrong alignment on FDragonIKTraceKeyValuePair");
static_assert(sizeof(FDragonIKTraceKeyValuePair) == 0x0000F8, "Wrong size on FDragonIKTraceKeyValuePair");
static_assert(offsetof(FDragonIKTraceKeyValuePair, Key) == 0x000000, "Member 'FDragonIKTraceKeyValuePair::Key' has a wrong offset!");
static_assert(offsetof(FDragonIKTraceKeyValuePair, BoneName) == 0x000008, "Member 'FDragonIKTraceKeyValuePair::BoneName' has a wrong offset!");
static_assert(offsetof(FDragonIKTraceKeyValuePair, hit_result) == 0x000010, "Member 'FDragonIKTraceKeyValuePair::hit_result' has a wrong offset!");

// ScriptStruct DragonIKPlugin.ChinaDragonChainLink
// 0x01D0 (0x01D0 - 0x0000)
struct alignas(0x10) FChinaDragonChainLink final
{
public:
	uint8                                         Pad_0[0x1D0];                                      // 0x0000(0x01D0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChinaDragonChainLink) == 0x000010, "Wrong alignment on FChinaDragonChainLink");
static_assert(sizeof(FChinaDragonChainLink) == 0x0001D0, "Wrong size on FChinaDragonChainLink");

// ScriptStruct DragonIKPlugin.DragonData_ChineseDragonBoneInput
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_ChineseDragonBoneInput final
{
public:
	TArray<class FName>                           Custom_Bone_Structure;                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_ChineseDragonBoneInput) == 0x000008, "Wrong alignment on FDragonData_ChineseDragonBoneInput");
static_assert(sizeof(FDragonData_ChineseDragonBoneInput) == 0x000010, "Wrong size on FDragonData_ChineseDragonBoneInput");
static_assert(offsetof(FDragonData_ChineseDragonBoneInput, Custom_Bone_Structure) == 0x000000, "Member 'FDragonData_ChineseDragonBoneInput::Custom_Bone_Structure' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_ChineseDragonBoneRotationOffset
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_ChineseDragonBoneRotationOffset final
{
public:
	TArray<struct FRotator>                       Custom_Bone_Rotation_Offset;                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_ChineseDragonBoneRotationOffset) == 0x000008, "Wrong alignment on FDragonData_ChineseDragonBoneRotationOffset");
static_assert(sizeof(FDragonData_ChineseDragonBoneRotationOffset) == 0x000010, "Wrong size on FDragonData_ChineseDragonBoneRotationOffset");
static_assert(offsetof(FDragonData_ChineseDragonBoneRotationOffset, Custom_Bone_Rotation_Offset) == 0x000000, "Member 'FDragonData_ChineseDragonBoneRotationOffset::Custom_Bone_Rotation_Offset' has a wrong offset!");

// ScriptStruct DragonIKPlugin.AnimNode_ChineseDragonSolver
// 0x03F0 (0x04C0 - 0x00D0)
struct FAnimNode_ChineseDragonSolver final : public FAnimNode_DragonControlBase
{
public:
	uint8                                         Pad_D0[0x40];                                      // 0x00D0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_ChineseDragonBoneInput     Custom_Bone_Input;                                 // 0x0110(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         Stability_Reference_Bone_Index;                    // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0xC];                                      // 0x0124(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             EffectorTransform;                                 // 0x0130(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDragonData_ChineseDragonBoneRotationOffset Extra_Rotation_Offset_Per_Bone;                    // 0x0190(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRotator                               Extra_Rotation_Offset_Overall;                     // 0x01A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Extra_Rotation_Offset;                             // 0x01B8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0xC0];                                     // 0x01D0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Use_Advanced_Strict_Chain_Logic;                   // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Limit_Z_Solving;                                   // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Fix_Root_in_Place;                                 // 0x0299(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Continous_Normalization;                           // 0x029A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29B[0x1];                                      // 0x029B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Normalization_Speed;                               // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     Normalization_Multiplier_Rel_Velocity;             // 0x02A0(0x0088)(Edit, NativeAccessSpecifierPublic)
	bool                                          Preserve_Original_Pose;                            // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Test_Ref_Forward_Axis;                             // 0x0330(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pelvis_Positioning_Calibration_Value;              // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34C[0x24];                                     // 0x034C(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Enable_AnimBP_Viewport_Output;                     // 0x0370(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Scale_Add_Mode;                                // 0x0371(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Rot_Add_Mode;                                  // 0x0372(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          rotation_relative_to_mesh;                         // 0x0373(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Warmup_Logic;                                  // 0x0374(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_375[0x3];                                      // 0x0375(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Initial_Warmup_Distance;                           // 0x0378(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Reset_To_Normal;                                   // 0x037C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37D[0xF];                                      // 0x037D(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Use_Interpolation;                                 // 0x038C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38D[0x3];                                      // 0x038D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Interpolation_Speed;                               // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Reset_ON_Interpolation_Speed;                      // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Reset_OFF_Interpolation_Speed;                     // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x10];                                     // 0x03A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CachedEffectorCSTransform;                         // 0x03B0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x18];                                     // 0x0410(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 owning_skel;                                       // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x90];                                     // 0x0430(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_ChineseDragonSolver) == 0x000010, "Wrong alignment on FAnimNode_ChineseDragonSolver");
static_assert(sizeof(FAnimNode_ChineseDragonSolver) == 0x0004C0, "Wrong size on FAnimNode_ChineseDragonSolver");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Custom_Bone_Input) == 0x000110, "Member 'FAnimNode_ChineseDragonSolver::Custom_Bone_Input' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Stability_Reference_Bone_Index) == 0x000120, "Member 'FAnimNode_ChineseDragonSolver::Stability_Reference_Bone_Index' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, EffectorTransform) == 0x000130, "Member 'FAnimNode_ChineseDragonSolver::EffectorTransform' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Extra_Rotation_Offset_Per_Bone) == 0x000190, "Member 'FAnimNode_ChineseDragonSolver::Extra_Rotation_Offset_Per_Bone' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Extra_Rotation_Offset_Overall) == 0x0001A0, "Member 'FAnimNode_ChineseDragonSolver::Extra_Rotation_Offset_Overall' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Extra_Rotation_Offset) == 0x0001B8, "Member 'FAnimNode_ChineseDragonSolver::Extra_Rotation_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Use_Advanced_Strict_Chain_Logic) == 0x000290, "Member 'FAnimNode_ChineseDragonSolver::Use_Advanced_Strict_Chain_Logic' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Limit_Z_Solving) == 0x000298, "Member 'FAnimNode_ChineseDragonSolver::Limit_Z_Solving' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Fix_Root_in_Place) == 0x000299, "Member 'FAnimNode_ChineseDragonSolver::Fix_Root_in_Place' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Continous_Normalization) == 0x00029A, "Member 'FAnimNode_ChineseDragonSolver::Continous_Normalization' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Normalization_Speed) == 0x00029C, "Member 'FAnimNode_ChineseDragonSolver::Normalization_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Normalization_Multiplier_Rel_Velocity) == 0x0002A0, "Member 'FAnimNode_ChineseDragonSolver::Normalization_Multiplier_Rel_Velocity' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Preserve_Original_Pose) == 0x000328, "Member 'FAnimNode_ChineseDragonSolver::Preserve_Original_Pose' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Test_Ref_Forward_Axis) == 0x000330, "Member 'FAnimNode_ChineseDragonSolver::Test_Ref_Forward_Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Pelvis_Positioning_Calibration_Value) == 0x000348, "Member 'FAnimNode_ChineseDragonSolver::Pelvis_Positioning_Calibration_Value' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Enable_AnimBP_Viewport_Output) == 0x000370, "Member 'FAnimNode_ChineseDragonSolver::Enable_AnimBP_Viewport_Output' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Use_Scale_Add_Mode) == 0x000371, "Member 'FAnimNode_ChineseDragonSolver::Use_Scale_Add_Mode' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Use_Rot_Add_Mode) == 0x000372, "Member 'FAnimNode_ChineseDragonSolver::Use_Rot_Add_Mode' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, rotation_relative_to_mesh) == 0x000373, "Member 'FAnimNode_ChineseDragonSolver::rotation_relative_to_mesh' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Use_Warmup_Logic) == 0x000374, "Member 'FAnimNode_ChineseDragonSolver::Use_Warmup_Logic' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Initial_Warmup_Distance) == 0x000378, "Member 'FAnimNode_ChineseDragonSolver::Initial_Warmup_Distance' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Reset_To_Normal) == 0x00037C, "Member 'FAnimNode_ChineseDragonSolver::Reset_To_Normal' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Use_Interpolation) == 0x00038C, "Member 'FAnimNode_ChineseDragonSolver::Use_Interpolation' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Interpolation_Speed) == 0x000390, "Member 'FAnimNode_ChineseDragonSolver::Interpolation_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Reset_ON_Interpolation_Speed) == 0x000394, "Member 'FAnimNode_ChineseDragonSolver::Reset_ON_Interpolation_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Reset_OFF_Interpolation_Speed) == 0x000398, "Member 'FAnimNode_ChineseDragonSolver::Reset_OFF_Interpolation_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, Precision) == 0x00039C, "Member 'FAnimNode_ChineseDragonSolver::Precision' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, CachedEffectorCSTransform) == 0x0003B0, "Member 'FAnimNode_ChineseDragonSolver::CachedEffectorCSTransform' has a wrong offset!");
static_assert(offsetof(FAnimNode_ChineseDragonSolver, owning_skel) == 0x000428, "Member 'FAnimNode_ChineseDragonSolver::owning_skel' has a wrong offset!");

// ScriptStruct DragonIKPlugin.SocketDragonReference
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x10) FSocketDragonReference final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSocketDragonReference) == 0x000010, "Wrong alignment on FSocketDragonReference");
static_assert(sizeof(FSocketDragonReference) == 0x000070, "Wrong size on FSocketDragonReference");
static_assert(offsetof(FSocketDragonReference, SocketName) == 0x000060, "Member 'FSocketDragonReference::SocketName' has a wrong offset!");

// ScriptStruct DragonIKPlugin.BoneDragonSocketTarget
// 0x0090 (0x0090 - 0x0000)
struct FBoneDragonSocketTarget final
{
public:
	bool                                          bUseSocket;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBoneReference                         BoneReference;                                     // 0x0004(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSocketDragonReference                 SocketReference;                                   // 0x0020(0x0070)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneDragonSocketTarget) == 0x000010, "Wrong alignment on FBoneDragonSocketTarget");
static_assert(sizeof(FBoneDragonSocketTarget) == 0x000090, "Wrong size on FBoneDragonSocketTarget");
static_assert(offsetof(FBoneDragonSocketTarget, bUseSocket) == 0x000000, "Member 'FBoneDragonSocketTarget::bUseSocket' has a wrong offset!");
static_assert(offsetof(FBoneDragonSocketTarget, BoneReference) == 0x000004, "Member 'FBoneDragonSocketTarget::BoneReference' has a wrong offset!");
static_assert(offsetof(FBoneDragonSocketTarget, SocketReference) == 0x000020, "Member 'FBoneDragonSocketTarget::SocketReference' has a wrong offset!");

// ScriptStruct DragonIKPlugin.AnimNode_DragonFabrikSolver
// 0x00F0 (0x01C0 - 0x00D0)
struct FAnimNode_DragonFabrikSolver final : public FAnimNode_DragonControlBase
{
public:
	struct FBoneReference                         TipBone_Input;                                     // 0x00D0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RootBone_Input;                                    // 0x00E0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxIterations;                                     // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Target_Transform;                                  // 0x0100(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x40];                                     // 0x0160(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 owning_skel;                                       // 0x01A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x18];                                     // 0x01A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DragonFabrikSolver) == 0x000010, "Wrong alignment on FAnimNode_DragonFabrikSolver");
static_assert(sizeof(FAnimNode_DragonFabrikSolver) == 0x0001C0, "Wrong size on FAnimNode_DragonFabrikSolver");
static_assert(offsetof(FAnimNode_DragonFabrikSolver, TipBone_Input) == 0x0000D0, "Member 'FAnimNode_DragonFabrikSolver::TipBone_Input' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFabrikSolver, RootBone_Input) == 0x0000E0, "Member 'FAnimNode_DragonFabrikSolver::RootBone_Input' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFabrikSolver, Precision) == 0x0000F0, "Member 'FAnimNode_DragonFabrikSolver::Precision' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFabrikSolver, MaxIterations) == 0x0000F4, "Member 'FAnimNode_DragonFabrikSolver::MaxIterations' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFabrikSolver, Target_Transform) == 0x000100, "Member 'FAnimNode_DragonFabrikSolver::Target_Transform' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFabrikSolver, owning_skel) == 0x0001A0, "Member 'FAnimNode_DragonFabrikSolver::owning_skel' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_BoneFatStruct
// 0x001C (0x001C - 0x0000)
struct FDragonData_BoneFatStruct final
{
public:
	class FName                                   bone_name;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInput_FatBoneFAxis                           Bone_Axis;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x13];                                       // 0x0009(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDragonData_BoneFatStruct) == 0x000004, "Wrong alignment on FDragonData_BoneFatStruct");
static_assert(sizeof(FDragonData_BoneFatStruct) == 0x00001C, "Wrong size on FDragonData_BoneFatStruct");
static_assert(offsetof(FDragonData_BoneFatStruct, bone_name) == 0x000000, "Member 'FDragonData_BoneFatStruct::bone_name' has a wrong offset!");
static_assert(offsetof(FDragonData_BoneFatStruct, Bone_Axis) == 0x000008, "Member 'FDragonData_BoneFatStruct::Bone_Axis' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_DragonFatBoneInput
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_DragonFatBoneInput final
{
public:
	TArray<struct FDragonData_BoneFatStruct>      Custom_Bone_Structure;                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_DragonFatBoneInput) == 0x000008, "Wrong alignment on FDragonData_DragonFatBoneInput");
static_assert(sizeof(FDragonData_DragonFatBoneInput) == 0x000010, "Wrong size on FDragonData_DragonFatBoneInput");
static_assert(offsetof(FDragonData_DragonFatBoneInput, Custom_Bone_Structure) == 0x000000, "Member 'FDragonData_DragonFatBoneInput::Custom_Bone_Structure' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_DragonFatControlInput
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_DragonFatControlInput final
{
public:
	TArray<float>                                 FatControlStrengthArray;                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_DragonFatControlInput) == 0x000008, "Wrong alignment on FDragonData_DragonFatControlInput");
static_assert(sizeof(FDragonData_DragonFatControlInput) == 0x000010, "Wrong size on FDragonData_DragonFatControlInput");
static_assert(offsetof(FDragonData_DragonFatControlInput, FatControlStrengthArray) == 0x000000, "Member 'FDragonData_DragonFatControlInput::FatControlStrengthArray' has a wrong offset!");

// ScriptStruct DragonIKPlugin.AnimNode_DragonFatSolver
// 0x00A8 (0x0178 - 0x00D0)
struct FAnimNode_DragonFatSolver final : public FAnimNode_DragonControlBase
{
public:
	uint8                                         Pad_D0[0x50];                                      // 0x00D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_DragonFatBoneInput         fat_bone_input;                                    // 0x0120(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDragonData_DragonFatControlInput      fat_control_input;                                 // 0x0130(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Fat_Strength_Value;                                // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fat_Alpha_Value;                                   // 0x0144(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Axis_Limitation;                               // 0x0148(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x27];                                     // 0x0149(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 owning_skel;                                       // 0x0170(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_DragonFatSolver) == 0x000008, "Wrong alignment on FAnimNode_DragonFatSolver");
static_assert(sizeof(FAnimNode_DragonFatSolver) == 0x000178, "Wrong size on FAnimNode_DragonFatSolver");
static_assert(offsetof(FAnimNode_DragonFatSolver, fat_bone_input) == 0x000120, "Member 'FAnimNode_DragonFatSolver::fat_bone_input' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFatSolver, fat_control_input) == 0x000130, "Member 'FAnimNode_DragonFatSolver::fat_control_input' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFatSolver, Fat_Strength_Value) == 0x000140, "Member 'FAnimNode_DragonFatSolver::Fat_Strength_Value' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFatSolver, Fat_Alpha_Value) == 0x000144, "Member 'FAnimNode_DragonFatSolver::Fat_Alpha_Value' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFatSolver, Use_Axis_Limitation) == 0x000148, "Member 'FAnimNode_DragonFatSolver::Use_Axis_Limitation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFatSolver, owning_skel) == 0x000170, "Member 'FAnimNode_DragonFatSolver::owning_skel' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_FeetOffset_Struct
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_FeetOffset_Struct final
{
public:
	TArray<struct FVector>                        feet_extra_offset_array;                           // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_FeetOffset_Struct) == 0x000008, "Wrong alignment on FDragonData_FeetOffset_Struct");
static_assert(sizeof(FDragonData_FeetOffset_Struct) == 0x000010, "Wrong size on FDragonData_FeetOffset_Struct");
static_assert(offsetof(FDragonData_FeetOffset_Struct, feet_extra_offset_array) == 0x000000, "Member 'FDragonData_FeetOffset_Struct::feet_extra_offset_array' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_FeetAlpha_Struct
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_FeetAlpha_Struct final
{
public:
	TArray<float>                                 feet_IK_alpha_array;                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_FeetAlpha_Struct) == 0x000008, "Wrong alignment on FDragonData_FeetAlpha_Struct");
static_assert(sizeof(FDragonData_FeetAlpha_Struct) == 0x000010, "Wrong size on FDragonData_FeetAlpha_Struct");
static_assert(offsetof(FDragonData_FeetAlpha_Struct, feet_IK_alpha_array) == 0x000000, "Member 'FDragonData_FeetAlpha_Struct::feet_IK_alpha_array' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_StickyFeetStruct
// 0x0020 (0x0020 - 0x0000)
struct FDragonData_StickyFeetStruct final
{
public:
	TArray<bool>                                  sticky_feet_array;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 sticky_feet_alpha_array;                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_StickyFeetStruct) == 0x000008, "Wrong alignment on FDragonData_StickyFeetStruct");
static_assert(sizeof(FDragonData_StickyFeetStruct) == 0x000020, "Wrong size on FDragonData_StickyFeetStruct");
static_assert(offsetof(FDragonData_StickyFeetStruct, sticky_feet_array) == 0x000000, "Member 'FDragonData_StickyFeetStruct::sticky_feet_array' has a wrong offset!");
static_assert(offsetof(FDragonData_StickyFeetStruct, sticky_feet_alpha_array) == 0x000010, "Member 'FDragonData_StickyFeetStruct::sticky_feet_alpha_array' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_StickySocketStruct
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_StickySocketStruct final
{
public:
	TArray<struct FBoneSocketTarget>              sticky_socket_array;                               // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_StickySocketStruct) == 0x000008, "Wrong alignment on FDragonData_StickySocketStruct");
static_assert(sizeof(FDragonData_StickySocketStruct) == 0x000010, "Wrong size on FDragonData_StickySocketStruct");
static_assert(offsetof(FDragonData_StickySocketStruct, sticky_socket_array) == 0x000000, "Member 'FDragonData_StickySocketStruct::sticky_socket_array' has a wrong offset!");

// ScriptStruct DragonIKPlugin.AnimNode_DragonFeetSolver
// 0x08E0 (0x09B0 - 0x00D0)
struct alignas(0x10) FAnimNode_DragonFeetSolver final : public FAnimNode_DragonControlBase
{
public:
	class UDragonIKTraceManagerComponent*         Dragon_Trace_Manager;                              // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          use_trace_manager_component;                       // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         solver_identifier;                                 // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x8];                                       // 0x00E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_MultiInput                 dragon_input_data;                                 // 0x00E8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x98];                                     // 0x0108(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	EIK_Type_Plugin                               ik_type;                                           // 0x01A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIKTrace_Type_Plugin                          trace_type;                                        // 0x01A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A2[0x2];                                      // 0x01A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Trace_Radius;                                      // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          line_trace_hit_complex;                            // 0x01A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A9[0xF];                                      // 0x01A9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         trace_interval_duration;                           // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_LOD_Specific_Intervals;                        // 0x01BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BD[0x3];                                      // 0x01BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LOD0_Interval;                                     // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LOD1_Interval;                                     // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LOD2_Interval;                                     // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Trace_Distance_Adapting;                       // 0x01CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CD[0x3];                                      // 0x01CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Trace_Max_Distance;                                // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Interval_Velocity_Curve;                       // 0x01D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Interval_Velocity_Curve;                           // 0x01D8(0x0088)(Edit, NativeAccessSpecifierPublic)
	bool                                          Override_Curve_Velocity;                           // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         custom_velocity;                                   // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInterpoLocation_Type_Plugin                  loc_interp_type;                                   // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0xB];                                      // 0x0269(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	EInterpoRotation_Type_Plugin                  rot_interp_type;                                   // 0x0274(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_275[0x3];                                      // 0x0275(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         virtual_scale;                                     // 0x0278(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_FeetAlpha_Struct           feet_alpha_multiplier_array;                       // 0x0280(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FDragonData_FeetOffset_Struct          feet_extra_offset_array;                           // 0x0290(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FRotator                               Overall_Feet_Rotation_Offset;                      // 0x02A0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          automatic_leg_make;                                // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_OptionalRef_Feet_As_Ref;                       // 0x02B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          enable_solver;                                     // 0x02BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Work_Outside_PIE;                                  // 0x02BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FComponentSpacePoseLink                OptionalRefPose;                                   // 0x02C0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          interpolate_only_z;                                // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         shift_speed;                                       // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Location_Lerp_Speed;                               // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         feet_rotation_speed;                               // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ignore_shift_speed;                                // 0x02E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore_Lerping;                                    // 0x02E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore_Location_Lerping;                           // 0x02EA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EB[0x5];                                      // 0x02EB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Interpolation_Velocity_Curve;                      // 0x02F0(0x0088)(Edit, NativeAccessSpecifierPublic)
	bool                                          Enable_Complex_Rotation_Method;                    // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     ComplexSimpleFoot_Velocity_Curve;                  // 0x0380(0x0088)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_408[0x40];                                     // 0x0408(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	ETraceTypeQuery                               Trace_Channel;                                     // 0x0448(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               Anti_Trace_Channel;                                // 0x0449(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44A[0x2];                                      // 0x044A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FPS_Lerp_Treshold;                                 // 0x044C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x1C4];                                    // 0x0450(0x01C4)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         line_trace_upper_height;                           // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         line_trace_down_height;                            // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Trace_Down_Multiplier_Curve;                       // 0x0620(0x0088)(Edit, NativeAccessSpecifierPublic)
	bool                                          Use_Anti_Channel;                                  // 0x06A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          use_footstep_listening;                            // 0x06A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6AA[0x6];                                      // 0x06AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDragonIKFootStepsComponent*            dragon_footsteps_component;                        // 0x06B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Should_Rotate_Feet;                                // 0x06B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B9[0x1];                                      // 0x06B9(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          show_trace_in_game;                                // 0x06BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          execute_in_preview;                                // 0x06BB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6BC[0xC];                                      // 0x06BC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Character_Actor;                                   // 0x06C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D0[0x8];                                      // 0x06D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Enable_Pitch;                                      // 0x06D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable_Roll;                                       // 0x06D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6DA[0x6];                                      // 0x06DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                character_direction_vector_CS;                     // 0x06E0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                character_forward_direction_vector_CS;             // 0x06F8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                poles_forward_direction_vector_CS;                 // 0x0710(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Four_Point_Feets;                              // 0x0728(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable_Foot_Lift_Limit;                            // 0x0729(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Affect_Toes_Always;                                // 0x072A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72B[0x5];                                      // 0x072B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Finger_Alpha_Velocity_Curve;                       // 0x0730(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         Max_Limb_Radius;                                   // 0x07B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Feet_Lift_Warping;                                 // 0x07BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7BD[0x3];                                      // 0x07BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Feet_Lift_Warp_Multiplier;                         // 0x07C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         feet_vertical_size;                                // 0x07C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Feet_Lift_Limit;                                   // 0x07C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          sticky_feet_mode;                                  // 0x07CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7CD[0x3];                                      // 0x07CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         sticky_feet_on_speed;                              // 0x07D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         sticky_feet_off_speed;                             // 0x07D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sticky_Feet_Range;                                 // 0x07D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Lock_Feet_Rotation;                                // 0x07DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7DD[0x3];                                      // 0x07DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_StickyFeetStruct           sticky_feets_data;                                 // 0x07E0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          sticky_floor_detection;                            // 0x0800(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_801[0x3];                                      // 0x0801(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         floor_value;                                       // 0x0804(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Auto_Sticky_Toggle;                                // 0x0808(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_809[0x7];                                      // 0x0809(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_StickySocketStruct         sticky_sockets_data;                               // 0x0810(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_820[0xB8];                                     // 0x0820(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 owning_skel;                                       // 0x08D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E0[0xC0];                                     // 0x08E0(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Foot_01_Height_Offset;                             // 0x09A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Foot_02_Height_Offset;                             // 0x09A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Foot_03_Height_Offset;                             // 0x09A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Foot_04_Height_Offset;                             // 0x09AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_DragonFeetSolver) == 0x000010, "Wrong alignment on FAnimNode_DragonFeetSolver");
static_assert(sizeof(FAnimNode_DragonFeetSolver) == 0x0009B0, "Wrong size on FAnimNode_DragonFeetSolver");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Dragon_Trace_Manager) == 0x0000D0, "Member 'FAnimNode_DragonFeetSolver::Dragon_Trace_Manager' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, use_trace_manager_component) == 0x0000D8, "Member 'FAnimNode_DragonFeetSolver::use_trace_manager_component' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, solver_identifier) == 0x0000DC, "Member 'FAnimNode_DragonFeetSolver::solver_identifier' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, dragon_input_data) == 0x0000E8, "Member 'FAnimNode_DragonFeetSolver::dragon_input_data' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, ik_type) == 0x0001A0, "Member 'FAnimNode_DragonFeetSolver::ik_type' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, trace_type) == 0x0001A1, "Member 'FAnimNode_DragonFeetSolver::trace_type' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Trace_Radius) == 0x0001A4, "Member 'FAnimNode_DragonFeetSolver::Trace_Radius' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, line_trace_hit_complex) == 0x0001A8, "Member 'FAnimNode_DragonFeetSolver::line_trace_hit_complex' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, trace_interval_duration) == 0x0001B8, "Member 'FAnimNode_DragonFeetSolver::trace_interval_duration' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Use_LOD_Specific_Intervals) == 0x0001BC, "Member 'FAnimNode_DragonFeetSolver::Use_LOD_Specific_Intervals' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, LOD0_Interval) == 0x0001C0, "Member 'FAnimNode_DragonFeetSolver::LOD0_Interval' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, LOD1_Interval) == 0x0001C4, "Member 'FAnimNode_DragonFeetSolver::LOD1_Interval' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, LOD2_Interval) == 0x0001C8, "Member 'FAnimNode_DragonFeetSolver::LOD2_Interval' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Use_Trace_Distance_Adapting) == 0x0001CC, "Member 'FAnimNode_DragonFeetSolver::Use_Trace_Distance_Adapting' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Trace_Max_Distance) == 0x0001D0, "Member 'FAnimNode_DragonFeetSolver::Trace_Max_Distance' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Use_Interval_Velocity_Curve) == 0x0001D4, "Member 'FAnimNode_DragonFeetSolver::Use_Interval_Velocity_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Interval_Velocity_Curve) == 0x0001D8, "Member 'FAnimNode_DragonFeetSolver::Interval_Velocity_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Override_Curve_Velocity) == 0x000260, "Member 'FAnimNode_DragonFeetSolver::Override_Curve_Velocity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, custom_velocity) == 0x000264, "Member 'FAnimNode_DragonFeetSolver::custom_velocity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, loc_interp_type) == 0x000268, "Member 'FAnimNode_DragonFeetSolver::loc_interp_type' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, rot_interp_type) == 0x000274, "Member 'FAnimNode_DragonFeetSolver::rot_interp_type' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, virtual_scale) == 0x000278, "Member 'FAnimNode_DragonFeetSolver::virtual_scale' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, feet_alpha_multiplier_array) == 0x000280, "Member 'FAnimNode_DragonFeetSolver::feet_alpha_multiplier_array' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, feet_extra_offset_array) == 0x000290, "Member 'FAnimNode_DragonFeetSolver::feet_extra_offset_array' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Overall_Feet_Rotation_Offset) == 0x0002A0, "Member 'FAnimNode_DragonFeetSolver::Overall_Feet_Rotation_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, automatic_leg_make) == 0x0002B8, "Member 'FAnimNode_DragonFeetSolver::automatic_leg_make' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Use_OptionalRef_Feet_As_Ref) == 0x0002B9, "Member 'FAnimNode_DragonFeetSolver::Use_OptionalRef_Feet_As_Ref' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, enable_solver) == 0x0002BA, "Member 'FAnimNode_DragonFeetSolver::enable_solver' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Work_Outside_PIE) == 0x0002BB, "Member 'FAnimNode_DragonFeetSolver::Work_Outside_PIE' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, OptionalRefPose) == 0x0002C0, "Member 'FAnimNode_DragonFeetSolver::OptionalRefPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, interpolate_only_z) == 0x0002D0, "Member 'FAnimNode_DragonFeetSolver::interpolate_only_z' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, shift_speed) == 0x0002D4, "Member 'FAnimNode_DragonFeetSolver::shift_speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Location_Lerp_Speed) == 0x0002E0, "Member 'FAnimNode_DragonFeetSolver::Location_Lerp_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, feet_rotation_speed) == 0x0002E4, "Member 'FAnimNode_DragonFeetSolver::feet_rotation_speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, ignore_shift_speed) == 0x0002E8, "Member 'FAnimNode_DragonFeetSolver::ignore_shift_speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Ignore_Lerping) == 0x0002E9, "Member 'FAnimNode_DragonFeetSolver::Ignore_Lerping' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Ignore_Location_Lerping) == 0x0002EA, "Member 'FAnimNode_DragonFeetSolver::Ignore_Location_Lerping' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Interpolation_Velocity_Curve) == 0x0002F0, "Member 'FAnimNode_DragonFeetSolver::Interpolation_Velocity_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Enable_Complex_Rotation_Method) == 0x000378, "Member 'FAnimNode_DragonFeetSolver::Enable_Complex_Rotation_Method' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, ComplexSimpleFoot_Velocity_Curve) == 0x000380, "Member 'FAnimNode_DragonFeetSolver::ComplexSimpleFoot_Velocity_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Trace_Channel) == 0x000448, "Member 'FAnimNode_DragonFeetSolver::Trace_Channel' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Anti_Trace_Channel) == 0x000449, "Member 'FAnimNode_DragonFeetSolver::Anti_Trace_Channel' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, FPS_Lerp_Treshold) == 0x00044C, "Member 'FAnimNode_DragonFeetSolver::FPS_Lerp_Treshold' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, line_trace_upper_height) == 0x000614, "Member 'FAnimNode_DragonFeetSolver::line_trace_upper_height' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, line_trace_down_height) == 0x000618, "Member 'FAnimNode_DragonFeetSolver::line_trace_down_height' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Trace_Down_Multiplier_Curve) == 0x000620, "Member 'FAnimNode_DragonFeetSolver::Trace_Down_Multiplier_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Use_Anti_Channel) == 0x0006A8, "Member 'FAnimNode_DragonFeetSolver::Use_Anti_Channel' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, use_footstep_listening) == 0x0006A9, "Member 'FAnimNode_DragonFeetSolver::use_footstep_listening' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, dragon_footsteps_component) == 0x0006B0, "Member 'FAnimNode_DragonFeetSolver::dragon_footsteps_component' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Should_Rotate_Feet) == 0x0006B8, "Member 'FAnimNode_DragonFeetSolver::Should_Rotate_Feet' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, show_trace_in_game) == 0x0006BA, "Member 'FAnimNode_DragonFeetSolver::show_trace_in_game' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, execute_in_preview) == 0x0006BB, "Member 'FAnimNode_DragonFeetSolver::execute_in_preview' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Character_Actor) == 0x0006C8, "Member 'FAnimNode_DragonFeetSolver::Character_Actor' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Enable_Pitch) == 0x0006D8, "Member 'FAnimNode_DragonFeetSolver::Enable_Pitch' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Enable_Roll) == 0x0006D9, "Member 'FAnimNode_DragonFeetSolver::Enable_Roll' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, character_direction_vector_CS) == 0x0006E0, "Member 'FAnimNode_DragonFeetSolver::character_direction_vector_CS' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, character_forward_direction_vector_CS) == 0x0006F8, "Member 'FAnimNode_DragonFeetSolver::character_forward_direction_vector_CS' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, poles_forward_direction_vector_CS) == 0x000710, "Member 'FAnimNode_DragonFeetSolver::poles_forward_direction_vector_CS' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Use_Four_Point_Feets) == 0x000728, "Member 'FAnimNode_DragonFeetSolver::Use_Four_Point_Feets' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Enable_Foot_Lift_Limit) == 0x000729, "Member 'FAnimNode_DragonFeetSolver::Enable_Foot_Lift_Limit' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Affect_Toes_Always) == 0x00072A, "Member 'FAnimNode_DragonFeetSolver::Affect_Toes_Always' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Finger_Alpha_Velocity_Curve) == 0x000730, "Member 'FAnimNode_DragonFeetSolver::Finger_Alpha_Velocity_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Max_Limb_Radius) == 0x0007B8, "Member 'FAnimNode_DragonFeetSolver::Max_Limb_Radius' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Feet_Lift_Warping) == 0x0007BC, "Member 'FAnimNode_DragonFeetSolver::Feet_Lift_Warping' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Feet_Lift_Warp_Multiplier) == 0x0007C0, "Member 'FAnimNode_DragonFeetSolver::Feet_Lift_Warp_Multiplier' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, feet_vertical_size) == 0x0007C4, "Member 'FAnimNode_DragonFeetSolver::feet_vertical_size' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Feet_Lift_Limit) == 0x0007C8, "Member 'FAnimNode_DragonFeetSolver::Feet_Lift_Limit' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, sticky_feet_mode) == 0x0007CC, "Member 'FAnimNode_DragonFeetSolver::sticky_feet_mode' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, sticky_feet_on_speed) == 0x0007D0, "Member 'FAnimNode_DragonFeetSolver::sticky_feet_on_speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, sticky_feet_off_speed) == 0x0007D4, "Member 'FAnimNode_DragonFeetSolver::sticky_feet_off_speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Sticky_Feet_Range) == 0x0007D8, "Member 'FAnimNode_DragonFeetSolver::Sticky_Feet_Range' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Lock_Feet_Rotation) == 0x0007DC, "Member 'FAnimNode_DragonFeetSolver::Lock_Feet_Rotation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, sticky_feets_data) == 0x0007E0, "Member 'FAnimNode_DragonFeetSolver::sticky_feets_data' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, sticky_floor_detection) == 0x000800, "Member 'FAnimNode_DragonFeetSolver::sticky_floor_detection' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, floor_value) == 0x000804, "Member 'FAnimNode_DragonFeetSolver::floor_value' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Auto_Sticky_Toggle) == 0x000808, "Member 'FAnimNode_DragonFeetSolver::Auto_Sticky_Toggle' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, sticky_sockets_data) == 0x000810, "Member 'FAnimNode_DragonFeetSolver::sticky_sockets_data' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, owning_skel) == 0x0008D8, "Member 'FAnimNode_DragonFeetSolver::owning_skel' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Foot_01_Height_Offset) == 0x0009A0, "Member 'FAnimNode_DragonFeetSolver::Foot_01_Height_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Foot_02_Height_Offset) == 0x0009A4, "Member 'FAnimNode_DragonFeetSolver::Foot_02_Height_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Foot_03_Height_Offset) == 0x0009A8, "Member 'FAnimNode_DragonFeetSolver::Foot_03_Height_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonFeetSolver, Foot_04_Height_Offset) == 0x0009AC, "Member 'FAnimNode_DragonFeetSolver::Foot_04_Height_Offset' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_PhysicsBoneStrip
// 0x0020 (0x0020 - 0x0000)
struct FDragonData_PhysicsBoneStrip final
{
public:
	struct FBoneReference                         Bone_Chain_Start;                                  // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Bone_Chain_End;                                    // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_PhysicsBoneStrip) == 0x000004, "Wrong alignment on FDragonData_PhysicsBoneStrip");
static_assert(sizeof(FDragonData_PhysicsBoneStrip) == 0x000020, "Wrong size on FDragonData_PhysicsBoneStrip");
static_assert(offsetof(FDragonData_PhysicsBoneStrip, Bone_Chain_Start) == 0x000000, "Member 'FDragonData_PhysicsBoneStrip::Bone_Chain_Start' has a wrong offset!");
static_assert(offsetof(FDragonData_PhysicsBoneStrip, Bone_Chain_End) == 0x000010, "Member 'FDragonData_PhysicsBoneStrip::Bone_Chain_End' has a wrong offset!");

// ScriptStruct DragonIKPlugin.AnimNode_DragonPhysicsSolver
// 0x0048 (0x0118 - 0x00D0)
struct FAnimNode_DragonPhysicsSolver final : public FAnimNode_DragonControlBase
{
public:
	uint8                                         Pad_D0[0x28];                                      // 0x00D0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 owning_skel;                                       // 0x00F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         physanim_tag_index;                                // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DragonPhysicsSolver) == 0x000008, "Wrong alignment on FAnimNode_DragonPhysicsSolver");
static_assert(sizeof(FAnimNode_DragonPhysicsSolver) == 0x000118, "Wrong size on FAnimNode_DragonPhysicsSolver");
static_assert(offsetof(FAnimNode_DragonPhysicsSolver, owning_skel) == 0x0000F8, "Member 'FAnimNode_DragonPhysicsSolver::owning_skel' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonPhysicsSolver, physanim_tag_index) == 0x000110, "Member 'FAnimNode_DragonPhysicsSolver::physanim_tag_index' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_FootPairData
// 0x0028 (0x0028 - 0x0000)
struct FDragonData_FootPairData final
{
public:
	class FName                                   CommonSpineBone;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ChildFollowBones;                                  // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDragonData_FootData>           Feet_Pair_Array;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_FootPairData) == 0x000008, "Wrong alignment on FDragonData_FootPairData");
static_assert(sizeof(FDragonData_FootPairData) == 0x000028, "Wrong size on FDragonData_FootPairData");
static_assert(offsetof(FDragonData_FootPairData, CommonSpineBone) == 0x000000, "Member 'FDragonData_FootPairData::CommonSpineBone' has a wrong offset!");
static_assert(offsetof(FDragonData_FootPairData, ChildFollowBones) == 0x000008, "Member 'FDragonData_FootPairData::ChildFollowBones' has a wrong offset!");
static_assert(offsetof(FDragonData_FootPairData, Feet_Pair_Array) == 0x000018, "Member 'FDragonData_FootPairData::Feet_Pair_Array' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_Type2MultiInput
// 0x0020 (0x0020 - 0x0000)
struct FDragonData_Type2MultiInput final
{
public:
	TArray<class FName>                           Spine_Structure;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FDragonData_FootPairData>       FeetRelatedData;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_Type2MultiInput) == 0x000008, "Wrong alignment on FDragonData_Type2MultiInput");
static_assert(sizeof(FDragonData_Type2MultiInput) == 0x000020, "Wrong size on FDragonData_Type2MultiInput");
static_assert(offsetof(FDragonData_Type2MultiInput, Spine_Structure) == 0x000000, "Member 'FDragonData_Type2MultiInput::Spine_Structure' has a wrong offset!");
static_assert(offsetof(FDragonData_Type2MultiInput, FeetRelatedData) == 0x000010, "Member 'FDragonData_Type2MultiInput::FeetRelatedData' has a wrong offset!");

// ScriptStruct DragonIKPlugin.AnimNode_DragonSpineSolver
// 0x0DD0 (0x0EA0 - 0x00D0)
struct alignas(0x10) FAnimNode_DragonSpineSolver final : public FAnimNode_DragonControlBase
{
public:
	bool                                          use_trace_manager_component;                       // 0x00D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         solver_identifier;                                 // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_MultiInput                 dragon_input_data;                                 // 0x00E0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x80];                                     // 0x0100(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          use_type2_input;                                   // 0x0180(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_Type2MultiInput            dragon_input_type2_data;                           // 0x0188(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Precision;                                         // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationLimit;                                     // 0x01AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxIterations;                                     // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDragonIKTraceManagerComponent*         Dragon_Trace_Manager;                              // 0x01B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         shift_speed;                                       // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               Trace_Channel;                                     // 0x01C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               Anti_Trace_Channel;                                // 0x01C5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIKTrace_Type_Plugin                          trace_type;                                        // 0x01C6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C7[0x1];                                      // 0x01C7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Trace_Radius;                                      // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          line_trace_hit_complex;                            // 0x01CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CD[0xF];                                      // 0x01CD(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         trace_interval_duration;                           // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_LOD_Specific_Intervals;                        // 0x01E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LOD0_Interval;                                     // 0x01E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LOD1_Interval;                                     // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LOD2_Interval;                                     // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Trace_Distance_Adapting;                       // 0x01F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F1[0x3];                                      // 0x01F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Trace_Max_Distance;                                // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Interval_Velocity_Curve;                       // 0x01F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x7];                                      // 0x01F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Interval_Velocity_Curve;                           // 0x0200(0x0088)(Edit, NativeAccessSpecifierPublic)
	bool                                          Override_Curve_Velocity;                           // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x3];                                      // 0x0289(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         custom_velocity;                                   // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Rotate_Around_Translate;                           // 0x0290(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESolverComplexityPluginEnum                   complexity_type;                                   // 0x0291(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore_Lerping;                                    // 0x0292(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_293[0x15];                                     // 0x0293(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         virtual_scale;                                     // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         line_trace_downward_height;                        // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         line_trace_upper_height;                           // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Anti_Channel;                                  // 0x02B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B5[0x13];                                     // 0x02B5(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          stabilize_pelvis_legs;                             // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Pelvis_UpSlopeStabilization_Alpha;                 // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pelvis_DownSlopeStabilization_Alpha;               // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          stabilize_chest_legs;                              // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Chest_UpSlopeStabilization_Alpha;                  // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chest_DownslopeStabilization_Alpha;                // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBoneReference                         Stabilization_Head_Bone;                           // 0x02E0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         Stabilization_Tail_Bone;                           // 0x02F0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          Use_Ducking_Feature;                               // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               Ducking_Trace_Channel;                             // 0x0301(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_302[0x2];                                      // 0x0302(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Ducking_Limit;                                     // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pelvis_Crouch_Height;                              // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pelvis_Crouch_Rotation_Intensity;                  // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Duck_Pelvis_Trace_Offset;                          // 0x0310(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chest_Crouch_Height;                               // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chest_Crouch_Rotation_Intensity;                   // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Duck_Chest_Trace_Offset;                           // 0x0330(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x230];                                    // 0x0348(0x0230)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Slanted_Height_Up_Offset;                          // 0x0578(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Slanted_Height_Down_Offset;                        // 0x0580(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         dip_multiplier;                                    // 0x0584(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         pelvis_adaptive_gravity;                           // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          reverse_fabrik;                                    // 0x058C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58D[0x7];                                      // 0x058D(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Calculation_To_RefPose;                            // 0x0594(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_595[0x3];                                      // 0x0595(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Chest_Slanted_Height_Up_Offset;                    // 0x0598(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chest_Slanted_Height_Down_Offset;                  // 0x059C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         chest_side_dip_multiplier;                         // 0x05A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         chest_adaptive_gravity;                            // 0x05A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chest_Base_Offset;                                 // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pelvis_Base_Offset;                                // 0x05AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         virtual_leg_width;                                 // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Maximum_Dip_Height;                                // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Pelvis_Height_Multiplier_Curve;                    // 0x05C0(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         Maximum_Dip_Height_Chest;                          // 0x0648(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64C[0x4];                                      // 0x064C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Chest_Height_Multiplier_Curve;                     // 0x0650(0x0088)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D8[0xC];                                      // 0x06D8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         rotation_power_between;                            // 0x06E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Automatic_Fabrik_Selection;                    // 0x06E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E9[0x3];                                      // 0x06E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Trace_Lerp_Speed;                                  // 0x06EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Location_Lerp_Speed;                               // 0x06F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F4[0x10];                                     // 0x06F4(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Rotation_Lerp_Speed;                               // 0x0704(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_708[0x8];                                      // 0x0708(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Interpolation_Multiplier_Curve;                    // 0x0710(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         Chest_Influence_Alpha;                             // 0x0798(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pelvis_ForwardRotation_Intensity;                  // 0x079C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pelvis_UpwardForwardRotation_Intensity;            // 0x07A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Body_Rotation_Intensity;                           // 0x07A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Pelvis_Rotation_Offset_Rotator;                    // 0x07A8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Chest_ForwardRotation_Intensity;                   // 0x07C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chest_UpwardForwardRotation_Intensity;             // 0x07C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Chest_SidewardRotation_Intensity;                  // 0x07C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7CC[0x4];                                      // 0x07CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Chest_Rotation_Offset_Rotator;                     // 0x07D0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E8[0x68];                                     // 0x07E8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Full_Extended_Spine;                               // 0x0850(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_851[0x3];                                      // 0x0851(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         max_extension_ratio;                               // 0x0854(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         min_extension_ratio;                               // 0x0858(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         extension_switch_speed;                            // 0x085C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_860[0x4];                                      // 0x0860(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          enable_solver;                                     // 0x0864(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Work_Outside_PIE;                                  // 0x0865(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Fake_Chest_Rotations;                          // 0x0866(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Fake_Pelvis_Rotations;                         // 0x0867(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_868[0x4];                                      // 0x0868(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Force_Activation;                                  // 0x086C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          accurate_feet_placement;                           // 0x086D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86E[0x2];                                      // 0x086E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Accurate_Foot_Curve;                               // 0x0870(0x0088)(Edit, NativeAccessSpecifierPublic)
	bool                                          use_crosshair_trace_also_for_fail_distance;        // 0x08F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Only_Root_Solve;                                   // 0x08F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore_Chest_Solve;                                // 0x08FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8FB[0xD];                                      // 0x08FB(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Overall_PostSolved_Offset;                         // 0x0908(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                character_direction_vector_CS;                     // 0x0920(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Forward_Direction_Vector;                          // 0x0938(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          flip_forward_and_right;                            // 0x0950(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_951[0x1F];                                     // 0x0951(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	ERefPosePluginEnum                            SolverReferencePose;                               // 0x0970(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Spine_Feet_Connect;                                // 0x0971(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_972[0x3C2];                                    // 0x0972(0x03C2)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Snake_Joint_Speed;                                 // 0x0D34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable_Snake_Interpolation;                        // 0x0D38(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          is_snake;                                          // 0x0D39(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Ignore_End_Points;                                 // 0x0D3A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D3B[0x1];                                      // 0x0D3B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Maximum_Feet_Distance;                             // 0x0D3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Minimum_Feet_Distance;                             // 0x0D40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisplayLineTrace;                                  // 0x0D44(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D45[0xB];                                      // 0x0D45(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 owning_skel;                                       // 0x0D50(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D58[0x8];                                      // 0x0D58(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Character_Actor;                                   // 0x0D60(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeleton*                              skeleton_ref;                                      // 0x0D68(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D70[0x130];                                    // 0x0D70(0x0130)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DragonSpineSolver) == 0x000010, "Wrong alignment on FAnimNode_DragonSpineSolver");
static_assert(sizeof(FAnimNode_DragonSpineSolver) == 0x000EA0, "Wrong size on FAnimNode_DragonSpineSolver");
static_assert(offsetof(FAnimNode_DragonSpineSolver, use_trace_manager_component) == 0x0000D0, "Member 'FAnimNode_DragonSpineSolver::use_trace_manager_component' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, solver_identifier) == 0x0000D4, "Member 'FAnimNode_DragonSpineSolver::solver_identifier' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, dragon_input_data) == 0x0000E0, "Member 'FAnimNode_DragonSpineSolver::dragon_input_data' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, use_type2_input) == 0x000180, "Member 'FAnimNode_DragonSpineSolver::use_type2_input' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, dragon_input_type2_data) == 0x000188, "Member 'FAnimNode_DragonSpineSolver::dragon_input_type2_data' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Precision) == 0x0001A8, "Member 'FAnimNode_DragonSpineSolver::Precision' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, RotationLimit) == 0x0001AC, "Member 'FAnimNode_DragonSpineSolver::RotationLimit' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, MaxIterations) == 0x0001B0, "Member 'FAnimNode_DragonSpineSolver::MaxIterations' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Dragon_Trace_Manager) == 0x0001B8, "Member 'FAnimNode_DragonSpineSolver::Dragon_Trace_Manager' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, shift_speed) == 0x0001C0, "Member 'FAnimNode_DragonSpineSolver::shift_speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Trace_Channel) == 0x0001C4, "Member 'FAnimNode_DragonSpineSolver::Trace_Channel' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Anti_Trace_Channel) == 0x0001C5, "Member 'FAnimNode_DragonSpineSolver::Anti_Trace_Channel' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, trace_type) == 0x0001C6, "Member 'FAnimNode_DragonSpineSolver::trace_type' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Trace_Radius) == 0x0001C8, "Member 'FAnimNode_DragonSpineSolver::Trace_Radius' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, line_trace_hit_complex) == 0x0001CC, "Member 'FAnimNode_DragonSpineSolver::line_trace_hit_complex' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, trace_interval_duration) == 0x0001DC, "Member 'FAnimNode_DragonSpineSolver::trace_interval_duration' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Use_LOD_Specific_Intervals) == 0x0001E0, "Member 'FAnimNode_DragonSpineSolver::Use_LOD_Specific_Intervals' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, LOD0_Interval) == 0x0001E4, "Member 'FAnimNode_DragonSpineSolver::LOD0_Interval' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, LOD1_Interval) == 0x0001E8, "Member 'FAnimNode_DragonSpineSolver::LOD1_Interval' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, LOD2_Interval) == 0x0001EC, "Member 'FAnimNode_DragonSpineSolver::LOD2_Interval' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Use_Trace_Distance_Adapting) == 0x0001F0, "Member 'FAnimNode_DragonSpineSolver::Use_Trace_Distance_Adapting' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Trace_Max_Distance) == 0x0001F4, "Member 'FAnimNode_DragonSpineSolver::Trace_Max_Distance' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Use_Interval_Velocity_Curve) == 0x0001F8, "Member 'FAnimNode_DragonSpineSolver::Use_Interval_Velocity_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Interval_Velocity_Curve) == 0x000200, "Member 'FAnimNode_DragonSpineSolver::Interval_Velocity_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Override_Curve_Velocity) == 0x000288, "Member 'FAnimNode_DragonSpineSolver::Override_Curve_Velocity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, custom_velocity) == 0x00028C, "Member 'FAnimNode_DragonSpineSolver::custom_velocity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Rotate_Around_Translate) == 0x000290, "Member 'FAnimNode_DragonSpineSolver::Rotate_Around_Translate' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, complexity_type) == 0x000291, "Member 'FAnimNode_DragonSpineSolver::complexity_type' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Ignore_Lerping) == 0x000292, "Member 'FAnimNode_DragonSpineSolver::Ignore_Lerping' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, virtual_scale) == 0x0002A8, "Member 'FAnimNode_DragonSpineSolver::virtual_scale' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, line_trace_downward_height) == 0x0002AC, "Member 'FAnimNode_DragonSpineSolver::line_trace_downward_height' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, line_trace_upper_height) == 0x0002B0, "Member 'FAnimNode_DragonSpineSolver::line_trace_upper_height' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Use_Anti_Channel) == 0x0002B4, "Member 'FAnimNode_DragonSpineSolver::Use_Anti_Channel' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, stabilize_pelvis_legs) == 0x0002C8, "Member 'FAnimNode_DragonSpineSolver::stabilize_pelvis_legs' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Pelvis_UpSlopeStabilization_Alpha) == 0x0002CC, "Member 'FAnimNode_DragonSpineSolver::Pelvis_UpSlopeStabilization_Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Pelvis_DownSlopeStabilization_Alpha) == 0x0002D0, "Member 'FAnimNode_DragonSpineSolver::Pelvis_DownSlopeStabilization_Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, stabilize_chest_legs) == 0x0002D4, "Member 'FAnimNode_DragonSpineSolver::stabilize_chest_legs' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Chest_UpSlopeStabilization_Alpha) == 0x0002D8, "Member 'FAnimNode_DragonSpineSolver::Chest_UpSlopeStabilization_Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Chest_DownslopeStabilization_Alpha) == 0x0002DC, "Member 'FAnimNode_DragonSpineSolver::Chest_DownslopeStabilization_Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Stabilization_Head_Bone) == 0x0002E0, "Member 'FAnimNode_DragonSpineSolver::Stabilization_Head_Bone' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Stabilization_Tail_Bone) == 0x0002F0, "Member 'FAnimNode_DragonSpineSolver::Stabilization_Tail_Bone' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Use_Ducking_Feature) == 0x000300, "Member 'FAnimNode_DragonSpineSolver::Use_Ducking_Feature' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Ducking_Trace_Channel) == 0x000301, "Member 'FAnimNode_DragonSpineSolver::Ducking_Trace_Channel' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Ducking_Limit) == 0x000304, "Member 'FAnimNode_DragonSpineSolver::Ducking_Limit' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Pelvis_Crouch_Height) == 0x000308, "Member 'FAnimNode_DragonSpineSolver::Pelvis_Crouch_Height' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Pelvis_Crouch_Rotation_Intensity) == 0x00030C, "Member 'FAnimNode_DragonSpineSolver::Pelvis_Crouch_Rotation_Intensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Duck_Pelvis_Trace_Offset) == 0x000310, "Member 'FAnimNode_DragonSpineSolver::Duck_Pelvis_Trace_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Chest_Crouch_Height) == 0x000328, "Member 'FAnimNode_DragonSpineSolver::Chest_Crouch_Height' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Chest_Crouch_Rotation_Intensity) == 0x00032C, "Member 'FAnimNode_DragonSpineSolver::Chest_Crouch_Rotation_Intensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Duck_Chest_Trace_Offset) == 0x000330, "Member 'FAnimNode_DragonSpineSolver::Duck_Chest_Trace_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Slanted_Height_Up_Offset) == 0x000578, "Member 'FAnimNode_DragonSpineSolver::Slanted_Height_Up_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Slanted_Height_Down_Offset) == 0x000580, "Member 'FAnimNode_DragonSpineSolver::Slanted_Height_Down_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, dip_multiplier) == 0x000584, "Member 'FAnimNode_DragonSpineSolver::dip_multiplier' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, pelvis_adaptive_gravity) == 0x000588, "Member 'FAnimNode_DragonSpineSolver::pelvis_adaptive_gravity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, reverse_fabrik) == 0x00058C, "Member 'FAnimNode_DragonSpineSolver::reverse_fabrik' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Calculation_To_RefPose) == 0x000594, "Member 'FAnimNode_DragonSpineSolver::Calculation_To_RefPose' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Chest_Slanted_Height_Up_Offset) == 0x000598, "Member 'FAnimNode_DragonSpineSolver::Chest_Slanted_Height_Up_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Chest_Slanted_Height_Down_Offset) == 0x00059C, "Member 'FAnimNode_DragonSpineSolver::Chest_Slanted_Height_Down_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, chest_side_dip_multiplier) == 0x0005A0, "Member 'FAnimNode_DragonSpineSolver::chest_side_dip_multiplier' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, chest_adaptive_gravity) == 0x0005A4, "Member 'FAnimNode_DragonSpineSolver::chest_adaptive_gravity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Chest_Base_Offset) == 0x0005A8, "Member 'FAnimNode_DragonSpineSolver::Chest_Base_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Pelvis_Base_Offset) == 0x0005AC, "Member 'FAnimNode_DragonSpineSolver::Pelvis_Base_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, virtual_leg_width) == 0x0005B0, "Member 'FAnimNode_DragonSpineSolver::virtual_leg_width' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Maximum_Dip_Height) == 0x0005B4, "Member 'FAnimNode_DragonSpineSolver::Maximum_Dip_Height' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Pelvis_Height_Multiplier_Curve) == 0x0005C0, "Member 'FAnimNode_DragonSpineSolver::Pelvis_Height_Multiplier_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Maximum_Dip_Height_Chest) == 0x000648, "Member 'FAnimNode_DragonSpineSolver::Maximum_Dip_Height_Chest' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Chest_Height_Multiplier_Curve) == 0x000650, "Member 'FAnimNode_DragonSpineSolver::Chest_Height_Multiplier_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, rotation_power_between) == 0x0006E4, "Member 'FAnimNode_DragonSpineSolver::rotation_power_between' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Use_Automatic_Fabrik_Selection) == 0x0006E8, "Member 'FAnimNode_DragonSpineSolver::Use_Automatic_Fabrik_Selection' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Trace_Lerp_Speed) == 0x0006EC, "Member 'FAnimNode_DragonSpineSolver::Trace_Lerp_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Location_Lerp_Speed) == 0x0006F0, "Member 'FAnimNode_DragonSpineSolver::Location_Lerp_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Rotation_Lerp_Speed) == 0x000704, "Member 'FAnimNode_DragonSpineSolver::Rotation_Lerp_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Interpolation_Multiplier_Curve) == 0x000710, "Member 'FAnimNode_DragonSpineSolver::Interpolation_Multiplier_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Chest_Influence_Alpha) == 0x000798, "Member 'FAnimNode_DragonSpineSolver::Chest_Influence_Alpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Pelvis_ForwardRotation_Intensity) == 0x00079C, "Member 'FAnimNode_DragonSpineSolver::Pelvis_ForwardRotation_Intensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Pelvis_UpwardForwardRotation_Intensity) == 0x0007A0, "Member 'FAnimNode_DragonSpineSolver::Pelvis_UpwardForwardRotation_Intensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Body_Rotation_Intensity) == 0x0007A4, "Member 'FAnimNode_DragonSpineSolver::Body_Rotation_Intensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Pelvis_Rotation_Offset_Rotator) == 0x0007A8, "Member 'FAnimNode_DragonSpineSolver::Pelvis_Rotation_Offset_Rotator' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Chest_ForwardRotation_Intensity) == 0x0007C0, "Member 'FAnimNode_DragonSpineSolver::Chest_ForwardRotation_Intensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Chest_UpwardForwardRotation_Intensity) == 0x0007C4, "Member 'FAnimNode_DragonSpineSolver::Chest_UpwardForwardRotation_Intensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Chest_SidewardRotation_Intensity) == 0x0007C8, "Member 'FAnimNode_DragonSpineSolver::Chest_SidewardRotation_Intensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Chest_Rotation_Offset_Rotator) == 0x0007D0, "Member 'FAnimNode_DragonSpineSolver::Chest_Rotation_Offset_Rotator' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Full_Extended_Spine) == 0x000850, "Member 'FAnimNode_DragonSpineSolver::Full_Extended_Spine' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, max_extension_ratio) == 0x000854, "Member 'FAnimNode_DragonSpineSolver::max_extension_ratio' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, min_extension_ratio) == 0x000858, "Member 'FAnimNode_DragonSpineSolver::min_extension_ratio' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, extension_switch_speed) == 0x00085C, "Member 'FAnimNode_DragonSpineSolver::extension_switch_speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, enable_solver) == 0x000864, "Member 'FAnimNode_DragonSpineSolver::enable_solver' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Work_Outside_PIE) == 0x000865, "Member 'FAnimNode_DragonSpineSolver::Work_Outside_PIE' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Use_Fake_Chest_Rotations) == 0x000866, "Member 'FAnimNode_DragonSpineSolver::Use_Fake_Chest_Rotations' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Use_Fake_Pelvis_Rotations) == 0x000867, "Member 'FAnimNode_DragonSpineSolver::Use_Fake_Pelvis_Rotations' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Force_Activation) == 0x00086C, "Member 'FAnimNode_DragonSpineSolver::Force_Activation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, accurate_feet_placement) == 0x00086D, "Member 'FAnimNode_DragonSpineSolver::accurate_feet_placement' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Accurate_Foot_Curve) == 0x000870, "Member 'FAnimNode_DragonSpineSolver::Accurate_Foot_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, use_crosshair_trace_also_for_fail_distance) == 0x0008F8, "Member 'FAnimNode_DragonSpineSolver::use_crosshair_trace_also_for_fail_distance' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Only_Root_Solve) == 0x0008F9, "Member 'FAnimNode_DragonSpineSolver::Only_Root_Solve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Ignore_Chest_Solve) == 0x0008FA, "Member 'FAnimNode_DragonSpineSolver::Ignore_Chest_Solve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Overall_PostSolved_Offset) == 0x000908, "Member 'FAnimNode_DragonSpineSolver::Overall_PostSolved_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, character_direction_vector_CS) == 0x000920, "Member 'FAnimNode_DragonSpineSolver::character_direction_vector_CS' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Forward_Direction_Vector) == 0x000938, "Member 'FAnimNode_DragonSpineSolver::Forward_Direction_Vector' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, flip_forward_and_right) == 0x000950, "Member 'FAnimNode_DragonSpineSolver::flip_forward_and_right' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, SolverReferencePose) == 0x000970, "Member 'FAnimNode_DragonSpineSolver::SolverReferencePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Spine_Feet_Connect) == 0x000971, "Member 'FAnimNode_DragonSpineSolver::Spine_Feet_Connect' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Snake_Joint_Speed) == 0x000D34, "Member 'FAnimNode_DragonSpineSolver::Snake_Joint_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Enable_Snake_Interpolation) == 0x000D38, "Member 'FAnimNode_DragonSpineSolver::Enable_Snake_Interpolation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, is_snake) == 0x000D39, "Member 'FAnimNode_DragonSpineSolver::is_snake' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Ignore_End_Points) == 0x000D3A, "Member 'FAnimNode_DragonSpineSolver::Ignore_End_Points' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Maximum_Feet_Distance) == 0x000D3C, "Member 'FAnimNode_DragonSpineSolver::Maximum_Feet_Distance' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Minimum_Feet_Distance) == 0x000D40, "Member 'FAnimNode_DragonSpineSolver::Minimum_Feet_Distance' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, DisplayLineTrace) == 0x000D44, "Member 'FAnimNode_DragonSpineSolver::DisplayLineTrace' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, owning_skel) == 0x000D50, "Member 'FAnimNode_DragonSpineSolver::owning_skel' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, Character_Actor) == 0x000D60, "Member 'FAnimNode_DragonSpineSolver::Character_Actor' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonSpineSolver, skeleton_ref) == 0x000D68, "Member 'FAnimNode_DragonSpineSolver::skeleton_ref' has a wrong offset!");

// ScriptStruct DragonIKPlugin.AnimNode_DragonTransformRelayer
// 0x00D8 (0x01A8 - 0x00D0)
struct FAnimNode_DragonTransformRelayer final : public FAnimNode_DragonControlBase
{
public:
	uint8                                         Pad_D0[0x28];                                      // 0x00D0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 owning_skel;                                       // 0x00F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDragonIKTransformReceiverComp*         transform_receiver_component;                      // 0x0100(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0xA0];                                     // 0x0108(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DragonTransformRelayer) == 0x000008, "Wrong alignment on FAnimNode_DragonTransformRelayer");
static_assert(sizeof(FAnimNode_DragonTransformRelayer) == 0x0001A8, "Wrong size on FAnimNode_DragonTransformRelayer");
static_assert(offsetof(FAnimNode_DragonTransformRelayer, owning_skel) == 0x0000F8, "Member 'FAnimNode_DragonTransformRelayer::owning_skel' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTransformRelayer, transform_receiver_component) == 0x000100, "Member 'FAnimNode_DragonTransformRelayer::transform_receiver_component' has a wrong offset!");

// ScriptStruct DragonIKPlugin.AnimNode_DragonTwistArmSolver
// 0x0930 (0x0A00 - 0x00D0)
struct FAnimNode_DragonTwistArmSolver final : public FAnimNode_DragonControlBase
{
public:
	uint8                                         Pad_D0[0x18];                                      // 0x00D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_ArmsData                   Hand_Input_Info;                                   // 0x00E8(0x0200)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E8[0x18];                                     // 0x02E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Target_Transform;                                  // 0x0300(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extra_Elbow_Pole_Offset;                           // 0x0360(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_378[0x3];                                      // 0x0378(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EPole_System_DragonIK                         pole_system_input;                                 // 0x037B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETwist_Type_DragonIK                          arm_twist_axis;                                    // 0x037C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotation_Type_DragonIK                       hand_rotation_method;                              // 0x037D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37E[0x127];                                    // 0x037E(0x0127)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Let_Arm_Twist_With_Hand;                           // 0x04A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          allow_arm_stretch;                                 // 0x04A6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A7[0xFE];                                     // 0x04A7(0x00FE)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Enable_Interpolation;                              // 0x05A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A6[0x2];                                      // 0x05A6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Interpolation_Speed;                               // 0x05A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5AC[0x64];                                     // 0x05AC(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAt_Axis;                                       // 0x0610(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Upward_Axis;                                       // 0x0628(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Physics_Adaptation;                            // 0x0640(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_641[0x3];                                      // 0x0641(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   physics_root_reference;                            // 0x0644(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64C[0x108];                                    // 0x064C(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DisplayLineTrace;                                  // 0x0754(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_755[0x3];                                      // 0x0755(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     Debug_Hand_Locations;                              // 0x0758(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_768[0x1D8];                                    // 0x0768(0x01D8)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 owning_skel;                                       // 0x0940(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_948[0xB8];                                     // 0x0948(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DragonTwistArmSolver) == 0x000010, "Wrong alignment on FAnimNode_DragonTwistArmSolver");
static_assert(sizeof(FAnimNode_DragonTwistArmSolver) == 0x000A00, "Wrong size on FAnimNode_DragonTwistArmSolver");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, Hand_Input_Info) == 0x0000E8, "Member 'FAnimNode_DragonTwistArmSolver::Hand_Input_Info' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, Target_Transform) == 0x000300, "Member 'FAnimNode_DragonTwistArmSolver::Target_Transform' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, Extra_Elbow_Pole_Offset) == 0x000360, "Member 'FAnimNode_DragonTwistArmSolver::Extra_Elbow_Pole_Offset' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, pole_system_input) == 0x00037B, "Member 'FAnimNode_DragonTwistArmSolver::pole_system_input' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, arm_twist_axis) == 0x00037C, "Member 'FAnimNode_DragonTwistArmSolver::arm_twist_axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, hand_rotation_method) == 0x00037D, "Member 'FAnimNode_DragonTwistArmSolver::hand_rotation_method' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, Let_Arm_Twist_With_Hand) == 0x0004A5, "Member 'FAnimNode_DragonTwistArmSolver::Let_Arm_Twist_With_Hand' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, allow_arm_stretch) == 0x0004A6, "Member 'FAnimNode_DragonTwistArmSolver::allow_arm_stretch' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, Enable_Interpolation) == 0x0005A5, "Member 'FAnimNode_DragonTwistArmSolver::Enable_Interpolation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, Interpolation_Speed) == 0x0005A8, "Member 'FAnimNode_DragonTwistArmSolver::Interpolation_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, LookAt_Axis) == 0x000610, "Member 'FAnimNode_DragonTwistArmSolver::LookAt_Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, Upward_Axis) == 0x000628, "Member 'FAnimNode_DragonTwistArmSolver::Upward_Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, Use_Physics_Adaptation) == 0x000640, "Member 'FAnimNode_DragonTwistArmSolver::Use_Physics_Adaptation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, physics_root_reference) == 0x000644, "Member 'FAnimNode_DragonTwistArmSolver::physics_root_reference' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, DisplayLineTrace) == 0x000754, "Member 'FAnimNode_DragonTwistArmSolver::DisplayLineTrace' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, Debug_Hand_Locations) == 0x000758, "Member 'FAnimNode_DragonTwistArmSolver::Debug_Hand_Locations' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonTwistArmSolver, owning_skel) == 0x000940, "Member 'FAnimNode_DragonTwistArmSolver::owning_skel' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_WarpLimbsData
// 0x0038 (0x0038 - 0x0000)
struct FDragonData_WarpLimbsData final
{
public:
	class FName                                   Foot_Bone_Name;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Knee_Bone_Name;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Thigh_Bone_Name;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Warp_Lift_Reference_Location;                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Warp_Param_Adder;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Min_Max_Warp;                                      // 0x0020(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         max_extra_compression_height;                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDragonData_WarpLimbsData) == 0x000008, "Wrong alignment on FDragonData_WarpLimbsData");
static_assert(sizeof(FDragonData_WarpLimbsData) == 0x000038, "Wrong size on FDragonData_WarpLimbsData");
static_assert(offsetof(FDragonData_WarpLimbsData, Foot_Bone_Name) == 0x000000, "Member 'FDragonData_WarpLimbsData::Foot_Bone_Name' has a wrong offset!");
static_assert(offsetof(FDragonData_WarpLimbsData, Knee_Bone_Name) == 0x000008, "Member 'FDragonData_WarpLimbsData::Knee_Bone_Name' has a wrong offset!");
static_assert(offsetof(FDragonData_WarpLimbsData, Thigh_Bone_Name) == 0x000010, "Member 'FDragonData_WarpLimbsData::Thigh_Bone_Name' has a wrong offset!");
static_assert(offsetof(FDragonData_WarpLimbsData, Warp_Lift_Reference_Location) == 0x000018, "Member 'FDragonData_WarpLimbsData::Warp_Lift_Reference_Location' has a wrong offset!");
static_assert(offsetof(FDragonData_WarpLimbsData, Warp_Param_Adder) == 0x00001C, "Member 'FDragonData_WarpLimbsData::Warp_Param_Adder' has a wrong offset!");
static_assert(offsetof(FDragonData_WarpLimbsData, Min_Max_Warp) == 0x000020, "Member 'FDragonData_WarpLimbsData::Min_Max_Warp' has a wrong offset!");
static_assert(offsetof(FDragonData_WarpLimbsData, max_extra_compression_height) == 0x000030, "Member 'FDragonData_WarpLimbsData::max_extra_compression_height' has a wrong offset!");

// ScriptStruct DragonIKPlugin.AnimNode_DragonWarpSolver
// 0x0600 (0x06D0 - 0x00D0)
struct alignas(0x10) FAnimNode_DragonWarpSolver final : public FAnimNode_DragonControlBase
{
public:
	TArray<struct FDragonData_WarpLimbsData>      dragon_limb_input;                                 // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   Hip_Bone_Name;                                     // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x44];                                      // 0x00E8(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          enable_solver;                                     // 0x012C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x18B];                                    // 0x012D(0x018B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                character_direction_vector_CS;                     // 0x02B8(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                forward_vector_CS;                                 // 0x02D0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         speed_warping_const;                               // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          enable_slope_warp;                                 // 0x02EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2ED[0x3];                                      // 0x02ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         automatic_speed_warping_const;                     // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         slope_detection_tolerance;                         // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Warp_Slope_Interpolation;                          // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FC[0x64];                                     // 0x02FC(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	ETraceTypeQuery                               Trace_Channel;                                     // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x3];                                      // 0x0361(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         line_trace_downward_height;                        // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         line_trace_upper_height;                           // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         virtual_leg_width;                                 // 0x036C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         virtual_scale;                                     // 0x0370(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DisplayLineTrace;                                  // 0x0378(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Limb_Compression_Intensity;                        // 0x037C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRuntimeFloatCurve                     Limb_Lifting_Curve;                                // 0x0380(0x0088)(Edit, NativeAccessSpecifierPublic)
	float                                         Hip_Change_Intensity;                              // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     Hip_Lifting_Curve;                                 // 0x0410(0x0088)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_498[0x210];                                    // 0x0498(0x0210)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 owning_skel;                                       // 0x06A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6B0[0x20];                                     // 0x06B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DragonWarpSolver) == 0x000010, "Wrong alignment on FAnimNode_DragonWarpSolver");
static_assert(sizeof(FAnimNode_DragonWarpSolver) == 0x0006D0, "Wrong size on FAnimNode_DragonWarpSolver");
static_assert(offsetof(FAnimNode_DragonWarpSolver, dragon_limb_input) == 0x0000D0, "Member 'FAnimNode_DragonWarpSolver::dragon_limb_input' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, Hip_Bone_Name) == 0x0000E0, "Member 'FAnimNode_DragonWarpSolver::Hip_Bone_Name' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, enable_solver) == 0x00012C, "Member 'FAnimNode_DragonWarpSolver::enable_solver' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, character_direction_vector_CS) == 0x0002B8, "Member 'FAnimNode_DragonWarpSolver::character_direction_vector_CS' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, forward_vector_CS) == 0x0002D0, "Member 'FAnimNode_DragonWarpSolver::forward_vector_CS' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, speed_warping_const) == 0x0002E8, "Member 'FAnimNode_DragonWarpSolver::speed_warping_const' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, enable_slope_warp) == 0x0002EC, "Member 'FAnimNode_DragonWarpSolver::enable_slope_warp' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, automatic_speed_warping_const) == 0x0002F0, "Member 'FAnimNode_DragonWarpSolver::automatic_speed_warping_const' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, slope_detection_tolerance) == 0x0002F4, "Member 'FAnimNode_DragonWarpSolver::slope_detection_tolerance' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, Warp_Slope_Interpolation) == 0x0002F8, "Member 'FAnimNode_DragonWarpSolver::Warp_Slope_Interpolation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, Trace_Channel) == 0x000360, "Member 'FAnimNode_DragonWarpSolver::Trace_Channel' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, line_trace_downward_height) == 0x000364, "Member 'FAnimNode_DragonWarpSolver::line_trace_downward_height' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, line_trace_upper_height) == 0x000368, "Member 'FAnimNode_DragonWarpSolver::line_trace_upper_height' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, virtual_leg_width) == 0x00036C, "Member 'FAnimNode_DragonWarpSolver::virtual_leg_width' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, virtual_scale) == 0x000370, "Member 'FAnimNode_DragonWarpSolver::virtual_scale' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, DisplayLineTrace) == 0x000378, "Member 'FAnimNode_DragonWarpSolver::DisplayLineTrace' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, Limb_Compression_Intensity) == 0x00037C, "Member 'FAnimNode_DragonWarpSolver::Limb_Compression_Intensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, Limb_Lifting_Curve) == 0x000380, "Member 'FAnimNode_DragonWarpSolver::Limb_Lifting_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, Hip_Change_Intensity) == 0x000408, "Member 'FAnimNode_DragonWarpSolver::Hip_Change_Intensity' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, Hip_Lifting_Curve) == 0x000410, "Member 'FAnimNode_DragonWarpSolver::Hip_Lifting_Curve' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWarpSolver, owning_skel) == 0x0006A8, "Member 'FAnimNode_DragonWarpSolver::owning_skel' has a wrong offset!");

// ScriptStruct DragonIKPlugin.AnimNode_DragonWeaponArmSolver
// 0x0A90 (0x0B60 - 0x00D0)
struct alignas(0x10) FAnimNode_DragonWeaponArmSolver final : public FAnimNode_DragonControlBase
{
public:
	class UDragonIKWeaponPhysicsComponent*        weapon_handler_component;                          // 0x00D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x7C];                                      // 0x00D8(0x007C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Physweapon_Component_Tag;                          // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDragonData_ArmsData>           Aiming_Hand_Limbs;                                 // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         primary_hand_index;                                // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x60];                                     // 0x016C(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	ETwist_Type_DragonIK                          arm_twist_axis;                                    // 0x01CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CD[0x128];                                    // 0x01CD(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Let_Arm_Twist_With_Hand;                           // 0x02F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F6[0xFF];                                     // 0x02F6(0x00FF)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Enable_Interpolation;                              // 0x03F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F6[0x2];                                      // 0x03F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Interpolation_Speed;                               // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FC[0x334];                                    // 0x03FC(0x0334)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LookAt_Axis;                                       // 0x0730(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Upward_Axis;                                       // 0x0748(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_760[0x148];                                    // 0x0760(0x0148)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          DisplayLineTrace;                                  // 0x08A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A9[0x7];                                      // 0x08A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTransform>                     Debug_Hand_Locations;                              // 0x08B0(0x0010)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C0[0x1E0];                                    // 0x08C0(0x01E0)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 owning_skel;                                       // 0x0AA0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA8[0xB8];                                     // 0x0AA8(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_DragonWeaponArmSolver) == 0x000010, "Wrong alignment on FAnimNode_DragonWeaponArmSolver");
static_assert(sizeof(FAnimNode_DragonWeaponArmSolver) == 0x000B60, "Wrong size on FAnimNode_DragonWeaponArmSolver");
static_assert(offsetof(FAnimNode_DragonWeaponArmSolver, weapon_handler_component) == 0x0000D0, "Member 'FAnimNode_DragonWeaponArmSolver::weapon_handler_component' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWeaponArmSolver, Physweapon_Component_Tag) == 0x000154, "Member 'FAnimNode_DragonWeaponArmSolver::Physweapon_Component_Tag' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWeaponArmSolver, Aiming_Hand_Limbs) == 0x000158, "Member 'FAnimNode_DragonWeaponArmSolver::Aiming_Hand_Limbs' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWeaponArmSolver, primary_hand_index) == 0x000168, "Member 'FAnimNode_DragonWeaponArmSolver::primary_hand_index' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWeaponArmSolver, arm_twist_axis) == 0x0001CC, "Member 'FAnimNode_DragonWeaponArmSolver::arm_twist_axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWeaponArmSolver, Let_Arm_Twist_With_Hand) == 0x0002F5, "Member 'FAnimNode_DragonWeaponArmSolver::Let_Arm_Twist_With_Hand' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWeaponArmSolver, Enable_Interpolation) == 0x0003F5, "Member 'FAnimNode_DragonWeaponArmSolver::Enable_Interpolation' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWeaponArmSolver, Interpolation_Speed) == 0x0003F8, "Member 'FAnimNode_DragonWeaponArmSolver::Interpolation_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWeaponArmSolver, LookAt_Axis) == 0x000730, "Member 'FAnimNode_DragonWeaponArmSolver::LookAt_Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWeaponArmSolver, Upward_Axis) == 0x000748, "Member 'FAnimNode_DragonWeaponArmSolver::Upward_Axis' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWeaponArmSolver, DisplayLineTrace) == 0x0008A8, "Member 'FAnimNode_DragonWeaponArmSolver::DisplayLineTrace' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWeaponArmSolver, Debug_Hand_Locations) == 0x0008B0, "Member 'FAnimNode_DragonWeaponArmSolver::Debug_Hand_Locations' has a wrong offset!");
static_assert(offsetof(FAnimNode_DragonWeaponArmSolver, owning_skel) == 0x000AA0, "Member 'FAnimNode_DragonWeaponArmSolver::owning_skel' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonTailChainLink
// 0x0260 (0x0260 - 0x0000)
struct alignas(0x10) FDragonTailChainLink final
{
public:
	uint8                                         Pad_0[0x260];                                      // 0x0000(0x0260)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDragonTailChainLink) == 0x000010, "Wrong alignment on FDragonTailChainLink");
static_assert(sizeof(FDragonTailChainLink) == 0x000260, "Wrong size on FDragonTailChainLink");

// ScriptStruct DragonIKPlugin.DragonData_TailBoneInput
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_TailBoneInput final
{
public:
	TArray<class FName>                           Custom_Bone_Structure;                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_TailBoneInput) == 0x000008, "Wrong alignment on FDragonData_TailBoneInput");
static_assert(sizeof(FDragonData_TailBoneInput) == 0x000010, "Wrong size on FDragonData_TailBoneInput");
static_assert(offsetof(FDragonData_TailBoneInput, Custom_Bone_Structure) == 0x000000, "Member 'FDragonData_TailBoneInput::Custom_Bone_Structure' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_TailHeightInput
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_TailHeightInput final
{
public:
	TArray<float>                                 Tail_Chain_Heights;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_TailHeightInput) == 0x000008, "Wrong alignment on FDragonData_TailHeightInput");
static_assert(sizeof(FDragonData_TailHeightInput) == 0x000010, "Wrong size on FDragonData_TailHeightInput");
static_assert(offsetof(FDragonData_TailHeightInput, Tail_Chain_Heights) == 0x000000, "Member 'FDragonData_TailHeightInput::Tail_Chain_Heights' has a wrong offset!");

// ScriptStruct DragonIKPlugin.AnimNode_TailSolver
// 0x02B0 (0x0380 - 0x00D0)
struct FAnimNode_TailSolver final : public FAnimNode_DragonControlBase
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HowToUse;                                          // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x28];                                      // 0x00E0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDragonData_TailBoneInput              Custom_Bone_Input;                                 // 0x0108(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x18];                                     // 0x0118(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          use_custom_heights;                                // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Tail_Bone_Height;                                  // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDragonData_TailHeightInput            Custom_Bone_Heights;                               // 0x0138(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FVector                                character_direction_vector_CS;                     // 0x0148(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_160[0x10];                                     // 0x0160(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Animation_Interpolation_Speed;                     // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               Trace_Channel;                                     // 0x0174(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          line_trace_hit_complex;                            // 0x0175(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Sphere_Trace;                                  // 0x0176(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_177[0x1];                                      // 0x0177(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Sphere_Trace_Radius;                               // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0xC4];                                     // 0x017C(0x00C4)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Trace_Up_Height;                                   // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Trace_Down_Height;                                 // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceBlock_Interpolation_Speed;                    // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceUnBlock_Interpolation_Speed;                  // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250[0x40];                                     // 0x0250(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         trace_interval_duration;                           // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_LOD_Specific_Intervals;                        // 0x0294(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_295[0x3];                                      // 0x0295(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LOD0_Interval;                                     // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LOD1_Interval;                                     // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LOD2_Interval;                                     // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Use_Trace_Distance_Adapting;                       // 0x02A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A5[0x3];                                      // 0x02A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Trace_Max_Distance;                                // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CachedEffectorCSTransform;                         // 0x02B0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 owning_skel;                                       // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_320[0x60];                                     // 0x0320(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_TailSolver) == 0x000010, "Wrong alignment on FAnimNode_TailSolver");
static_assert(sizeof(FAnimNode_TailSolver) == 0x000380, "Wrong size on FAnimNode_TailSolver");
static_assert(offsetof(FAnimNode_TailSolver, HowToUse) == 0x0000D8, "Member 'FAnimNode_TailSolver::HowToUse' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, Custom_Bone_Input) == 0x000108, "Member 'FAnimNode_TailSolver::Custom_Bone_Input' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, use_custom_heights) == 0x000130, "Member 'FAnimNode_TailSolver::use_custom_heights' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, Tail_Bone_Height) == 0x000134, "Member 'FAnimNode_TailSolver::Tail_Bone_Height' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, Custom_Bone_Heights) == 0x000138, "Member 'FAnimNode_TailSolver::Custom_Bone_Heights' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, character_direction_vector_CS) == 0x000148, "Member 'FAnimNode_TailSolver::character_direction_vector_CS' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, Animation_Interpolation_Speed) == 0x000170, "Member 'FAnimNode_TailSolver::Animation_Interpolation_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, Trace_Channel) == 0x000174, "Member 'FAnimNode_TailSolver::Trace_Channel' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, line_trace_hit_complex) == 0x000175, "Member 'FAnimNode_TailSolver::line_trace_hit_complex' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, Use_Sphere_Trace) == 0x000176, "Member 'FAnimNode_TailSolver::Use_Sphere_Trace' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, Sphere_Trace_Radius) == 0x000178, "Member 'FAnimNode_TailSolver::Sphere_Trace_Radius' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, Trace_Up_Height) == 0x000240, "Member 'FAnimNode_TailSolver::Trace_Up_Height' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, Trace_Down_Height) == 0x000244, "Member 'FAnimNode_TailSolver::Trace_Down_Height' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, TraceBlock_Interpolation_Speed) == 0x000248, "Member 'FAnimNode_TailSolver::TraceBlock_Interpolation_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, TraceUnBlock_Interpolation_Speed) == 0x00024C, "Member 'FAnimNode_TailSolver::TraceUnBlock_Interpolation_Speed' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, trace_interval_duration) == 0x000290, "Member 'FAnimNode_TailSolver::trace_interval_duration' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, Use_LOD_Specific_Intervals) == 0x000294, "Member 'FAnimNode_TailSolver::Use_LOD_Specific_Intervals' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, LOD0_Interval) == 0x000298, "Member 'FAnimNode_TailSolver::LOD0_Interval' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, LOD1_Interval) == 0x00029C, "Member 'FAnimNode_TailSolver::LOD1_Interval' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, LOD2_Interval) == 0x0002A0, "Member 'FAnimNode_TailSolver::LOD2_Interval' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, Use_Trace_Distance_Adapting) == 0x0002A4, "Member 'FAnimNode_TailSolver::Use_Trace_Distance_Adapting' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, Trace_Max_Distance) == 0x0002A8, "Member 'FAnimNode_TailSolver::Trace_Max_Distance' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, CachedEffectorCSTransform) == 0x0002B0, "Member 'FAnimNode_TailSolver::CachedEffectorCSTransform' has a wrong offset!");
static_assert(offsetof(FAnimNode_TailSolver, owning_skel) == 0x000318, "Member 'FAnimNode_TailSolver::owning_skel' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_PhysicsParentRelationship
// 0x0010 (0x0010 - 0x0000)
struct FDragonData_PhysicsParentRelationship final
{
public:
	class FName                                   child_bone_name;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   parent_bone_name;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_PhysicsParentRelationship) == 0x000004, "Wrong alignment on FDragonData_PhysicsParentRelationship");
static_assert(sizeof(FDragonData_PhysicsParentRelationship) == 0x000010, "Wrong size on FDragonData_PhysicsParentRelationship");
static_assert(offsetof(FDragonData_PhysicsParentRelationship, child_bone_name) == 0x000000, "Member 'FDragonData_PhysicsParentRelationship::child_bone_name' has a wrong offset!");
static_assert(offsetof(FDragonData_PhysicsParentRelationship, parent_bone_name) == 0x000008, "Member 'FDragonData_PhysicsParentRelationship::parent_bone_name' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonData_PhysicsHandleMultiplier
// 0x000C (0x000C - 0x0000)
struct FDragonData_PhysicsHandleMultiplier final
{
public:
	class FName                                   bone_name;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         bone_strength;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonData_PhysicsHandleMultiplier) == 0x000004, "Wrong alignment on FDragonData_PhysicsHandleMultiplier");
static_assert(sizeof(FDragonData_PhysicsHandleMultiplier) == 0x00000C, "Wrong size on FDragonData_PhysicsHandleMultiplier");
static_assert(offsetof(FDragonData_PhysicsHandleMultiplier, bone_name) == 0x000000, "Member 'FDragonData_PhysicsHandleMultiplier::bone_name' has a wrong offset!");
static_assert(offsetof(FDragonData_PhysicsHandleMultiplier, bone_strength) == 0x000008, "Member 'FDragonData_PhysicsHandleMultiplier::bone_strength' has a wrong offset!");

// ScriptStruct DragonIKPlugin.DragonIKTraceMParams
// 0x0138 (0x0138 - 0x0000)
struct alignas(0x08) FDragonIKTraceMParams final
{
public:
	uint8                                         Pad_0[0x138];                                      // 0x0000(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDragonIKTraceMParams) == 0x000008, "Wrong alignment on FDragonIKTraceMParams");
static_assert(sizeof(FDragonIKTraceMParams) == 0x000138, "Wrong size on FDragonIKTraceMParams");

// ScriptStruct DragonIKPlugin.DragonIKTraceParamKeyValuePair
// 0x0140 (0x0140 - 0x0000)
struct FDragonIKTraceParamKeyValuePair final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDragonIKTraceMParams                  trace_params;                                      // 0x0008(0x0138)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonIKTraceParamKeyValuePair) == 0x000008, "Wrong alignment on FDragonIKTraceParamKeyValuePair");
static_assert(sizeof(FDragonIKTraceParamKeyValuePair) == 0x000140, "Wrong size on FDragonIKTraceParamKeyValuePair");
static_assert(offsetof(FDragonIKTraceParamKeyValuePair, Key) == 0x000000, "Member 'FDragonIKTraceParamKeyValuePair::Key' has a wrong offset!");
static_assert(offsetof(FDragonIKTraceParamKeyValuePair, trace_params) == 0x000008, "Member 'FDragonIKTraceParamKeyValuePair::trace_params' has a wrong offset!");

// ScriptStruct DragonIKPlugin.CCDIK_Modified_ChainLink
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x10) FCCDIK_Modified_ChainLink final
{
public:
	uint8                                         Pad_0[0xA0];                                       // 0x0000(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCCDIK_Modified_ChainLink) == 0x000010, "Wrong alignment on FCCDIK_Modified_ChainLink");
static_assert(sizeof(FCCDIK_Modified_ChainLink) == 0x0000A0, "Wrong size on FCCDIK_Modified_ChainLink");

}

